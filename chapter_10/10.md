# Expressions

## 10.1 Introduction
این فصل عبارت‌ها را با جزئیات بررسی می‌کند. در ++C، انتساب یک عبارت است، فراخوانی تابع یک عبارت است، ساختنِ یک شیء یک عبارت است، و بسیاری عملیات دیگر که فراتر از ارزیابیِ متعارفِ عباراتِ حسابی می‌روند نیز عبارت‌اند. برای اینکه تصوری از چگونگیِ استفادهٔ عبارت‌ها بدهیم و آن‌ها را در بسترشان نشان دهیم، ابتدا یک برنامهٔ کوچک و کامل ارائه می‌کنم: یک «ماشین‌حساب رومیزی» ساده. سپس مجموعهٔ کاملِ عملگرها فهرست می‌شود و معنای آن‌ها برای نوع‌های درون‌ساخت به‌اختصار بیان می‌گردد. عملگرهایی که به توضیح گسترده‌تری نیاز دارند در فصل ۱۱ بررسی می‌شوند.

## 10.2 A Desk Calculator
یک برنامهٔ سادهٔ «ماشین‌حساب رومیزی» را در نظر بگیرید که چهار عمل استاندارد حسابی را به‌صورت عملگرهای میانوندی روی اعداد ممیز شناور فراهم می‌کند. کاربر همچنین می‌تواند متغیر تعریف کند. برای نمونه، اگر ورودی چنین باشد:

```
r = 2.5
area = pi * r * r
```

(pi از پیش تعریف شده است) برنامهٔ ماشین‌حساب می‌نویسد:

```
2.5
19.635
```

که در آن 2.5 نتیجهٔ خطِ نخستِ ورودی و 19.635 نتیجهٔ خطِ دوم است.

این ماشین‌حساب از چهار بخش اصلی تشکیل شده است: یک «تجزیه‌گر» (parser)، یک «تابع ورودی»، یک «جدول نمادها»، و یک «راه‌انداز» (driver). در واقع، این یک کامپایلر کوچک است که در آن تجزیه‌گر تحلیل نحوی را انجام می‌دهد، تابع ورودی مسئولِ دریافت ورودی و تحلیل واژگانی است، جدول نمادها اطلاعاتِ دائمی را نگه می‌دارد، و راه‌انداز وظیفهٔ مقداردهیِ اولیه، خروجی، و رسیدگی به خطاها را بر عهده دارد. می‌توانستیم قابلیت‌های بسیاری به این ماشین‌حساب بیفزاییم تا کاربردی‌تر شود، اما همین حالا هم کد به‌اندازهٔ کافی طولانی است و بیشترِ آن قابلیت‌ها فقط کد بیشتری اضافه می‌کنند بی‌آن‌که بینش بیشتری دربارهٔ استفاده از ++C فراهم کنند.

## 10.2.1 The Parser
در اینجا دستور زبان (grammar) زبانی که ماشین‌حساب می‌پذیرد آمده است:

```
program:
    end                 // end یعنی پایانِ ورودی
    expr_list end

expr_list:
    expression print    // print یعنی سطرِ جدید (newline) یا نقطه‌ویرگول (;)
    expression print expr_list

expression:
    expression + term
    expression − term
    term

term:
    term / primary
    term ∗ primary
    primary

primary:
    number              // number یعنی یک عددِ ممیز شناور (literal)
    name                // name یعنی یک شناسه (identifier)
    name = expression
    − primary
    ( expression )
```

به بیان دیگر، یک «برنامه» دنباله‌ای از عبارت‌هاست که با نقطه‌ویرگول از هم جدا می‌شوند. واحدهای پایهٔ یک عبارت عبارت‌اند از عددها، نام‌ها، و عملگرهای ∗ و / و + و − (هم یکانی و هم دوتایی) و نیز = (انتساب). نام‌ها لازم نیست پیش از استفاده اعلان شوند.

من از سبکی برای تحلیل نحو (syntax analysis) استفاده می‌کنم که «نزول بازگشتی» (recursive descent) نام دارد؛ روشی سرراست و رایج از بالا به پایین است. در زبانی مانند ++C که فراخوانیِ تابع ارزان است، این روش کارآمد هم هست. برای هر قاعدهٔ دستور زبان، تابعی داریم که توابع دیگر را فراخوانی می‌کند. نشانه‌های پایانه (terminal) – مانند end، number، + و − – توسط «تحلیلگر واژگانی» (lexer) تشخیص داده می‌شوند و نشانه‌های ناپایانه توسط توابعِ تحلیلگر نحوی، یعنی ‎`expr()`‎، ‎`term()`‎، و ‎`prim()`‎. همین که هر دو عملوند یک (زیر)عبارت معلوم شد، عبارت ارزیابی می‌شود؛ در یک کامپایلر واقعی، در همین نقطه می‌توان کد تولید کرد.

برای ورودی، تجزیه‌گر از ‎`Token_stream`‎ استفاده می‌کند که خواندن کاراکترها و ساختنِ آن‌ها به «نشانه»ها (Token) را در خود کپسوله می‌کند. یعنی ‎`Token_stream`‎ «توکن‌سازی» می‌کند: دنباله‌های کاراکتری مثل ‎`123.45`‎ را به Token تبدیل می‌کند. یک Token جفتِ ‎`{kind-of-token, value}`‎ است، مانند ‎`{number, 123.45}`‎ که در آن 123.45 به مقدار ممیز شناور تبدیل شده است. بخش‌های اصلیِ تجزیه‌گر فقط لازم است نامِ ‎`Token_stream`‎ (مثلاً ‎`ts`‎) را بدانند و این‌که چگونه از آن Token بگیرند: برای خواندنِ Token بعدی ‎`ts.get()`‎ را صدا می‌زنند؛ برای گرفتنِ آخرین Token خوانده‌شده (Token «جاری») ‎`ts.current()`‎ را. افزون بر توکن‌سازی، ‎`Token_stream`‎ منبع واقعیِ کاراکترها را پنهان می‌کند: خواه از تایپ مستقیمِ کاربر روی ‎`cin`‎ بیاید، خواه از خطِ فرمانِ برنامه، یا هر جریانِ ورودیِ دیگری (§10.2.7).

تعریفِ ‎`Token`‎ چنین است:

```cpp
enum class Kind : char {
    name, number, end,
    plus='+', minus='−', mul='∗', div='/', print=';', assign='=', lp='(', rp=')'
};

struct Token {
    Kind   kind;
    string string_value;
    double number_value;
};
```

نمایشِ هر Token با مقدارِ صحیحِ کاراکترِ متناظر، هم راحت و هم کارآمد است و به کارِ رفع‌اشکال هم می‌آید. این روش تا وقتی کار می‌کند که هیچ کاراکتری که به‌عنوان ورودی به‌کار می‌رود، ارزشی برابر با یکی از شمارشگرها نداشته باشد – و در هیچ مجموعه‌کاراکترِ امروزی‌ای که می‌شناسم، کاراکترِ قابلِ چاپی با مقدارِ صحیحِ تک‌رقمی وجود ندارد.

واسطِ ‎`Token_stream`‎ چنین است:

```cpp
class Token_stream {
public:
    Token get();            // خواندن و برگرداندنِ Token بعدی
    const Token& current(); // آخرین Token خوانده‌شده
    // ...
};
```

پیاده‌سازی در §10.2.2 آمده است.

هر تابعِ پارسر یک آرگومانِ ‎`bool`‎ به نامِ ‎`get`‎ می‌گیرد (§6.2.2) که مشخص می‌کند آیا لازم است ‎`Token_stream::get()`‎ را برای گرفتنِ Token بعدی صدا بزند یا نه. هر تابعِ پارسر «عبارتِ خودش» را ارزیابی می‌کند و مقدار را برمی‌گرداند. تابع ‎`expr()`‎ جمع و تفریق را رسیدگی می‌کند. این تابع یک حلقهٔ واحد دارد که به‌دنبال جملات (term)ی برای جمع یا تفریق می‌گردد:

```cpp
double expr(bool get) // جمع و تفریق
{
    double left = term(get);
    for (;;) {           // «تا ابد»
        switch (ts.current().kind) {
        case Kind::plus:
            left += term(true);
            break;
        case Kind::minus:
            left -= term(true);
            break;
        default:
            return left;
        }
    }
}
```

این تابع خودش کارِ زیادی انجام نمی‌دهد. به‌طور典型 برای توابعِ سطحِ بالاتر در یک برنامهٔ بزرگ، کار را به توابعِ دیگر واگذار می‌کند.

عبارتِ ‎`switch`‎ (§2.2.4، §9.4.2) مقدارِ شرطِ داخل پرانتز پس از کلیدواژهٔ ‎`switch`‎ را با مجموعه‌ای از ثابت‌ها مقایسه می‌کند. ‎`break`‎ برای خروج از ‎`switch`‎ به‌کار می‌رود. اگر مقدارِ آزمایش‌شده با هیچ برچسبِ ‎`case`‎ای تطبیق نکند، ‎`default`‎ انتخاب می‌شود؛ نویسندهٔ برنامه مجبور نیست ‎`default`‎ بنویسد.

توجه کنید عبارتی مانند ‎`2−3+4`‎ مطابقِ دستور زبان به‌صورت ‎`(2−3)+4`‎ ارزیابی می‌شود. نگارشِ کنجکاوانهٔ ‎`for(;;)`‎ راهی برای مشخص‌کردن یک حلقهٔ بی‌نهایت است؛ می‌توانید آن را «forever» تلفظ کنید (§9.5). ‎`while(true)`‎ هم جایگزینی برای آن است. ‎`switch`‎ بارها و بارها اجرا می‌شود تا چیزی غیر از ‎`+`‎ و ‎`−`‎ پیدا کند، و سپس ‎`return`‎ در شاخهٔ ‎`default`‎ اجرا می‌شود.

عملگرهای ‎`+=`‎ و ‎`-=`‎ برای جمع و تفریق به‌کار رفته‌اند؛ می‌شد ‎`left = left + term(true)`‎ و ‎`left = left - term(true)`‎ نوشت بی‌آن‌که معنای برنامه عوض شود، اما ‎`left += term(true)`‎ و ‎`left -= term(true)`‎ هم کوتاه‌ترند و هم مقصود را مستقیم‌تر بیان می‌کنند. هر عملگرِ انتساب یک Tokenِ واژگانی جداست، پس ‎`a + = 1;`‎ – به‌دلیل فاصله بین ‎`+`‎ و ‎`=`‎ – خطای نحوی است.

++C برای عملگرهای دوتاییِ زیر عملگرِ انتساب متناظر فراهم می‌کند:

```
+  −  ∗  /  %  &  |  ˆ  <<  >>
```

و در نتیجه این عملگرهای انتساب ممکن‌اند:

```
=  +=  −=  ∗=  /=  %=  &=  |=  ˆ=  <<=  >>=
```

‎`%`‎ عملگرِ باقیمانده (modulo) است؛ ‎`&`‎، ‎`|`‎ و ‎`ˆ`‎ عملگرهای بیتیِ منطقیِ and، or و «xor» هستند؛ ‎`<<`‎ و ‎`>>`‎ عملگرِ شیفتِ چپ و راست‌اند؛ §10.3 عملگرها و معانی‌شان را خلاصه می‌کند. برای یک عملگرِ دوتاییِ ‎`@`‎ که روی عملوندهای نوع‌های درون‌ساخت اعمال می‌شود، عبارتِ ‎`x @= y`‎ یعنی ‎`x = x @ y`‎، با این تفاوت که ‎`x`‎ فقط یک بار ارزیابی می‌شود.

تابعِ ‎`term()`‎ ضرب و تقسیم را همان‌گونه رسیدگی می‌کند که ‎`expr()`‎ جمع و تفریق را:

```cpp
double term(bool get) // ضرب و تقسیم
{
    double left = prim(get);
    for (;;) {
        switch (ts.current().kind) {
        case Kind::mul:
            left *= prim(true);
            break;
        case Kind::div:
            if (auto d = prim(true)) {
                left /= d;
                break;
            }
            return error("divide by 0");
        default:
            return left;
        }
    }
}
```

نتیجهٔ تقسیم بر صفر نامعین و معمولاً فاجعه‌بار است؛ بنابراین پیش از تقسیم، صفر بودن را می‌آزماییم و اگر مقسومٌ‌علیهِ صفر بود ‎`error()`‎ را صدا می‌زنیم. ‎`error()`‎ در §10.2.4 توصیف شده است. متغیر ‎`d`‎ دقیقاً همان‌جا که لازم است معرفی و بلافاصله مقداردهی می‌شود. حوزهٔ نامی که در شرط معرفی می‌شود، همان جمله‌ای است که آن شرط کنترل می‌کند و مقدارِ حاصل هم مقدارِ همان شرط است (§9.4.3). در نتیجه، تقسیم و انتسابِ ‎`left /= d`‎ فقط و فقط وقتی انجام می‌شود که ‎`d`‎ ناصفر باشد.

تابعِ ‎`prim()`‎ که یک «اولیه» (primary) را رسیدگی می‌کند، شبیه ‎`expr()`‎ و ‎`term()`‎ است، جز این‌که چون پایین‌تر در سلسله‌مراتبِ فراخوانی قرار گرفته‌ایم، کمی «کار واقعی» انجام می‌شود و دیگر نیازی به حلقه نیست:

```cpp
double prim(bool get) // رسیدگی به primary
{
    if (get) ts.get(); // Token بعدی را بخوان
    switch (ts.current().kind) {
    case Kind::number: {                // ثابتِ ممیز شناور
        double v = ts.current().number_value;
        ts.get();
        return v;
    }
    case Kind::name: {                  // یک نام (شناسه)
        double& v = table[ts.current().string_value]; // مقدارِ متناظر را بیاب
        if (ts.get().kind == Kind::assign)            // اگر '=' دیدیم: انتساب
            v = expr(true);
        return v;
    }
    case Kind::minus:                   // منفیِ یکانی
        return -prim(true);
    case Kind::lp: {                    // '('
        auto e = expr(true);
        if (ts.current().kind != Kind::rp)
            return error("')' expected");
        ts.get();                       // ')' را بخور
        return e;
    }
    default:
        return error("primary expected");
    }
}
```

وقتی یک ‎`Token`‎ از نوعِ «عدد» (عدد صحیح یا ممیز شناورِ literal) دیده می‌شود، مقدارش در ‎`number_value`‎ قرار می‌گیرد. به‌طور مشابه، وقتی ‎`Token`‎ی که «نام» است (هر طور تعریف شده؛ §10.2.2 و §10.2.3 را ببینید) دیده شود، مقدارش در ‎`string_value`‎ گذاشته می‌شود.

توجه کنید ‎`prim()`‎ همیشه یک ‎`Token`‎ بیش از آن‌چه برای تحلیلِ عبارتِ اولیه‌اش استفاده می‌کند می‌خوانَد. دلیلش این است که در برخی حالت‌ها مجبور است چنین کند (مثلاً برای این‌که ببیند آیا به یک نام انتساب می‌شود یا فقط خوانده می‌شود)؛ بنابراین، برای یکنواختی، در همهٔ حالت‌ها چنین می‌کند. در جاهایی که یک تابعِ پارسر فقط می‌خواهد به Tokenِ بعدی برود، از مقدارِ بازگشتیِ ‎`ts.get()`‎ استفاده نمی‌کند – اشکالی ندارد، چون می‌توانیم نتیجه را از ‎`ts.current()`‎ بگیریم. اگر بی‌اعتنایی به مقدارِ بازگشتیِ ‎`get()`‎ آزارم می‌داد، یا یک تابعِ ‎`read()`‎ اضافه می‌کردم که فقط ‎`current()`‎ را به‌روز کند و چیزی برنگرداند، یا صراحتاً نتیجه را «دور می‌ریختم»: ‎`void(ts.get());`‎.

پیش از انجام هرکاری با یک نام، ماشین‌حساب باید جلوتر را ببیند که آیا به آن انتساب می‌شود یا فقط خوانده می‌شود. در هر دو حالت، «جدولِ نمادها» (symbol table) مشورت می‌شود. جدول نمادها یک ‎`map`‎ است (§4.4.3، §31.4.3):

```cpp
map<string,double> table;
```

یعنی وقتی ‎`table`‎ با یک ‎`string`‎ اندیس‌گذاری شود، مقدارِ حاصل یک ‎`double`‎ متناظر با آن رشته است. مثلاً اگر کاربر بنویسد:

```cpp
radius = 6378.388;
```

ماشین‌حساب به ‎`case Kind::name`‎ می‌رسد و این‌ها اجرا می‌شوند:

```cpp
double& v = table["radius"];
// ... expr() مقدارِ قابلِ انتساب را محاسبه می‌کند ...
v = 6378.388;
```

ارجاعِ ‎`v`‎ برای نگه‌داشتنِ ‎`double`‎ متناظر با ‎`radius`‎ به‌کار می‌رود، در حالی که ‎`expr()`‎ مقدارِ ‎`6378.388`‎ را از کاراکترهای ورودی محاسبه می‌کند.

فصل‌های 14 و 15 دربارهٔ سازمان‌دهیِ برنامه به صورت مجموعه‌ای از ماژول‌ها بحث می‌کنند. با این حال – به‌جز یک مورد – اعلان‌های این مثالِ ماشین‌حساب را می‌توان طوری مرتب کرد که هر چیز دقیقاً یک‌بار و پیش از استفاده اعلان شود. استثنا ‎`expr()`‎ است که ‎`term()`‎ را صدا می‌زند، ‎`term()`‎ ‎`prim()`‎ را، و ‎`prim()`‎ هم دوباره ‎`expr()`‎ را؛ این حلقهٔ فراخوانی باید به‌نحوی شکسته شود. یک اعلانِ

```cpp
double expr(bool);
```

پیش از تعریفِ ‎`prim()`‎ به‌خوبی از عهدهٔ این کار برمی‌آید.
