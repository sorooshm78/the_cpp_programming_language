# Expressions

## 10.1 Introduction
این فصل عبارت‌ها را با جزئیات بررسی می‌کند. در ++C، انتساب یک عبارت است، فراخوانی تابع یک عبارت است، ساختنِ یک شیء یک عبارت است، و بسیاری عملیات دیگر که فراتر از ارزیابیِ متعارفِ عباراتِ حسابی می‌روند نیز عبارت‌اند. برای اینکه تصوری از چگونگیِ استفادهٔ عبارت‌ها بدهیم و آن‌ها را در بسترشان نشان دهیم، ابتدا یک برنامهٔ کوچک و کامل ارائه می‌کنم: یک «ماشین‌حساب رومیزی» ساده. سپس مجموعهٔ کاملِ عملگرها فهرست می‌شود و معنای آن‌ها برای نوع‌های درون‌ساخت به‌اختصار بیان می‌گردد. عملگرهایی که به توضیح گسترده‌تری نیاز دارند در فصل ۱۱ بررسی می‌شوند.

## 10.2 A Desk Calculator
یک برنامهٔ سادهٔ «ماشین‌حساب رومیزی» را در نظر بگیرید که چهار عمل استاندارد حسابی را به‌صورت عملگرهای میانوندی روی اعداد ممیز شناور فراهم می‌کند. کاربر همچنین می‌تواند متغیر تعریف کند. برای نمونه، اگر ورودی چنین باشد:

```
r = 2.5
area = pi * r * r
```

(pi از پیش تعریف شده است) برنامهٔ ماشین‌حساب می‌نویسد:

```
2.5
19.635
```

که در آن 2.5 نتیجهٔ خطِ نخستِ ورودی و 19.635 نتیجهٔ خطِ دوم است.

این ماشین‌حساب از چهار بخش اصلی تشکیل شده است: یک «تجزیه‌گر» (parser)، یک «تابع ورودی»، یک «جدول نمادها»، و یک «راه‌انداز» (driver). در واقع، این یک کامپایلر کوچک است که در آن تجزیه‌گر تحلیل نحوی را انجام می‌دهد، تابع ورودی مسئولِ دریافت ورودی و تحلیل واژگانی است، جدول نمادها اطلاعاتِ دائمی را نگه می‌دارد، و راه‌انداز وظیفهٔ مقداردهیِ اولیه، خروجی، و رسیدگی به خطاها را بر عهده دارد. می‌توانستیم قابلیت‌های بسیاری به این ماشین‌حساب بیفزاییم تا کاربردی‌تر شود، اما همین حالا هم کد به‌اندازهٔ کافی طولانی است و بیشترِ آن قابلیت‌ها فقط کد بیشتری اضافه می‌کنند بی‌آن‌که بینش بیشتری دربارهٔ استفاده از ++C فراهم کنند.

## 10.2.1 The Parser
در اینجا دستور زبان (grammar) زبانی که ماشین‌حساب می‌پذیرد آمده است:

```
program:
    end                 // end یعنی پایانِ ورودی
    expr_list end

expr_list:
    expression print    // print یعنی سطرِ جدید (newline) یا نقطه‌ویرگول (;)
    expression print expr_list

expression:
    expression + term
    expression − term
    term

term:
    term / primary
    term ∗ primary
    primary

primary:
    number              // number یعنی یک عددِ ممیز شناور (literal)
    name                // name یعنی یک شناسه (identifier)
    name = expression
    − primary
    ( expression )
```

به بیان دیگر، یک «برنامه» دنباله‌ای از عبارت‌هاست که با نقطه‌ویرگول از هم جدا می‌شوند. واحدهای پایهٔ یک عبارت عبارت‌اند از عددها، نام‌ها، و عملگرهای ∗ و / و + و − (هم یکانی و هم دوتایی) و نیز = (انتساب). نام‌ها لازم نیست پیش از استفاده اعلان شوند.

من از سبکی برای تحلیل نحو (syntax analysis) استفاده می‌کنم که «نزول بازگشتی» (recursive descent) نام دارد؛ روشی سرراست و رایج از بالا به پایین است. در زبانی مانند ++C که فراخوانیِ تابع ارزان است، این روش کارآمد هم هست. برای هر قاعدهٔ دستور زبان، تابعی داریم که توابع دیگر را فراخوانی می‌کند. نشانه‌های پایانه (terminal) – مانند end، number، + و − – توسط «تحلیلگر واژگانی» (lexer) تشخیص داده می‌شوند و نشانه‌های ناپایانه توسط توابعِ تحلیلگر نحوی، یعنی ‎`expr()`‎، ‎`term()`‎، و ‎`prim()`‎. همین که هر دو عملوند یک (زیر)عبارت معلوم شد، عبارت ارزیابی می‌شود؛ در یک کامپایلر واقعی، در همین نقطه می‌توان کد تولید کرد.

برای ورودی، تجزیه‌گر از ‎`Token_stream`‎ استفاده می‌کند که خواندن کاراکترها و ساختنِ آن‌ها به «نشانه»ها (Token) را در خود کپسوله می‌کند. یعنی ‎`Token_stream`‎ «توکن‌سازی» می‌کند: دنباله‌های کاراکتری مثل ‎`123.45`‎ را به Token تبدیل می‌کند. یک Token جفتِ ‎`{kind-of-token, value}`‎ است، مانند ‎`{number, 123.45}`‎ که در آن 123.45 به مقدار ممیز شناور تبدیل شده است. بخش‌های اصلیِ تجزیه‌گر فقط لازم است نامِ ‎`Token_stream`‎ (مثلاً ‎`ts`‎) را بدانند و این‌که چگونه از آن Token بگیرند: برای خواندنِ Token بعدی ‎`ts.get()`‎ را صدا می‌زنند؛ برای گرفتنِ آخرین Token خوانده‌شده (Token «جاری») ‎`ts.current()`‎ را. افزون بر توکن‌سازی، ‎`Token_stream`‎ منبع واقعیِ کاراکترها را پنهان می‌کند: خواه از تایپ مستقیمِ کاربر روی ‎`cin`‎ بیاید، خواه از خطِ فرمانِ برنامه، یا هر جریانِ ورودیِ دیگری (§10.2.7).

تعریفِ ‎`Token`‎ چنین است:

```cpp
enum class Kind : char {
    name, number, end,
    plus='+', minus='−', mul='∗', div='/', print=';', assign='=', lp='(', rp=')'
};

struct Token {
    Kind   kind;
    string string_value;
    double number_value;
};
```

نمایشِ هر Token با مقدارِ صحیحِ کاراکترِ متناظر، هم راحت و هم کارآمد است و به کارِ رفع‌اشکال هم می‌آید. این روش تا وقتی کار می‌کند که هیچ کاراکتری که به‌عنوان ورودی به‌کار می‌رود، ارزشی برابر با یکی از شمارشگرها نداشته باشد – و در هیچ مجموعه‌کاراکترِ امروزی‌ای که می‌شناسم، کاراکترِ قابلِ چاپی با مقدارِ صحیحِ تک‌رقمی وجود ندارد.

واسطِ ‎`Token_stream`‎ چنین است:

```cpp
class Token_stream {
public:
    Token get();            // خواندن و برگرداندنِ Token بعدی
    const Token& current(); // آخرین Token خوانده‌شده
    // ...
};
```

پیاده‌سازی در §10.2.2 آمده است.

هر تابعِ پارسر یک آرگومانِ ‎`bool`‎ به نامِ ‎`get`‎ می‌گیرد (§6.2.2) که مشخص می‌کند آیا لازم است ‎`Token_stream::get()`‎ را برای گرفتنِ Token بعدی صدا بزند یا نه. هر تابعِ پارسر «عبارتِ خودش» را ارزیابی می‌کند و مقدار را برمی‌گرداند. تابع ‎`expr()`‎ جمع و تفریق را رسیدگی می‌کند. این تابع یک حلقهٔ واحد دارد که به‌دنبال جملات (term)ی برای جمع یا تفریق می‌گردد:

```cpp
double expr(bool get) // جمع و تفریق
{
    double left = term(get);
    for (;;) {           // «تا ابد»
        switch (ts.current().kind) {
        case Kind::plus:
            left += term(true);
            break;
        case Kind::minus:
            left -= term(true);
            break;
        default:
            return left;
        }
    }
}
```

این تابع خودش کارِ زیادی انجام نمی‌دهد. به‌طور典型 برای توابعِ سطحِ بالاتر در یک برنامهٔ بزرگ، کار را به توابعِ دیگر واگذار می‌کند.

عبارتِ ‎`switch`‎ (§2.2.4، §9.4.2) مقدارِ شرطِ داخل پرانتز پس از کلیدواژهٔ ‎`switch`‎ را با مجموعه‌ای از ثابت‌ها مقایسه می‌کند. ‎`break`‎ برای خروج از ‎`switch`‎ به‌کار می‌رود. اگر مقدارِ آزمایش‌شده با هیچ برچسبِ ‎`case`‎ای تطبیق نکند، ‎`default`‎ انتخاب می‌شود؛ نویسندهٔ برنامه مجبور نیست ‎`default`‎ بنویسد.

توجه کنید عبارتی مانند ‎`2−3+4`‎ مطابقِ دستور زبان به‌صورت ‎`(2−3)+4`‎ ارزیابی می‌شود. نگارشِ کنجکاوانهٔ ‎`for(;;)`‎ راهی برای مشخص‌کردن یک حلقهٔ بی‌نهایت است؛ می‌توانید آن را «forever» تلفظ کنید (§9.5). ‎`while(true)`‎ هم جایگزینی برای آن است. ‎`switch`‎ بارها و بارها اجرا می‌شود تا چیزی غیر از ‎`+`‎ و ‎`−`‎ پیدا کند، و سپس ‎`return`‎ در شاخهٔ ‎`default`‎ اجرا می‌شود.

عملگرهای ‎`+=`‎ و ‎`-=`‎ برای جمع و تفریق به‌کار رفته‌اند؛ می‌شد ‎`left = left + term(true)`‎ و ‎`left = left - term(true)`‎ نوشت بی‌آن‌که معنای برنامه عوض شود، اما ‎`left += term(true)`‎ و ‎`left -= term(true)`‎ هم کوتاه‌ترند و هم مقصود را مستقیم‌تر بیان می‌کنند. هر عملگرِ انتساب یک Tokenِ واژگانی جداست، پس ‎`a + = 1;`‎ – به‌دلیل فاصله بین ‎`+`‎ و ‎`=`‎ – خطای نحوی است.

++C برای عملگرهای دوتاییِ زیر عملگرِ انتساب متناظر فراهم می‌کند:

```
+  −  ∗  /  %  &  |  ˆ  <<  >>
```

و در نتیجه این عملگرهای انتساب ممکن‌اند:

```
=  +=  −=  ∗=  /=  %=  &=  |=  ˆ=  <<=  >>=
```

‎`%`‎ عملگرِ باقیمانده (modulo) است؛ ‎`&`‎، ‎`|`‎ و ‎`ˆ`‎ عملگرهای بیتیِ منطقیِ and، or و «xor» هستند؛ ‎`<<`‎ و ‎`>>`‎ عملگرِ شیفتِ چپ و راست‌اند؛ §10.3 عملگرها و معانی‌شان را خلاصه می‌کند. برای یک عملگرِ دوتاییِ ‎`@`‎ که روی عملوندهای نوع‌های درون‌ساخت اعمال می‌شود، عبارتِ ‎`x @= y`‎ یعنی ‎`x = x @ y`‎، با این تفاوت که ‎`x`‎ فقط یک بار ارزیابی می‌شود.

تابعِ ‎`term()`‎ ضرب و تقسیم را همان‌گونه رسیدگی می‌کند که ‎`expr()`‎ جمع و تفریق را:

```cpp
double term(bool get) // ضرب و تقسیم
{
    double left = prim(get);
    for (;;) {
        switch (ts.current().kind) {
        case Kind::mul:
            left *= prim(true);
            break;
        case Kind::div:
            if (auto d = prim(true)) {
                left /= d;
                break;
            }
            return error("divide by 0");
        default:
            return left;
        }
    }
}
```

نتیجهٔ تقسیم بر صفر نامعین و معمولاً فاجعه‌بار است؛ بنابراین پیش از تقسیم، صفر بودن را می‌آزماییم و اگر مقسومٌ‌علیهِ صفر بود ‎`error()`‎ را صدا می‌زنیم. ‎`error()`‎ در §10.2.4 توصیف شده است. متغیر ‎`d`‎ دقیقاً همان‌جا که لازم است معرفی و بلافاصله مقداردهی می‌شود. حوزهٔ نامی که در شرط معرفی می‌شود، همان جمله‌ای است که آن شرط کنترل می‌کند و مقدارِ حاصل هم مقدارِ همان شرط است (§9.4.3). در نتیجه، تقسیم و انتسابِ ‎`left /= d`‎ فقط و فقط وقتی انجام می‌شود که ‎`d`‎ ناصفر باشد.

تابعِ ‎`prim()`‎ که یک «اولیه» (primary) را رسیدگی می‌کند، شبیه ‎`expr()`‎ و ‎`term()`‎ است، جز این‌که چون پایین‌تر در سلسله‌مراتبِ فراخوانی قرار گرفته‌ایم، کمی «کار واقعی» انجام می‌شود و دیگر نیازی به حلقه نیست:

```cpp
double prim(bool get) // رسیدگی به primary
{
    if (get) ts.get(); // Token بعدی را بخوان
    switch (ts.current().kind) {
    case Kind::number: {                // ثابتِ ممیز شناور
        double v = ts.current().number_value;
        ts.get();
        return v;
    }
    case Kind::name: {                  // یک نام (شناسه)
        double& v = table[ts.current().string_value]; // مقدارِ متناظر را بیاب
        if (ts.get().kind == Kind::assign)            // اگر '=' دیدیم: انتساب
            v = expr(true);
        return v;
    }
    case Kind::minus:                   // منفیِ یکانی
        return -prim(true);
    case Kind::lp: {                    // '('
        auto e = expr(true);
        if (ts.current().kind != Kind::rp)
            return error("')' expected");
        ts.get();                       // ')' را بخور
        return e;
    }
    default:
        return error("primary expected");
    }
}
```

وقتی یک ‎`Token`‎ از نوعِ «عدد» (عدد صحیح یا ممیز شناورِ literal) دیده می‌شود، مقدارش در ‎`number_value`‎ قرار می‌گیرد. به‌طور مشابه، وقتی ‎`Token`‎ی که «نام» است (هر طور تعریف شده؛ §10.2.2 و §10.2.3 را ببینید) دیده شود، مقدارش در ‎`string_value`‎ گذاشته می‌شود.

توجه کنید ‎`prim()`‎ همیشه یک ‎`Token`‎ بیش از آن‌چه برای تحلیلِ عبارتِ اولیه‌اش استفاده می‌کند می‌خوانَد. دلیلش این است که در برخی حالت‌ها مجبور است چنین کند (مثلاً برای این‌که ببیند آیا به یک نام انتساب می‌شود یا فقط خوانده می‌شود)؛ بنابراین، برای یکنواختی، در همهٔ حالت‌ها چنین می‌کند. در جاهایی که یک تابعِ پارسر فقط می‌خواهد به Tokenِ بعدی برود، از مقدارِ بازگشتیِ ‎`ts.get()`‎ استفاده نمی‌کند – اشکالی ندارد، چون می‌توانیم نتیجه را از ‎`ts.current()`‎ بگیریم. اگر بی‌اعتنایی به مقدارِ بازگشتیِ ‎`get()`‎ آزارم می‌داد، یا یک تابعِ ‎`read()`‎ اضافه می‌کردم که فقط ‎`current()`‎ را به‌روز کند و چیزی برنگرداند، یا صراحتاً نتیجه را «دور می‌ریختم»: ‎`void(ts.get());`‎.

پیش از انجام هرکاری با یک نام، ماشین‌حساب باید جلوتر را ببیند که آیا به آن انتساب می‌شود یا فقط خوانده می‌شود. در هر دو حالت، «جدولِ نمادها» (symbol table) مشورت می‌شود. جدول نمادها یک ‎`map`‎ است (§4.4.3، §31.4.3):

```cpp
map<string,double> table;
```

یعنی وقتی ‎`table`‎ با یک ‎`string`‎ اندیس‌گذاری شود، مقدارِ حاصل یک ‎`double`‎ متناظر با آن رشته است. مثلاً اگر کاربر بنویسد:

```cpp
radius = 6378.388;
```

ماشین‌حساب به ‎`case Kind::name`‎ می‌رسد و این‌ها اجرا می‌شوند:

```cpp
double& v = table["radius"];
// ... expr() مقدارِ قابلِ انتساب را محاسبه می‌کند ...
v = 6378.388;
```

ارجاعِ ‎`v`‎ برای نگه‌داشتنِ ‎`double`‎ متناظر با ‎`radius`‎ به‌کار می‌رود، در حالی که ‎`expr()`‎ مقدارِ ‎`6378.388`‎ را از کاراکترهای ورودی محاسبه می‌کند.

فصل‌های 14 و 15 دربارهٔ سازمان‌دهیِ برنامه به صورت مجموعه‌ای از ماژول‌ها بحث می‌کنند. با این حال – به‌جز یک مورد – اعلان‌های این مثالِ ماشین‌حساب را می‌توان طوری مرتب کرد که هر چیز دقیقاً یک‌بار و پیش از استفاده اعلان شود. استثنا ‎`expr()`‎ است که ‎`term()`‎ را صدا می‌زند، ‎`term()`‎ ‎`prim()`‎ را، و ‎`prim()`‎ هم دوباره ‎`expr()`‎ را؛ این حلقهٔ فراخوانی باید به‌نحوی شکسته شود. یک اعلانِ

```cpp
double expr(bool);
```

پیش از تعریفِ ‎`prim()`‎ به‌خوبی از عهدهٔ این کار برمی‌آید.

-----------------
-----------------
-----------------
-----------------
-----------------

حتماً ✅
در ادامه ترجمه‌ی کامل و روان متن آورده شده است:

---

### **تحلیل‌گر (Parser)**

در اینجا یک دستور زبان (Grammar) برای زبان ماشین‌حساب ارائه شده است:

```
program:
    end                  // end یعنی پایان ورودی
    expr_list end

expr_list:
    expression print      // print یعنی سمی‌کالن یا خط‌جدید
    expression print expr_list

expression:
    expression + term
    expression − term
    term

term:
    term / primary
    term ∗ primary
    primary

primary:
    number                // عدد اعشاری
    name                  // شناسه (نام متغیر)
    name = expression
    − primary
    ( expression )
```

به عبارت دیگر، یک «برنامه» مجموعه‌ای از عبارات است که با سمی‌کالن از هم جدا می‌شوند.
واحدهای اصلی یک عبارت شامل **عددها، نام‌ها** و عملگرهای `*`, `/`, `+`, `−` (یوناری و باینری) و `=` (تخصیص) هستند.
در این زبان، **نام‌ها (متغیرها)** لازم نیست قبل از استفاده اعلان شوند.

---

### **روش تحلیل نحوی: Recursive Descent**

در این روش که «نزولی بازگشتی» نام دارد، برای هر قاعده‌ی نحوی در دستور زبان، یک تابع متناظر نوشته می‌شود که سایر توابع را فراخوانی می‌کند.
این روش ساده و محبوب است و در زبان‌هایی مانند ++C که فراخوانی تابع ارزان است، کارایی بالایی دارد.

در این تحلیل‌گر، هر بار که دو عملوندِ یک زیرعبارت شناخته شوند، همان‌جا مقدار آن محاسبه می‌شود.
در یک **کامپایلر واقعی**، در همین نقطه می‌توان به‌جای محاسبه، **کد تولید کرد**.

---

### **جریان توکن‌ها (Token_stream)**

ورودیِ تحلیل‌گر از یک شیء به نام `Token_stream` خوانده می‌شود.
این شیء مسئول خواندن کاراکترها و ساختن **توکن‌ها (Tokens)** است؛ یعنی فرایند **توکنیزه کردن**.

مثلاً رشته‌ی `"123.45"` به یک توکن `{number, 123.45}` تبدیل می‌شود.
توکن شامل دو بخش است:

* **kind**: نوع توکن (مثلاً عدد، نام، عملگر و غیره)
* **value**: مقدار عددی یا متنی آن

تابع `ts.get()` توکن بعدی را می‌خواند،
و `ts.current()` آخرین توکن خوانده‌شده را برمی‌گرداند.

---

### **تعریف Token**

```cpp
enum class Kind : char {
    name, number, end,
    plus='+', minus='−', mul='∗', div='/', print=';', assign='=', lp='(', rp=')'
};

struct Token {
    Kind kind;
    string string_value;
    double number_value;
};
```

نمایش هر توکن با مقدار عددیِ کاراکتر آن، کارایی را بالا می‌برد و برای دیباگ نیز مفید است.

---

### **رابط Token_stream**

```cpp
class Token_stream {
public:
    Token get();               // خواندن توکن بعدی
    const Token& current();    // آخرین توکن خوانده‌شده
    // ...
};
```

---

### **تابع expr()**

این تابع عملگرهای جمع و تفریق را مدیریت می‌کند:

```cpp
double expr(bool get)  // جمع و تفریق
{
    double left = term(get);
    for (;;) {
        switch (ts.current().kind) {
        case Kind::plus:
            left += term(true);
            break;
        case Kind::minus:
            left -= term(true);
            break;
        default:
            return left;
        }
    }
}
```

اینجا حلقه‌ی `for(;;)` یعنی **حلقه‌ی بی‌نهایت** (معادل `while(true)`)،
و زمانی متوقف می‌شود که دیگر عملگر + یا − وجود نداشته باشد.

عبارتی مانند `2−3+4` به‌صورت `(2−3)+4` محاسبه می‌شود (از چپ به راست).

---

### **تابع term()**

تابع `term()` عملگرهای ضرب و تقسیم را مانند `expr()` ولی برای `*` و `/` مدیریت می‌کند:

```cpp
double term(bool get)
{
    double left = prim(get);
    for (;;) {
        switch (ts.current().kind) {
        case Kind::mul:
            left *= prim(true);
            break;
        case Kind::div:
            if (auto d = prim(true)) {
                left /= d;
                break;
            }
            return error("divide by 0");
        default:
            return left;
        }
    }
}
```

قبل از تقسیم، بررسی می‌شود که تقسیم بر صفر رخ ندهد؛ در غیر این صورت `error()` فراخوانی می‌شود.

---

### **تابع prim()**

تابع `prim()` کوچک‌ترین اجزای نحوی را (اعداد، متغیرها، پرانتز، منفی) تحلیل می‌کند:

```cpp
double prim(bool get)
{
    if (get) ts.get();
    switch (ts.current().kind) {
    case Kind::number:
        { double v = ts.current().number_value;
          ts.get();
          return v; }

    case Kind::name:
        { double& v = table[ts.current().string_value];
          if (ts.get().kind == Kind::assign)
              v = expr(true);
          return v; }

    case Kind::minus:
        return -prim(true);

    case Kind::lp:
        { auto e = expr(true);
          if (ts.current().kind != Kind::rp)
              return error("')' expected");
          ts.get();
          return e; }

    default:
        return error("primary expected");
    }
}
```

* اگر **عدد** دیده شود، مقدار عددی آن بازگردانده می‌شود.
* اگر **نام** دیده شود، در جدول نمادها (`table`) جستجو می‌شود. اگر بعد از آن علامت `=` باشد، مقدار جدید محاسبه و ذخیره می‌شود.
* اگر `-` باشد، منفیِ مقدار بعدی گرفته می‌شود.
* اگر پرانتز باز باشد، عبارت داخل پرانتز محاسبه می‌شود.

---

### **جدول نمادها (Symbol Table)**

```cpp
map<string, double> table;
```

این جدول نام متغیرها را به مقدارشان نگاشت می‌کند.
مثلاً اگر کاربر بنویسد:

```
radius = 6378.388;
```

برنامه مقدار `6378.388` را در `table["radius"]` ذخیره می‌کند.

---

### **نکته درباره‌ی وابستگی توابع**

تابع `expr()` تابع `term()` را فراخوانی می‌کند،
`term()` تابع `prim()` را،
و `prim()` دوباره `expr()` را (برای پرانتزها).
برای شکستن این حلقه‌ی ارجاع، باید قبل از تعریف `prim()` بنویسیم:

```cpp
double expr(bool);
```


-----------------
-----------------
-----------------
-----------------
-----------------


