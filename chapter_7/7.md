## Introduction
این فصل به مکانیزم‌های زبان پایه برای ارجاع به حافظه می‌پردازد. واضح است که می‌توانیم به یک شیء از طریق نام آن ارجاع دهیم، اما در C++ (برای بیشتر) اشیاء «هویت دارند». به این معنی که آنها در یک آدرس خاص در حافظه قرار دارند و یک شیء در صورتی که آدرس و نوع آن را بدانید، قابل دسترسی است. ساختارهای زبانی برای نگهداری و استفاده از آدرس‌ها، اشاره‌گرها و ارجاعات هستند.

## Pointers
برای یک نوع T، نوع T∗ نوع ‘‘اشاره‌گر به T’’ است. به این معنا که یک متغیر از نوع T∗ می‌تواند آدرس یک شیء از نوع T را نگه دارد. برای مثال:

```cpp
char c = 'a';
char* p = &c; // p آدرس c را نگه می‌دارد؛ & اپراتور آدرس‌دهی است
```

یا به صورت گرافیکی:
![](../image/7/7.1.png)

عملیات اساسی روی یک اشاره‌گر، dereferencing (ارجاع به شیء اشاره شده توسط اشاره‌گر) است. این عملیات همچنین به نام indirection (واژگانی معکوس) شناخته می‌شود. اپراتور dereference، اپراتور ∗ (یونری پیشوند) است. برای مثال:

```cpp
char c = 'a';
char* p = &c; // p آدرس c را نگه می‌دارد؛ & اپراتور آدرس‌دهی است
char c2 = *p; // c2 == 'a'; * اپراتور dereference است
```

شیء اشاره شده توسط p، c است و مقداری که در c ذخیره شده، 'a' است، بنابراین مقدار \*p که به c2 اختصاص داده می‌شود، 'a' است.

ممکن است برخی عملیات‌های حسابی بر روی اشاره‌گرها به عناصر آرایه انجام شود (§7.4). پیاده‌سازی اشاره‌گرها به گونه‌ای است که مستقیماً با مکانیزم‌های آدرس‌دهی ماشین روی سیستم هدف ارتباط دارد. بیشتر ماشین‌ها قادر به آدرس‌دهی به یک بایت هستند. آنهایی که نمی‌توانند، معمولاً سخت‌افزاری برای استخراج بایت‌ها از واژه‌ها دارند. از طرف دیگر، تعداد کمی از ماشین‌ها می‌توانند به طور مستقیم به یک بیت خاص آدرس‌دهی کنند. بنابراین، کوچکترین شیء که می‌تواند به طور مستقل تخصیص یابد و با استفاده از نوع پیش‌ساخته اشاره‌گر به آن اشاره شود، یک char است. توجه داشته باشید که یک bool حداقل به اندازه یک char فضا اشغال می‌کند (§6.2.8). برای ذخیره مقادیر کوچکتر به صورت فشرده‌تر، می‌توانید از عملیات‌های منطقی بیتی (§11.1.1)، فیلدهای بیتی در ساختارها (§8.2.7)، یا bitset (§34.2.2) استفاده کنید.

اپراتور ∗ که به معنای ‘‘اشاره‌گر به’’ است، به عنوان پسوندی برای نام نوع استفاده می‌شود. متأسفانه، اشاره‌گرها به آرایه‌ها و اشاره‌گرها به توابع نیاز به نگارش پیچیده‌تری دارند:

```cpp
int* pi; // اشاره‌گر به int
char** ppc; // اشاره‌گر به اشاره‌گر به char
int* ap[15]; // آرایه‌ای از 15 اشاره‌گر به int
int (*fp)(char*); // اشاره‌گر به تابعی که یک آرگومان char* می‌گیرد و int برمی‌گرداند
int* f(char*); // تابعی که یک آرگومان char* می‌گیرد و یک اشاره‌گر به int برمی‌گرداند
```

برای توضیح نحوه نوشتار اعلامیه‌ها به §6.3.1 و برای گرامر کامل به §iso.A مراجعه کنید. اشاره‌گرها به توابع می‌توانند مفید باشند و در §12.5 مورد بحث قرار گرفته‌اند. اشاره‌گرها به اعضای کلاس در §20.6 آورده شده‌اند.

## void∗
در کد سطح پایین، گاهی نیاز داریم که آدرس یک مکان حافظه را ذخیره کنیم یا به مکان دیگری منتقل کنیم بدون اینکه بدانیم در آن مکان چه نوع شیء ذخیره شده است. برای این کار از `void*` استفاده می‌شود. می‌توان `void*` را به عنوان ‘‘اشاره‌گر به شیء با نوع نامعلوم’’ خواند.

یک اشاره‌گر به هر نوع شیء می‌تواند به متغیری از نوع `void*` اختصاص داده شود، اما اشاره‌گر به تابع (§12.5) یا اشاره‌گر به اعضای کلاس (§20.6) نمی‌تواند. علاوه بر این، یک `void*` می‌تواند به یک `void*` دیگر اختصاص داده شود، می‌توان `void*` ها را برای برابری و نابرابری مقایسه کرد، و یک `void*` می‌تواند به طور صریح به نوع دیگری تبدیل شود. عملیات‌های دیگر بر روی `void*` غیرایمن خواهند بود زیرا کامپایلر نمی‌تواند نوع شیء اشاره شده را تشخیص دهد. به همین دلیل، عملیات‌های دیگر باعث بروز خطای زمان کامپایل می‌شوند. برای استفاده از یک `void*`، باید آن را به طور صریح به یک اشاره‌گر به نوع خاصی تبدیل کنیم. برای مثال:

```cpp
void f(int* pi)
{
    void* pv = pi; // ok: تبدیل ضمنی از int* به void*
    *pv; // خطا: نمی‌توان void* را dereference کرد
    ++pv; // خطا: نمی‌توان void* را افزایش داد (اندازه شیء اشاره شده ناشناخته است)
    int* pi2 = static_cast<int*>(pv); // تبدیل صریح به int*
    double* pd1 = pv; // خطا
    double* pd2 = pi; // خطا
    double* pd3 = static_cast<double*>(pv); // غیرایمن (§11.5.2)
}
```

به طور کلی، استفاده از یک اشاره‌گر که به نوعی تبدیل شده است (‘‘کست’’) به نوعی که با نوع شیء اشاره شده متفاوت است، ایمن نیست. برای مثال، ممکن است یک ماشین فرض کند که هر `double` روی یک مرز 8 بایتی اختصاص داده می‌شود. اگر چنین باشد، رفتار عجیب ممکن است رخ دهد اگر `pi` به یک `int` اشاره کند که به این شکل اختصاص داده نشده است. این نوع تبدیل صریح نوع به طور ذاتی غیرایمن و نازیبا است. به همین دلیل، نگارش مورد استفاده، `static_cast` (§11.5.2)، به گونه‌ای طراحی شده است که زشت باشد و به راحتی در کد شناسایی شود.

استفاده اصلی از `void*` برای ارسال اشاره‌گرها به توابعی است که اجازه ندارند فرضیاتی در مورد نوع شیء داشته باشند و برای بازگشت شیءهای بدون نوع از توابع. برای استفاده از چنین شیءهایی، باید از تبدیل صریح نوع استفاده کنیم.

توابعی که از اشاره‌گرهای `void*` استفاده می‌کنند معمولاً در پایین‌ترین سطح سیستم وجود دارند، جایی که منابع سخت‌افزاری واقعی دستکاری می‌شوند. به عنوان مثال:

```cpp
void* my_alloc(size_t n); // تخصیص n بایت از حافظه اختصاصی من
```

مواقعی که از `void*` ها در سطوح بالاتر سیستم استفاده می‌شود، باید با شک و تردید به آن‌ها نگاه کرد زیرا احتمالاً نشان‌دهنده اشتباهات طراحی هستند. وقتی که از `void*` برای بهینه‌سازی استفاده می‌شود، می‌توان آن را پشت یک رابط ایمن از نظر نوع (§27.3.1) پنهان کرد.

اشاره‌گرهای توابع (§12.5) و اشاره‌گرهای اعضای کلاس (§20.6) نمی‌توانند به `void*` ها اختصاص داده شوند.

## nullptr
مقدار ثابت `nullptr` نمایانگر اشاره‌گر تهی است، به این معنی که اشاره‌گری است که به هیچ شیء‌ای اشاره نمی‌کند. این مقدار می‌تواند به هر نوع اشاره‌گری اختصاص یابد، اما نمی‌تواند به انواع دیگر داده‌های پیش‌ساخته اختصاص یابد:

```cpp
int* pi = nullptr;
double* pd = nullptr;
int i = nullptr; // خطا: i یک اشاره‌گر نیست
```

فقط یک `nullptr` وجود دارد که می‌تواند برای هر نوع اشاره‌گری استفاده شود، به جای اینکه برای هر نوع اشاره‌گر، یک اشاره‌گر تهی متفاوت داشته باشیم.

قبل از معرفی `nullptr`، از صفر (0) به عنوان نشانه‌ای برای اشاره‌گر تهی استفاده می‌شد. برای مثال:

```cpp
int* x = 0; // x مقدار nullptr را می‌گیرد
```

هیچ شیئی با آدرس 0 اختصاص داده نمی‌شود و صفر (الگوی بیتی صفر) معمول‌ترین نمایش برای `nullptr` است. صفر (0) یک `int` است. با این حال، تبدیل‌های استاندارد (§10.5.2.3) اجازه می‌دهند که 0 به عنوان یک مقدار از نوع اشاره‌گر یا اشاره‌گر به عضو استفاده شود.

استفاده از یک ماکرو به نام `NULL` برای نمایش اشاره‌گر تهی متداول بوده است. برای مثال:

```cpp
int* p = NULL; // استفاده از ماکرو NULL
```

با این حال، تفاوت‌هایی در تعریف `NULL` در پیاده‌سازی‌های مختلف وجود دارد؛ برای مثال، `NULL` ممکن است 0 یا 0L باشد. در C، `NULL` معمولاً به صورت `(void*)0` تعریف می‌شود که در C++ غیرقانونی است (§7.2.1):

```cpp
int* p = NULL; // خطا: نمی‌توان یک void* را به int* اختصاص داد
```

استفاده از `nullptr` کد را خواناتر از گزینه‌های دیگر می‌کند و از سردرگمی‌های احتمالی جلوگیری می‌کند، به خصوص زمانی که یک تابع برای پذیرش هم اشاره‌گر و هم عدد (در صورت بارگذاری بیش از حد تابع) تعریف شده باشد (§12.3.1).

## Arrays
برای یک نوع T، نوع `T[size]` به معنای ‘‘آرایه‌ای با اندازه size از عناصر نوع T’’ است. عناصر آرایه از 0 تا `size-1` ایندکس می‌شوند. برای مثال:

```cpp
float v[3]; // یک آرایه از سه عدد اعشاری: v[0], v[1], v[2]
char* a[32]; // یک آرایه از 32 اشاره‌گر به char: a[0] .. a[31]
```

می‌توانید به آرایه‌ها از طریق اپراتور ساب‌اسکریپت (`[]`) یا از طریق اشاره‌گر (با استفاده از اپراتور `*` یا `[]`; §7.4) دسترسی پیدا کنید. برای مثال:

```cpp
void f()
{
    int aa[10];
    aa[6] = 9; // اختصاص مقدار به هفتمین عنصر آرایه aa
    int x = aa[99]; // رفتار غیرتعریف شده
}
```

دسترسی به آرایه خارج از محدوده آن، رفتار غیرتعریف شده‌ای دارد و معمولاً فاجعه‌آمیز است. به‌ویژه، بررسی محدوده در زمان اجرا معمولاً تضمین شده نیست و رایج نمی‌باشد.

تعداد عناصر آرایه، حد آرایه، باید یک عبارت ثابت باشد (§10.4). اگر به اندازه‌های متغیر نیاز دارید، از `vector` (§4.4.1, §31.4) استفاده کنید. برای مثال:

```cpp
void f(int n)
{
    int v1[n]; // خطا: اندازه آرایه باید یک عبارت ثابت باشد
    vector<int> v2(n); // درست: وکتور با n عنصر از نوع int
}
```

آرایه‌های چندبعدی به صورت آرایه‌هایی از آرایه‌ها نمایش داده می‌شوند (§7.4.2).

آرایه‌ها روش اصلی C++ برای نمایش یک دنباله از اشیاء در حافظه هستند. اگر چیزی که می‌خواهید یک دنباله ساده از اشیاء با طول ثابت از یک نوع داده خاص در حافظه باشد، آرایه بهترین راه‌حل است. برای هر نیاز دیگری، آرایه مشکلات جدی دارد.

آرایه می‌تواند به صورت ایستا، در پشته، و در حافظه آزاد (free store) تخصیص یابد (§6.4.2). برای مثال:

```cpp
int a1[10]; // 10 عدد int در حافظه ایستا
void f()
{
    int a2[20]; // 20 عدد int در پشته
    int* p = new int[40]; // 40 عدد int در حافظه آزاد
    // ...
}
```

آرایه‌های پیش‌ساخته C++ یک ابزار به‌طور ذاتی سطح پایین هستند که باید عمدتاً در پیاده‌سازی ساختارهای داده‌ای سطح بالاتر و با رفتار بهتر، مانند `vector` یا `array` از کتابخانه استاندارد، استفاده شوند. آرایه‌ها هیچ‌گونه عمل تخصیص ندارند و نام یک آرایه به طور ضمنی به یک اشاره‌گر به اولین عنصر آن تبدیل می‌شود (§7.4). به‌ویژه، باید از استفاده از آرایه‌ها در رابط‌ها (مثلاً به‌عنوان آرگومان‌های تابع؛ §7.4.3, §12.2.2) اجتناب کنید زیرا تبدیل ضمنی به اشاره‌گر منبع بسیاری از خطاهای رایج در کدهای C و کدهای C++ به سبک C است. اگر یک آرایه را در حافظه آزاد تخصیص دادید، مطمئن شوید که تنها یک‌بار از `delete[]` برای آن استفاده کنید و فقط پس از استفاده نهایی از آن (§11.2.2). این کار به راحتی و به‌طور قابل اعتماد از طریق کنترل طول عمر آرایه حافظه آزاد توسط یک ابزار مدیریت منابع (مثلاً `string` (§19.3, §36.3)، `vector` (§13.6, §34.2)، یا `unique_ptr` (§34.3.1)) انجام می‌شود. اگر آرایه را به صورت ایستا یا در پشته تخصیص دادید، مطمئن شوید که هرگز از `delete[]` استفاده نکنید. واضح است که برنامه‌نویسان C نمی‌توانند این توصیه‌ها را دنبال کنند چون C توانایی محصور کردن آرایه‌ها را ندارد، اما این توصیه‌ها در C++ به هیچ‌وجه اشتباه نیستند.

یکی از رایج‌ترین انواع آرایه‌ها، آرایه‌ای از `char` است که به صورت صفر-ترمیناتور (zero-terminated) ذخیره می‌شود. این نحوه ذخیره‌سازی رشته‌ها در C است، بنابراین معمولاً به این نوع آرایه‌ها ‘‘رشته‌های C-style’’ می‌گویند. ادبیات رشته‌ای در C++ از این سنت پیروی می‌کند (§7.3.2) و برخی از توابع کتابخانه استاندارد (مانند `strcpy()` و `strcmp()`؛ §43.4) به آن متکی هستند. اغلب، یک `char*` یا یک `const char*` فرض می‌شود که به یک دنباله از کاراکترها با انتهای صفر اشاره می‌کند.

