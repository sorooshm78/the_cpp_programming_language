## 9.1 Introduction
سی++ مجموعه‌ای متداول و انعطاف‌پذیر از **دستورات** را ارائه می‌دهد. در واقع، هر چیزی که جالب یا پیچیده باشد، در **عبارت‌ها (expressions)** و **اعلان‌ها (declarations)** یافت می‌شود. توجه داشته باشید که یک اعلان خودش یک دستور است و یک عبارت وقتی به دستور تبدیل می‌شود که در انتهایش یک **سمیکالن (;)** اضافه کنید.

برخلاف یک عبارت، یک دستور مقداری ندارد. در عوض، دستورات برای مشخص کردن **ترتیب اجرا** به کار می‌روند. برای مثال:

```cpp
a = b + c;   // دستور عبارتی (expression statement)
if (a == 7)  // دستور شرطی if
    b = 9;   // فقط در صورتی اجرا می‌شود که a == 9 باشد
```

به صورت منطقی، دستور `a = b + c` قبل از `if` اجرا می‌شود، همان‌طور که همه انتظار دارند.
البته یک کامپایلر می‌تواند برای بهبود کارایی، کد را **بازچینی (reorder)** کند، به شرطی که نتیجه دقیقاً مشابه اجرای ترتیبی ساده باشد.


---------------

Expression → همیشه یه مقدار می‌ده.

Statement → ترتیب اجرا رو مشخص می‌کنه، خودش ارزشی نداره.

---------------

## Statement Summary
حتماً 🌹 — در ادامه ترجمهٔ متن شما به فارسی آورده شده است:

---

### گزیده‌ای از دستورهای C++

**statement (دستور):**

* declaration (اعلان)
* expressionاختیاری ;
* { statement-listاختیاری }
* try { statement-listاختیاری } handler-list
* case constant-expression : statement
* default : statement
* break ;
* continue ;
* return expressionاختیاری ;
* goto identifier ;
* identifier : statement
* selection-statement (دستور انتخابی)
* iteration-statement (دستور تکرار)

---

**selection-statement (دستور انتخابی):**

* `if ( condition ) statement`
* `if ( condition ) statement else statement`
* `switch ( condition ) statement`

---

**iteration-statement (دستور تکرار):**

* `while ( condition ) statement`
* `do statement while ( expression ) ;`
* `for ( for-init-statement conditionاختیاری ; expressionاختیاری ) statement`
* `for ( for-init-declaration : expression ) statement`

---

**statement-list (فهرست دستورها):**

* `statement statement-list`
* اختیاری

---

**condition (شرط):**

* expression (عبارت)
* `type-specifier declarator = expression`
* `type-specifier declarator { expression }`

---

**handler-list (فهرست کنترل‌کننده‌ها):**

* `handler handler-list`
* اختیاری

**handler (کنترل‌کننده):**

* `catch ( exception-declaration ) { statement-listاختیاری }`

---

### نکات تکمیلی

* یک **نقطه‌ویرگول** (semicolon) به تنهایی یک دستور محسوب می‌شود و به آن **دستور خالی** می‌گویند.
* دنباله‌ای (حتی خالی) از دستورها که درون **آکلاد**‌ها (یعنی `{` و `}`) قرار می‌گیرد، **block** یا **compound statement** (دستور مرکب) نام دارد.
* نامی که درون یک بلوک تعریف می‌شود، در پایان همان بلوک از **دامنه (scope)** خارج می‌شود (§6.3.4).
* یک اعلان (declaration) خودش یک دستور است و در C++ چیزی به نام «دستور انتساب (assignment statement)» یا «دستور فراخوانی تابع (procedure-call statement)» وجود ندارد؛ بلکه **انتساب‌ها** و **فراخوانی توابع** همگی **عبارت (expression)** هستند.
* مقدار اولیهٔ `for-init-statement` باید یا یک **اعلان** یا یک **دستور-عبارت (expression-statement)** باشد. توجه کنید که هر دو با نقطه‌ویرگول پایان می‌یابند.
* یک `for-init-declaration` باید اعلان یک متغیر منفرد **بدون مقدار اولیه** باشد.
* دستورهایی که برای مدیریت **استثناها** به کار می‌روند (try-blocks)، در بخش §13.5 توضیح داده شده‌اند.

## 9.3 Declarations as Statements
اعلام یک عبارت است. مگر اینکه متغیر به صورت استاتیک اعلان شود، مقداردهی اولیهٔ آن هر بار که جریان کنترل به اعلان می‌رسد، اجرا می‌شود (نگاه کنید به §6.4.2). دلیل اجازه دادن به اعلان‌ها در هر مکانی که یک بیانیه می‌تواند استفاده شود (و چند مکان دیگر؛ §9.4.3، §9.5.2) این است که به برنامه‌نویس امکان دهد از بروز خطاهای ناشی از مقداردهی اولیه نشدهٔ متغیرها جلوگیری کند و locality کد را بهبود بخشد. به ندرت دلیلی وجود دارد که متغیری را قبل از داشتن مقداری برای نگه داشتن آن معرفی کنیم. به عنوان مثال:

```
void f(vector<string>& v, int i, const char* p)
{
  if (p==nullptr) return;
  if (i<0 || v.size()<=i)
    error("bad index");
  string s = v[i];
  if (s == p) {
    // ...
  }
  // ...
}
```

توانایی قرار دادن اعلان‌ها پس از کد اجرایی برای بسیاری از مقادیر ثابت و سبک‌های برنامه‌نویسی با تک‌بار مقداردهی جمعی (single-assignment) که در آن مقدار یک شیء پس از مقداردهی اولیه تغییر داده نمی‌شود، ضروری است. برای انواع کاربری‌های کاربر-تعریف، تخصیص متغیر تا زمانی که مقدار مناسب برای مقداردهی در دسترس باشد می‌تواند منجر به کارایی بهتری شود. به عنوان مثال:

```
void use()
{
  string s1;
  s1 = "The best is the enemy of the good.";
  // ...
}
```

این درخواست مقداردهی اولیه پیش‌فرضی را انجام می‌دهد (به رشتهٔ خالی) که با دنبالِ آن یک مقداردهی انجام می‌شود. این ممکن است نسبت به مقداردهی ساده به مقدار دلخواه وابسته سریع‌تر نباشد:

```
string s2 {"Voltaire"};
```

دلیل رایج‌ترین برای اعلان یک متغیر بدون مقدار اولیه این است که به یک جمله نیاز دارد تا مقدار مورد نظر خود را بدست آورد. متغیرهای ورودی از جمله مثال‌های نسبتاً معقول کم‌تری هستند که این کار را می‌کنند:

```
void input()
{
  int buf[max];
  int count = 0;
  for (int i; cin>>i;) {
    if (i<0) error("unexpected negative value");
    if (count==max) error("buffer overflow");
    buf[count++] = i;
  }
  // ...
}
```

فرض می‌کنم که error() بازمی‌گردد؛ اگر بازگردد، این کد ممکن است باعث سرریز بافر شود. اغلب، push_back() (§3.2.1.3، §13.6، §31.3.6) راه‌حل بهتری برای چنین مثالی ارائه می‌دهد.

## 9.4 Selection Statements
یک مقدار می‌تواند توسط either یک عبارت شرطی یا یک بیانیه سوئیچ آزمایش شود:
- if ( شرط ) بیانیه
- if ( شرط ) بیانیه else بیانیه
- switch ( شرط ) بیانیه
یک شرط یا یک عبارت است یا یک اعلان (§9.4.3).

## 9.4.1 if Statements
در یک بیانیه־شرطی (if-statement)، اولین بیانیه (یا تنها بیانیه) زمانی اجرا می‌شود که شرط درست باشد و بیانیه دوم (اگر مشخص شود) در غیر این صورت اجرا می‌شود. اگر شرط نتیجه‌ای غیر از مقدار بولی بدهد، اگر ممکن باشد به طور ضمنی به bool تبدیل می‌شود. این بدین معناست که هر عبارت حسابی یا اشاره‌گر می‌تواند به عنوان شرط استفاده شود. برای مثال، اگر x یک عدد صحیح باشد، آنگاه

```
if (x) // ...
```

یعنی

```
if (x != 0) // ...
```

برای یک اشاره‌گر p،

```
if (p) // ...
```

یک عبارت آزمایشی مستقیم است که می‌گوید «آیا p اشاره به یک شیء معتبر دارد؟» (با فرض مقداردهی مناسب)، و معادل است با

```
if (p != nullptr) // ...
```

توجه کنید که یک مقدارِ مَشخُصِ ساده (plain) enum می‌تواند به طور ضمنی به یک عدد صحیح تبدیل شود و سپس به bool، در حالی که یک enum class نمی‌تواند (§8.4.1). برای مثال:

```
enum E1 { a, b };
enum class E2 { a, b };

void f(E1 x, E2 y)
{
  if (x) // OK
    // ...
  if (y) // خطا: تبدیل به bool مجاز نیست
    // ...
  if (y == E2::a) // OK
    // ...
}
```

عبارت‌های منطقی
&& || !
بیشترین استفاده را در شرایط دارند. عملگرهای && و || دومین آرگومان خود را تنها در صورت لازم بودن ارزیابی می‌کنند. برای مثال:

```
if (p && 1 < p->count) // ...
```

این شرط فقط زمانی مقدار 1 < p->count را بررسی می‌کند که p مقدار nullptr نباشد.

برای انتخاب بین دو گزینه که هر کدام مقداری تولید می‌کند، عبارت شرطی (conditional expression) (§11.1.3) صریح‌تر از یک if-statement است. برای مثال:

```
int max(int a, int b)
{
  return (a > b) ? a : b; // بازگرداندن بزرگ‌ترین مقدار بین a و b
}
```

یک نام تنها می‌تواند در دامنه‌ای که در آن اعلان شده استفاده شود. به ویژه، در branch دیگری از if-statement نمی‌توان از آن استفاده کرد. برای مثال:

```
void f2(int i)
{
  if (i) {
    int x = i + 2;
    ++x;
    // ...
  }
  else {
    ++x; // خطا: x در دامنه نیست
  }
  ++x; // خطا: x در دامنه نیست
}
```

یک شاخه از if-statement نمی‌تواند فقط یک اعلان باشد. اگر بخواهیم نامی را در یک شاخه معرفی کنیم، باید آن را در یک بلاک (§9.2) محصور کنیم. برای مثال:

```
void f1(int i)
{
  if (i)
    int x = i + 2; // خطا: اعلان در شاخه if-statement
}
```


-----
-----
-----
-----

### ۱. اعلان (declaration) مثل یک دستور است

در C++، وقتی داخل یک بلاک (مثلاً درون تابع یا داخل if) یک متغیر تعریف می‌کنی، اون تعریف خودش یک **statement** (دستور) حساب میشه.
مثلاً:

```cpp
int x = 5;
```

این یک دستور کامل محسوب میشه، درست مثل `if`, `for`, یا `return`.

---

### ۲. اجرای initializer

اگر متغیر **static** نباشه، مقداردهی اولیه (initializer) هر بار که کنترل برنامه به اون خط می‌رسه اجرا میشه.
مثال:

```cpp
void f() {
    int x = rand();   // هر بار که f اجرا بشه، x دوباره مقداردهی میشه
}
```

اما اگر `static` باشه:

```cpp
void f() {
    static int x = rand(); // فقط بار اول مقداردهی میشه
}
```

---

### ۳. چرا اجازه میدن هرجا بشه متغیر تعریف کرد؟

در زبان‌هایی قدیمی‌تر مثل C (نسخه‌های قدیم)، باید همه متغیرها رو ابتدای بلاک تعریف می‌کردی.
C++ اجازه میده هرجا که نیاز داشتی تعریف کنی. دلیلش:

* جلوگیری از استفاده‌ی تصادفی متغیر **بدون مقدار اولیه**
* خوانایی و محلی بودن متغیر (locality): متغیر نزدیک به جایی که استفاده میشه تعریف بشه.

---

### ۴. مثال متن

کدی که آوردی:

```cpp
void f(vector<string>& v, int i, const char* p)
{
    if (p==nullptr) return;                // اگر p تهی باشه، زود برگرد
    if (i<0 || v.size()<=i)                // بررسی اینکه i معتبره یا نه
        error("bad index");

    string s = v[i];                       // اینجا تازه s تعریف میشه
    if (s == p) {
        // ...
    }
    // ...
}
```

🔍 نکته اینجاست:
متغیر `s` دقیقا همون جایی تعریف شده که به مقدارش نیاز داریم (`v[i]`).

* اگر بالاتر (قبل از ifها) تعریفش می‌کردیم، ممکن بود برنامه قبل از رسیدن به مقدار معتبر برگرده یا خطا بده، ولی `s` بی‌دلیل ساخته بشه.
* این باعث میشه هم کارایی بهتر بشه (چون سازنده و مخرب بی‌مورد صدا زده نمیشه)، هم احتمال خطای "استفاده از متغیر بدون مقدار درست" کمتر بشه.

---

### جمع‌بندی ساده:

* تعریف متغیر در C++ یک دستور کامل حساب میشه.
* اگر متغیر static نباشه، مقداردهی اولیه هر بار که به اون خط می‌رسیم اجرا میشه.
* C++ اجازه میده هرجا لازم داشتی متغیر تعریف کنی → کدت امن‌تر و خواناتر میشه.
* مثال کد نشون میده چطور متغیر رو دقیقا در نقطه‌ای تعریف کنیم که ارزش و معنای واقعی پیدا می‌کنه.

---























## ۱. چرا اجازه داریم بعد از کد اجرایی متغیر تعریف کنیم؟

این ویژگی باعث میشه:

* **ثابت‌ها (constants)** درست همون‌جا که بهشون نیاز داریم تعریف بشن.
* **سبک تک‌اختصاص (single-assignment style)** رعایت بشه: یعنی متغیر وقتی ساخته میشه که از همون لحظه تا آخر عمرش یه مقدار ثابت داره (نه اینکه بسازیمش و بعد چند بار تغییرش بدیم).
* برای **کلاس‌ها و نوع‌های کاربر (user-defined types)** خیلی مهمه، چون بعضی‌ها ساختن و مقداردهی اولیه‌شون گرونه. اگر زودتر بسازیم و بعد دوباره مقدار بدیم، اضافه‌کاری میشه.

---

## ۲. تفاوت بین "تعریف بدون مقداردهی" و "تعریف با مقداردهی"

### حالت اول: تعریف بدون initializer + انتساب بعدی

```cpp
void use()
{
    string s1;                     // ساخته میشه به عنوان رشته خالی ""
    s1 = "The best is the enemy of the good."; // بعد دوباره مقداردهی میشه
}
```

این یعنی:

1. اول سازنده‌ی پیش‌فرض (`string()`) صدا زده میشه → رشته خالی ساخته میشه.
2. بعد عملگر انتساب (`operator=`) صدا زده میشه → محتوای جدید جایگزین میشه.

این یعنی **دو بار کار اضافه** (اول ساخت، بعد تغییر).

---

### حالت دوم: تعریف همراه initializer

```cpp
string s2 {"Voltaire"};
```

اینجا مستقیماً رشته با مقدار `"Voltaire"` ساخته میشه.

* فقط **یک بار سازنده** صدا زده میشه.
* سریع‌تر و بهینه‌تر از حالت قبلی.

---

## ۳. چه موقع بدون initializer تعریف می‌کنیم؟

معمولاً باید همیشه متغیر رو همون موقع مقدار بدیم.
اما بعضی وقتا لازمه **بعداً در طول اجرای حلقه یا دریافت ورودی مقدار بگیره**.

مثال متن:

```cpp
void input()
{
    int buf[max];      // یه بافر ساده
    int count = 0;     // تعداد ورودی‌هایی که گرفتیم
    for (int i; cin >> i;) {       // i اینجا مقدارش با ورودی پر میشه
        if (i < 0) error("unexpected negative value");
        if (count == max) error("buffer overflow");
        buf[count++] = i;          // مقدار i رو می‌ریزیم توی بافر
    }
}
```

اینجا:

* متغیر `i` اول ساخته میشه ولی مقداردهی اولیه نمی‌گیره.
* مقدارش هر بار در حلقه با ورودی `cin >> i` تعیین میشه.
* این یه مثال درست از متغیریه که باید **بعداً مقدار بگیره** چون مقدار اولیه از کاربر میاد.

---

## ۴. نکته‌ی مهم: مدیریت خطا

* توی کد بالا، اگر `error()` برگرده (یعنی برنامه رو متوقف نکنه)، ممکنه کد همچنان ادامه پیدا کنه و باعث **بافر اورفلو (buffer overflow)** بشه.
* نویسنده فرض کرده `error()` اصلاً برنمی‌گرده (مثلاً `throw` میکنه یا `exit` میکنه).

---

## ۵. راه بهتر → استفاده از `push_back`

به جای مدیریت دستی آرایه و شمارنده:

```cpp
vector<int> buf;
for (int i; cin >> i;) {
    if (i < 0) error("unexpected negative value");
    buf.push_back(i);   // خود vector رشد میکنه و جا اضافه میکنه
}
```

* اینطوری دیگه لازم نیست نگران ظرفیت ثابت `max` باشیم.
* احتمال خطای بافر اورفلو از بین میره.

---

✅ **خلاصه ساده:**

* بهتره متغیرها رو همون جایی تعریف کنیم که مقدار درست براشون داریم.
* تعریف متغیر بدون initializer باعث دو بار کار (ساخت + انتساب) میشه.
* تنها موارد معقول برای تعریف بدون initializer، وقتی هستن که مقدار اولیه از کاربر یا از جریان اجرا بعداً به دست میاد.
* به جای آرایه‌ی دستی + شمارنده، معمولاً `vector` + `push_back` انتخاب امن‌تر و مدرن‌تریه.






















-----
-----
-----
-----


