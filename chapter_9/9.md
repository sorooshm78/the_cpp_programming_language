## 9.1 Introduction
سی++ مجموعه‌ای متداول و انعطاف‌پذیر از **دستورات** را ارائه می‌دهد. در واقع، هر چیزی که جالب یا پیچیده باشد، در **عبارت‌ها (expressions)** و **اعلان‌ها (declarations)** یافت می‌شود. توجه داشته باشید که یک اعلان خودش یک دستور است و یک عبارت وقتی به دستور تبدیل می‌شود که در انتهایش یک **سمیکالن (;)** اضافه کنید.

برخلاف یک عبارت، یک دستور مقداری ندارد. در عوض، دستورات برای مشخص کردن **ترتیب اجرا** به کار می‌روند. برای مثال:

```cpp
a = b + c;   // دستور عبارتی (expression statement)
if (a == 7)  // دستور شرطی if
    b = 9;   // فقط در صورتی اجرا می‌شود که a == 9 باشد
```

به صورت منطقی، دستور `a = b + c` قبل از `if` اجرا می‌شود، همان‌طور که همه انتظار دارند.
البته یک کامپایلر می‌تواند برای بهبود کارایی، کد را **بازچینی (reorder)** کند، به شرطی که نتیجه دقیقاً مشابه اجرای ترتیبی ساده باشد.


---------------

Expression → همیشه یه مقدار می‌ده.

Statement → ترتیب اجرا رو مشخص می‌کنه، خودش ارزشی نداره.

---------------

## Statement Summary
حتماً 🌹 — در ادامه ترجمهٔ متن شما به فارسی آورده شده است:

---

### گزیده‌ای از دستورهای C++

**statement (دستور):**

* declaration (اعلان)
* expressionاختیاری ;
* { statement-listاختیاری }
* try { statement-listاختیاری } handler-list
* case constant-expression : statement
* default : statement
* break ;
* continue ;
* return expressionاختیاری ;
* goto identifier ;
* identifier : statement
* selection-statement (دستور انتخابی)
* iteration-statement (دستور تکرار)

---

**selection-statement (دستور انتخابی):**

* `if ( condition ) statement`
* `if ( condition ) statement else statement`
* `switch ( condition ) statement`

---

**iteration-statement (دستور تکرار):**

* `while ( condition ) statement`
* `do statement while ( expression ) ;`
* `for ( for-init-statement conditionاختیاری ; expressionاختیاری ) statement`
* `for ( for-init-declaration : expression ) statement`

---

**statement-list (فهرست دستورها):**

* `statement statement-list`
* اختیاری

---

**condition (شرط):**

* expression (عبارت)
* `type-specifier declarator = expression`
* `type-specifier declarator { expression }`

---

**handler-list (فهرست کنترل‌کننده‌ها):**

* `handler handler-list`
* اختیاری

**handler (کنترل‌کننده):**

* `catch ( exception-declaration ) { statement-listاختیاری }`

---

### نکات تکمیلی

* یک **نقطه‌ویرگول** (semicolon) به تنهایی یک دستور محسوب می‌شود و به آن **دستور خالی** می‌گویند.
* دنباله‌ای (حتی خالی) از دستورها که درون **آکلاد**‌ها (یعنی `{` و `}`) قرار می‌گیرد، **block** یا **compound statement** (دستور مرکب) نام دارد.
* نامی که درون یک بلوک تعریف می‌شود، در پایان همان بلوک از **دامنه (scope)** خارج می‌شود (§6.3.4).
* یک اعلان (declaration) خودش یک دستور است و در C++ چیزی به نام «دستور انتساب (assignment statement)» یا «دستور فراخوانی تابع (procedure-call statement)» وجود ندارد؛ بلکه **انتساب‌ها** و **فراخوانی توابع** همگی **عبارت (expression)** هستند.
* مقدار اولیهٔ `for-init-statement` باید یا یک **اعلان** یا یک **دستور-عبارت (expression-statement)** باشد. توجه کنید که هر دو با نقطه‌ویرگول پایان می‌یابند.
* یک `for-init-declaration` باید اعلان یک متغیر منفرد **بدون مقدار اولیه** باشد.
* دستورهایی که برای مدیریت **استثناها** به کار می‌روند (try-blocks)، در بخش §13.5 توضیح داده شده‌اند.

## 9.3 Declarations as Statements
اعلام یک عبارت است. مگر اینکه متغیر به صورت استاتیک اعلان شود، مقداردهی اولیهٔ آن هر بار که جریان کنترل به اعلان می‌رسد، اجرا می‌شود (نگاه کنید به §6.4.2). دلیل اجازه دادن به اعلان‌ها در هر مکانی که یک بیانیه می‌تواند استفاده شود (و چند مکان دیگر؛ §9.4.3، §9.5.2) این است که به برنامه‌نویس امکان دهد از بروز خطاهای ناشی از مقداردهی اولیه نشدهٔ متغیرها جلوگیری کند و locality کد را بهبود بخشد. به ندرت دلیلی وجود دارد که متغیری را قبل از داشتن مقداری برای نگه داشتن آن معرفی کنیم. به عنوان مثال:

```
void f(vector<string>& v, int i, const char* p)
{
  if (p==nullptr) return;
  if (i<0 || v.size()<=i)
    error("bad index");
  string s = v[i];
  if (s == p) {
    // ...
  }
  // ...
}
```

توانایی قرار دادن اعلان‌ها پس از کد اجرایی برای بسیاری از مقادیر ثابت و سبک‌های برنامه‌نویسی با تک‌بار مقداردهی جمعی (single-assignment) که در آن مقدار یک شیء پس از مقداردهی اولیه تغییر داده نمی‌شود، ضروری است. برای انواع کاربری‌های کاربر-تعریف، تخصیص متغیر تا زمانی که مقدار مناسب برای مقداردهی در دسترس باشد می‌تواند منجر به کارایی بهتری شود. به عنوان مثال:

```
void use()
{
  string s1;
  s1 = "The best is the enemy of the good.";
  // ...
}
```

این درخواست مقداردهی اولیه پیش‌فرضی را انجام می‌دهد (به رشتهٔ خالی) که با دنبالِ آن یک مقداردهی انجام می‌شود. این ممکن است نسبت به مقداردهی ساده به مقدار دلخواه وابسته سریع‌تر نباشد:

```
string s2 {"Voltaire"};
```

دلیل رایج‌ترین برای اعلان یک متغیر بدون مقدار اولیه این است که به یک جمله نیاز دارد تا مقدار مورد نظر خود را بدست آورد. متغیرهای ورودی از جمله مثال‌های نسبتاً معقول کم‌تری هستند که این کار را می‌کنند:

```
void input()
{
  int buf[max];
  int count = 0;
  for (int i; cin>>i;) {
    if (i<0) error("unexpected negative value");
    if (count==max) error("buffer overflow");
    buf[count++] = i;
  }
  // ...
}
```

فرض می‌کنم که error() بازمی‌گردد؛ اگر بازگردد، این کد ممکن است باعث سرریز بافر شود. اغلب، push_back() (§3.2.1.3، §13.6، §31.3.6) راه‌حل بهتری برای چنین مثالی ارائه می‌دهد.

## 9.4 Selection Statements
یک مقدار می‌تواند توسط either یک عبارت شرطی یا یک بیانیه سوئیچ آزمایش شود:
- if ( شرط ) بیانیه
- if ( شرط ) بیانیه else بیانیه
- switch ( شرط ) بیانیه
یک شرط یا یک عبارت است یا یک اعلان (§9.4.3).

## 9.4.1 if Statements
در یک بیانیه־شرطی (if-statement)، اولین بیانیه (یا تنها بیانیه) زمانی اجرا می‌شود که شرط درست باشد و بیانیه دوم (اگر مشخص شود) در غیر این صورت اجرا می‌شود. اگر شرط نتیجه‌ای غیر از مقدار بولی بدهد، اگر ممکن باشد به طور ضمنی به bool تبدیل می‌شود. این بدین معناست که هر عبارت حسابی یا اشاره‌گر می‌تواند به عنوان شرط استفاده شود. برای مثال، اگر x یک عدد صحیح باشد، آنگاه

```
if (x) // ...
```

یعنی

```
if (x != 0) // ...
```

برای یک اشاره‌گر p،

```
if (p) // ...
```

یک عبارت آزمایشی مستقیم است که می‌گوید «آیا p اشاره به یک شیء معتبر دارد؟» (با فرض مقداردهی مناسب)، و معادل است با

```
if (p != nullptr) // ...
```

توجه کنید که یک مقدارِ مَشخُصِ ساده (plain) enum می‌تواند به طور ضمنی به یک عدد صحیح تبدیل شود و سپس به bool، در حالی که یک enum class نمی‌تواند (§8.4.1). برای مثال:

```
enum E1 { a, b };
enum class E2 { a, b };

void f(E1 x, E2 y)
{
  if (x) // OK
    // ...
  if (y) // خطا: تبدیل به bool مجاز نیست
    // ...
  if (y == E2::a) // OK
    // ...
}
```

عبارت‌های منطقی
&& || !
بیشترین استفاده را در شرایط دارند. عملگرهای && و || دومین آرگومان خود را تنها در صورت لازم بودن ارزیابی می‌کنند. برای مثال:

```
if (p && 1 < p->count) // ...
```

این شرط فقط زمانی مقدار 1 < p->count را بررسی می‌کند که p مقدار nullptr نباشد.

برای انتخاب بین دو گزینه که هر کدام مقداری تولید می‌کند، عبارت شرطی (conditional expression) (§11.1.3) صریح‌تر از یک if-statement است. برای مثال:

```
int max(int a, int b)
{
  return (a > b) ? a : b; // بازگرداندن بزرگ‌ترین مقدار بین a و b
}
```

یک نام تنها می‌تواند در دامنه‌ای که در آن اعلان شده استفاده شود. به ویژه، در branch دیگری از if-statement نمی‌توان از آن استفاده کرد. برای مثال:

```
void f2(int i)
{
  if (i) {
    int x = i + 2;
    ++x;
    // ...
  }
  else {
    ++x; // خطا: x در دامنه نیست
  }
  ++x; // خطا: x در دامنه نیست
}
```

یک شاخه از if-statement نمی‌تواند فقط یک اعلان باشد. اگر بخواهیم نامی را در یک شاخه معرفی کنیم، باید آن را در یک بلاک (§9.2) محصور کنیم. برای مثال:

```
void f1(int i)
{
  if (i)
    int x = i + 2; // خطا: اعلان در شاخه if-statement
}
```


-----
-----
-----
-----

### ۱. اعلان (declaration) مثل یک دستور است

در C++، وقتی داخل یک بلاک (مثلاً درون تابع یا داخل if) یک متغیر تعریف می‌کنی، اون تعریف خودش یک **statement** (دستور) حساب میشه.
مثلاً:

```cpp
int x = 5;
```

این یک دستور کامل محسوب میشه، درست مثل `if`, `for`, یا `return`.

---

### ۲. اجرای initializer

اگر متغیر **static** نباشه، مقداردهی اولیه (initializer) هر بار که کنترل برنامه به اون خط می‌رسه اجرا میشه.
مثال:

```cpp
void f() {
    int x = rand();   // هر بار که f اجرا بشه، x دوباره مقداردهی میشه
}
```

اما اگر `static` باشه:

```cpp
void f() {
    static int x = rand(); // فقط بار اول مقداردهی میشه
}
```

---

### ۳. چرا اجازه میدن هرجا بشه متغیر تعریف کرد؟

در زبان‌هایی قدیمی‌تر مثل C (نسخه‌های قدیم)، باید همه متغیرها رو ابتدای بلاک تعریف می‌کردی.
C++ اجازه میده هرجا که نیاز داشتی تعریف کنی. دلیلش:

* جلوگیری از استفاده‌ی تصادفی متغیر **بدون مقدار اولیه**
* خوانایی و محلی بودن متغیر (locality): متغیر نزدیک به جایی که استفاده میشه تعریف بشه.

---

### ۴. مثال متن

کدی که آوردی:

```cpp
void f(vector<string>& v, int i, const char* p)
{
    if (p==nullptr) return;                // اگر p تهی باشه، زود برگرد
    if (i<0 || v.size()<=i)                // بررسی اینکه i معتبره یا نه
        error("bad index");

    string s = v[i];                       // اینجا تازه s تعریف میشه
    if (s == p) {
        // ...
    }
    // ...
}
```

🔍 نکته اینجاست:
متغیر `s` دقیقا همون جایی تعریف شده که به مقدارش نیاز داریم (`v[i]`).

* اگر بالاتر (قبل از ifها) تعریفش می‌کردیم، ممکن بود برنامه قبل از رسیدن به مقدار معتبر برگرده یا خطا بده، ولی `s` بی‌دلیل ساخته بشه.
* این باعث میشه هم کارایی بهتر بشه (چون سازنده و مخرب بی‌مورد صدا زده نمیشه)، هم احتمال خطای "استفاده از متغیر بدون مقدار درست" کمتر بشه.

---

### جمع‌بندی ساده:

* تعریف متغیر در C++ یک دستور کامل حساب میشه.
* اگر متغیر static نباشه، مقداردهی اولیه هر بار که به اون خط می‌رسیم اجرا میشه.
* C++ اجازه میده هرجا لازم داشتی متغیر تعریف کنی → کدت امن‌تر و خواناتر میشه.
* مثال کد نشون میده چطور متغیر رو دقیقا در نقطه‌ای تعریف کنیم که ارزش و معنای واقعی پیدا می‌کنه.

---























## ۱. چرا اجازه داریم بعد از کد اجرایی متغیر تعریف کنیم؟

این ویژگی باعث میشه:

* **ثابت‌ها (constants)** درست همون‌جا که بهشون نیاز داریم تعریف بشن.
* **سبک تک‌اختصاص (single-assignment style)** رعایت بشه: یعنی متغیر وقتی ساخته میشه که از همون لحظه تا آخر عمرش یه مقدار ثابت داره (نه اینکه بسازیمش و بعد چند بار تغییرش بدیم).
* برای **کلاس‌ها و نوع‌های کاربر (user-defined types)** خیلی مهمه، چون بعضی‌ها ساختن و مقداردهی اولیه‌شون گرونه. اگر زودتر بسازیم و بعد دوباره مقدار بدیم، اضافه‌کاری میشه.

---

## ۲. تفاوت بین "تعریف بدون مقداردهی" و "تعریف با مقداردهی"

### حالت اول: تعریف بدون initializer + انتساب بعدی

```cpp
void use()
{
    string s1;                     // ساخته میشه به عنوان رشته خالی ""
    s1 = "The best is the enemy of the good."; // بعد دوباره مقداردهی میشه
}
```

این یعنی:

1. اول سازنده‌ی پیش‌فرض (`string()`) صدا زده میشه → رشته خالی ساخته میشه.
2. بعد عملگر انتساب (`operator=`) صدا زده میشه → محتوای جدید جایگزین میشه.

این یعنی **دو بار کار اضافه** (اول ساخت، بعد تغییر).

---

### حالت دوم: تعریف همراه initializer

```cpp
string s2 {"Voltaire"};
```

اینجا مستقیماً رشته با مقدار `"Voltaire"` ساخته میشه.

* فقط **یک بار سازنده** صدا زده میشه.
* سریع‌تر و بهینه‌تر از حالت قبلی.

---

## ۳. چه موقع بدون initializer تعریف می‌کنیم؟

معمولاً باید همیشه متغیر رو همون موقع مقدار بدیم.
اما بعضی وقتا لازمه **بعداً در طول اجرای حلقه یا دریافت ورودی مقدار بگیره**.

مثال متن:

```cpp
void input()
{
    int buf[max];      // یه بافر ساده
    int count = 0;     // تعداد ورودی‌هایی که گرفتیم
    for (int i; cin >> i;) {       // i اینجا مقدارش با ورودی پر میشه
        if (i < 0) error("unexpected negative value");
        if (count == max) error("buffer overflow");
        buf[count++] = i;          // مقدار i رو می‌ریزیم توی بافر
    }
}
```

اینجا:

* متغیر `i` اول ساخته میشه ولی مقداردهی اولیه نمی‌گیره.
* مقدارش هر بار در حلقه با ورودی `cin >> i` تعیین میشه.
* این یه مثال درست از متغیریه که باید **بعداً مقدار بگیره** چون مقدار اولیه از کاربر میاد.

---

## ۴. نکته‌ی مهم: مدیریت خطا

* توی کد بالا، اگر `error()` برگرده (یعنی برنامه رو متوقف نکنه)، ممکنه کد همچنان ادامه پیدا کنه و باعث **بافر اورفلو (buffer overflow)** بشه.
* نویسنده فرض کرده `error()` اصلاً برنمی‌گرده (مثلاً `throw` میکنه یا `exit` میکنه).

---

## ۵. راه بهتر → استفاده از `push_back`

به جای مدیریت دستی آرایه و شمارنده:

```cpp
vector<int> buf;
for (int i; cin >> i;) {
    if (i < 0) error("unexpected negative value");
    buf.push_back(i);   // خود vector رشد میکنه و جا اضافه میکنه
}
```

* اینطوری دیگه لازم نیست نگران ظرفیت ثابت `max` باشیم.
* احتمال خطای بافر اورفلو از بین میره.

---

✅ **خلاصه ساده:**

* بهتره متغیرها رو همون جایی تعریف کنیم که مقدار درست براشون داریم.
* تعریف متغیر بدون initializer باعث دو بار کار (ساخت + انتساب) میشه.
* تنها موارد معقول برای تعریف بدون initializer، وقتی هستن که مقدار اولیه از کاربر یا از جریان اجرا بعداً به دست میاد.
* به جای آرایه‌ی دستی + شمارنده، معمولاً `vector` + `push_back` انتخاب امن‌تر و مدرن‌تریه.


-----
-----
-----
-----

## switch Statements
یک دستور **switch** بین مجموعه‌ای از گزینه‌ها (case-labels) انتخاب می‌کند. عبارت در **case-label**ها باید یک عبارت ثابت از نوع صحیح (integral) یا شمارشی (enumeration) باشد. یک مقدار نمی‌تواند بیش از یک بار در **case-label**ها استفاده شود. به عنوان مثال:

```cpp
void f(int i)
{
    switch (i) {
        case 2.7: // خطا: استفاده از عدد اعشاری در case
        // ...
        case 2:
        // ...
        case 4-2: // خطا: عدد 2 دو بار استفاده شده است
        // ...
    };
}
```

یک دستور **switch** می‌تواند به صورت مجموعه‌ای از دستورات **if** نوشته شود. به عنوان مثال:

```cpp
switch (val) {
    case 1:
        f();
        break;
    case 2:
        g();
        break;
    default:
        h();
        break;
}
```

می‌توان این را به شکل زیر نوشت:

```cpp
if (val == 1)
    f();
else if (val == 2)
    g();
else
    h();
```

معنی هر دو نسخه یکسان است، اما نسخه اول (**switch**) ترجیح داده می‌شود زیرا ماهیت عملیات (آزمایش یک مقدار واحد در برابر مجموعه‌ای از ثابت‌ها) واضح است. این باعث می‌شود که **switch** برای مثال‌های غیرترivial راحت‌تر خوانده شود. معمولاً همچنین باعث تولید کد بهینه‌تر می‌شود، زیرا نیازی به بررسی مکرر مقادیر فردی نیست و می‌توان از جدول پرش (jump table) استفاده کرد.

---

**توجه:** هر **case** در **switch** باید به نحوی خاتمه یابد، مگر اینکه بخواهید اجرای **case** بعدی ادامه یابد. به عنوان مثال:

```cpp
switch (val) { // مراقب باشید
    case 1:
        cout << "case 1\n";
    case 2:
        cout << "case 2\n";
    default:
        cout << "default: case not found\n";
}
```

اگر `val==1` باشد، خروجی ممکن است تازه‌کاران را شگفت‌زده کند:

```
case 1
case 2
default: case not found
```

ایده خوبی است که مواردی که سقوط (fall-through) **عمدی** است را کامنت بگذارید تا سقوط بدون کامنت به عنوان خطا فرض شود. به عنوان مثال:

```cpp
switch (action) { // مدیریت جفت (action, value)
    case do_and_print:
        act(value);
        // بدون break: ادامه به print
    case print:
        print(value);
        break;
    // ...
}
```

یک **break** رایج‌ترین روش برای خاتمه هر **case** است، اما گاهی اوقات **return** هم مفید است.

---

**چه زمانی باید از default استفاده کرد؟**
جواب قطعی وجود ندارد. یک استفاده این است که default برای رایج‌ترین حالت استفاده شود. استفاده رایج دیگر این است که default صرفاً برای گرفتن خطاها باشد و همه جایگزین‌های معتبر توسط **case**ها پوشش داده شوند.

با این حال، یک مورد وجود دارد که نباید از default استفاده کرد: اگر **switch** برای داشتن یک case برای هر شمارنده (enumerator) در یک enum طراحی شده باشد، بهتر است default حذف شود تا کامپایلر بتواند نسبت به مجموعه‌ای از **case**هایی که تقریباً اما نه کاملاً با enum مطابقت دارند، هشدار دهد. به عنوان مثال، این تقریباً حتماً یک خطاست:

```cpp
enum class Vessel { cup, glass, goblet, chalice };

void problematic(Vessel v)
{
    switch (v) {
        case Vessel::cup: /* ... */ break;
        case Vessel::glass: /* ... */ break;
        case Vessel::goblet: /* ... */ break;
    }
}
```

چنین اشتباهی به راحتی هنگام اضافه کردن یک شمارنده جدید در طول نگهداری رخ می‌دهد.
آزمایش برای یک مقدار «غیرممکن» از شمارنده بهتر است جداگانه انجام شود.

## Declarations in Cases
امکان دارد و معمولاً رایج است که متغیرها را در بلاک یک دستور `switch` اعلام کنیم. با این حال، نمی‌توان از مقداردهی اولیه صرف‌نظر کرد. برای مثال:

```cpp
void f(int i)
{
    switch (i) {
    case 0:
        int x;      // مقداردهی نشده
        int y = 3;  // خطا: مقداردهی اولیه می‌تواند نادیده گرفته شود (به‌طور صریح مقداردهی شده)
        string s;   // خطا: مقداردهی اولیه می‌تواند نادیده گرفته شود (به‌طور ضمنی مقداردهی شده)
    case 1:
        ++x;        // خطا: استفاده از شیء مقداردهی نشده
        ++y;
        s = "nasty!";
    }
}
```

اینجا، اگر `i == 1` باشد، جریان اجرای برنامه، مقداردهی‌های `y` و `s` را نادیده می‌گیرد، بنابراین تابع `f()` کامپایل نخواهد شد. متأسفانه، از آنجا که `int` نیازی به مقداردهی اولیه ندارد، اعلام متغیر `x` خطا نیست. با این حال، استفاده از آن خطاست زیرا از یک متغیر مقداردهی نشده خوانده می‌شود. متأسفانه، کامپایلرها اغلب فقط یک هشدار برای استفاده از متغیر مقداردهی نشده می‌دهند و نمی‌توانند همهٔ این اشتباهات را به‌طور قابل اعتماد تشخیص دهند. همان‌طور که معمول است، از متغیرهای مقداردهی نشده خودداری کنید (§6.3.5.1).

اگر نیاز به یک متغیر درون دستور `switch` داریم، می‌توانیم محدودهٔ آن را با قرار دادن اعلام و استفاده از آن در یک بلاک محدود کنیم. برای مثال، به تابع `prim()` در §10.2.1 مراجعه کنید.

## Declarations in Conditions
برای جلوگیری از استفادهٔ تصادفی یا اشتباه از یک متغیر، معمولاً ایدهٔ خوبی است که متغیر را در **کوچک‌ترین محدودهٔ ممکن** معرفی کنیم. به‌ویژه، بهتر است تعریف یک متغیر محلی را **به زمانی موکول کنیم که بتوانیم به آن یک مقدار اولیه بدهیم**. با این کار، نمی‌توانیم قبل از مقداردهی اولیه از متغیر استفاده کنیم و مشکل ایجاد شود.

یکی از زیباترین کاربردهای این دو اصل، **اعلام متغیر در یک شرط** است. برای مثال:

```cpp
if (double d = prim(true)) {
    left /= d;
    break;
}
```

اینجا، `d` هم اعلام و هم مقداردهی اولیه شده و مقدار `d` بعد از مقداردهی به‌عنوان مقدار شرط بررسی می‌شود. محدودهٔ (scope) `d` از نقطهٔ اعلام آن تا انتهای همان دستوری که شرط کنترل می‌کند ادامه دارد. به‌عنوان مثال، اگر یک شاخهٔ `else` هم وجود داشت، `d` در هر دو شاخه در محدودهٔ قابل دسترسی بود.

گزینهٔ واضح و سنتی این است که `d` را قبل از شرط اعلام کنیم. اما این کار باعث می‌شود محدودهٔ `d` بیشتر شود و ممکن است **قبل از مقداردهی اولیه یا بعد از زمان مفید مورد نظر، از آن استفاده شود**:

```cpp
double d;
// ...
d2 = d; // اوه! استفادهٔ اشتباه
// ...
if (d = prim(true)) {
    left /= d;
    break;
}
// ...
d = 2.0; // دو استفادهٔ غیرمرتبط از d
```

علاوه بر مزایای منطقی اعلام متغیرها در شرط، این کار **کد منبع را نیز فشرده‌تر و مرتب‌تر می‌کند**.

توجه: یک اعلام در شرط باید **یک متغیر یا یک const را همزمان اعلام و مقداردهی اولیه کند**.

## Iteration Statements
یک حلقه می‌تواند به صورت یک دستور `for`، `while` یا `do` بیان شود:

```cpp
while (condition) statement
do statement while (expression);
for (for-init-statement; conditionopt; expressionopt) statement
for (for-declaration : expression) statement
```

* **for-init-statement** باید یا یک **اعلام متغیر (declaration)** باشد یا یک **دستور-عبارت (expression-statement)**. توجه داشته باشید که هر دو با **نقطه‌ویرگول** (`;`) پایان می‌یابند.

* **دستور داخل حلقه for** (که به آن **controlled statement** یا **loop body** گفته می‌شود) به صورت تکراری اجرا می‌شود تا زمانی که شرط نادرست شود یا برنامه‌نویس به روش دیگری از حلقه خارج شود، مانند استفاده از `break`، `return`، `throw` یا `goto`.

* حلقه‌های پیچیده‌تر می‌توانند با **ترکیب الگوریتم‌ها و توابع lambda** بیان شوند (§11.4.2).

## Range-for Statement
ساده‌ترین حلقه، **دستور for با محدوده (range-for)** است؛ این حلقه به برنامه‌نویس اجازه می‌دهد تا به هر عنصر یک محدوده دسترسی داشته باشد. به عنوان مثال:

```cpp
int sum(vector<int>& v)
{
    int s = 0;
    for (int x : v)
        s += x;
    return s;
}
```

عبارت `for (int x : v)` را می‌توان این‌گونه خواند: «برای هر عنصر x در محدوده v» یا ساده‌تر: «برای هر x در v». عناصر v به ترتیب از اولین تا آخرین بازدید می‌شوند.

**دامنه‌ی (scope) متغیری که عنصر را نام‌گذاری می‌کند (در اینجا x) در داخل خود دستور for است.**

عبارت بعد از علامت دو نقطه (`:`) باید یک دنباله (sequence) باشد؛ یعنی باید مقداری بدهد که بتوان برای آن `v.begin()` و `v.end()` یا `begin(v)` و `end(v)` را فراخوانی کرد تا **ایرتریتور (iterator)** به دست آوریم (§4.5):

1. کامپایلر ابتدا به دنبال توابع عضو `begin` و `end` می‌گردد و سعی می‌کند از آن‌ها به عنوان محدوده استفاده کند. اگر `begin` یا `end` پیدا شود ولی قابل استفاده به عنوان محدوده نباشد (مثلاً چون `begin` یک متغیر است نه یک تابع)، دستور range-for خطا است.
2. در غیر این صورت، کامپایلر به دنبال جفت توابع عضو begin/end در دامنهٔ پیرامون می‌گردد. اگر چیزی پیدا نشود یا قابل استفاده نباشد (مثلاً begin آرگومانی از نوع دنباله نگیرد)، دستور range-for خطا است.

برای آرایه‌های توکار (`built-in array`) مانند `T v[N]`، کامپایلر از `v` و `v+N` به عنوان `begin(v)` و `end(v)` استفاده می‌کند. هدر `<iterator>` برای آرایه‌های توکار و تمام کانتینرهای استاندارد کتابخانه، `begin(c)` و `end(c)` را فراهم می‌کند. برای دنباله‌های طراحی‌شده توسط خودمان، می‌توانیم `begin()` و `end()` را به همان روش کانتینرهای استاندارد تعریف کنیم (§4.4.5).

متغیر کنترل‌شده، `x` در مثال بالا، که به عنصر فعلی اشاره دارد، **معادل `*p`** در استفاده از دستور for معادل زیر است:

```cpp
int sum2(vector<int>& v)
{
    int s = 0;
    for (auto p = begin(v); p != end(v); ++p)
        s += *p;
    return s;
}
```

اگر نیاز دارید عنصر یک محدوده را تغییر دهید، متغیر عنصر باید **ارجاع (reference)** باشد. به عنوان مثال، می‌توانیم هر عنصر یک وکتور را به این صورت افزایش دهیم:

```cpp
void incr(vector<int>& v)
{
    for (int& x : v)
        ++x;
}
```

ارجاعات همچنین برای عناصری مناسب‌اند که ممکن است بزرگ باشند، زیرا کپی کردن آن‌ها به متغیر عنصر هزینه‌بر است. به عنوان مثال:

```cpp
template<class T> 
T accum(vector<T>& v)
{
    T sum = 0;
    for (const T& x : v)
        sum += x;
    return sum;
}
```

توجه داشته باشید که **حلقه range-for به طور عمد ساده طراحی شده است.** به عنوان مثال، با استفاده از آن نمی‌توان همزمان به دو عنصر دست زد و نمی‌توان دو محدوده را همزمان پیمایش کرد. برای این کار نیاز به دستور for معمولی داریم.

## for Statements
یک نوع عمومی‌تر از دستور **for** نیز وجود دارد که کنترل بیشتری روی حلقه فراهم می‌کند. متغیر حلقه، شرط پایان حلقه و عبارتی که متغیر حلقه را به‌روزرسانی می‌کند، همگی به صورت «روشن و واضح» در یک خط ارائه می‌شوند. به عنوان مثال:

```cpp
void f(int v[], int max)
{
    for (int i = 0; i != max; ++i)
        v[i] = i * i;
}
```

این معادل است با:

```cpp
void f(int v[], int max)
{
    int i = 0; // معرفی متغیر حلقه i
    while (i != max) { // بررسی شرط پایان
        v[i] = i * i; // اجرای بدنه حلقه
        ++i; // افزایش مقدار متغیر حلقه
    }
}
```

می‌توان یک متغیر را در قسمت **initializer** دستور for تعریف کرد. اگر آن initializer یک **declaration** باشد، متغیری که معرفی می‌کند تا پایان دستور for در محدوده (scope) خواهد بود.

همیشه مشخص نیست که چه نوع داده‌ای برای متغیر کنترل حلقه مناسب است، بنابراین استفاده از **auto** اغلب مفید است:

```cpp
for (auto p = begin(c); c != end(c); ++p) {
    // ... استفاده از iterator p برای عناصر container c ...
}
```

اگر لازم باشد مقدار نهایی یک **index** بعد از خروج از حلقه for مشخص باشد، متغیر index باید خارج از حلقه for تعریف شود.

اگر نیاز به مقداردهی اولیه نباشد، دستور مقداردهی اولیه می‌تواند خالی باشد.

اگر عبارتی که قرار است متغیر حلقه را افزایش دهد حذف شود، باید متغیر حلقه را به شکل دیگری، معمولاً در بدنه حلقه، به‌روزرسانی کنیم. اگر حلقه از نوع ساده «تعریف متغیر حلقه، بررسی شرط، به‌روزرسانی متغیر حلقه» نباشد، معمولاً بهتر است با دستور **while** بیان شود.

با این حال، یک حالت شیک وجود دارد:

```cpp
for (string s; cin >> s;)
    v.push_back(s);
```

در این مثال، خواندن و بررسی شرط پایان در `cin >> s` ترکیب شده‌اند، بنابراین نیازی به متغیر حلقه صریح نیست. از طرف دیگر، استفاده از for به جای while اجازه می‌دهد تا محدوده (scope) عنصر فعلی `s` فقط به داخل حلقه محدود شود.

یک دستور for همچنین برای بیان حلقه‌ای بدون شرط پایان صریح مفید است:

```cpp
for (;;) { // حلقه «همیشه»
    // ...
}
```

با این حال، بسیاری این سبک را مبهم می‌دانند و ترجیح می‌دهند از:

```cpp
while(true) { // حلقه «همیشه»
    // ...
}
```

## while Statements
یک دستور **while** تا زمانی که شرط آن **false** شود، دستور کنترل‌شده‌اش را اجرا می‌کند. برای مثال:

```cpp
template<class Iter, class Value>
Iter find(Iter first, Iter last, Value val)
{
    while (first != last && *first != val)
        ++first;
    return first;
}
```

من تمایل دارم از **while** به جای **for** استفاده کنم وقتی که **متغیر حلقه مشخص و واضحی وجود ندارد** یا وقتی که **به‌روزرسانی متغیر حلقه به‌طور طبیعی در وسط بدنه حلقه انجام می‌شود**.

یک دستور **for** (§9.5.2) به راحتی می‌تواند به یک دستور **while** معادل بازنویسی شود و بالعکس.
