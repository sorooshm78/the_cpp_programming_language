## 9.1 Introduction
سی++ مجموعه‌ای متداول و انعطاف‌پذیر از **دستورات** را ارائه می‌دهد. در واقع، هر چیزی که جالب یا پیچیده باشد، در **عبارت‌ها (expressions)** و **اعلان‌ها (declarations)** یافت می‌شود. توجه داشته باشید که یک اعلان خودش یک دستور است و یک عبارت وقتی به دستور تبدیل می‌شود که در انتهایش یک **سمیکالن (;)** اضافه کنید.

برخلاف یک عبارت، یک دستور مقداری ندارد. در عوض، دستورات برای مشخص کردن **ترتیب اجرا** به کار می‌روند. برای مثال:

```cpp
a = b + c;   // دستور عبارتی (expression statement)
if (a == 7)  // دستور شرطی if
    b = 9;   // فقط در صورتی اجرا می‌شود که a == 9 باشد
```

به صورت منطقی، دستور `a = b + c` قبل از `if` اجرا می‌شود، همان‌طور که همه انتظار دارند.
البته یک کامپایلر می‌تواند برای بهبود کارایی، کد را **بازچینی (reorder)** کند، به شرطی که نتیجه دقیقاً مشابه اجرای ترتیبی ساده باشد.


---------------

Expression → همیشه یه مقدار می‌ده.

Statement → ترتیب اجرا رو مشخص می‌کنه، خودش ارزشی نداره.

---------------

## Statement Summary
حتماً 🌹 — در ادامه ترجمهٔ متن شما به فارسی آورده شده است:

---

### گزیده‌ای از دستورهای C++

**statement (دستور):**

* declaration (اعلان)
* expressionاختیاری ;
* { statement-listاختیاری }
* try { statement-listاختیاری } handler-list
* case constant-expression : statement
* default : statement
* break ;
* continue ;
* return expressionاختیاری ;
* goto identifier ;
* identifier : statement
* selection-statement (دستور انتخابی)
* iteration-statement (دستور تکرار)

---

**selection-statement (دستور انتخابی):**

* `if ( condition ) statement`
* `if ( condition ) statement else statement`
* `switch ( condition ) statement`

---

**iteration-statement (دستور تکرار):**

* `while ( condition ) statement`
* `do statement while ( expression ) ;`
* `for ( for-init-statement conditionاختیاری ; expressionاختیاری ) statement`
* `for ( for-init-declaration : expression ) statement`

---

**statement-list (فهرست دستورها):**

* `statement statement-list`
* اختیاری

---

**condition (شرط):**

* expression (عبارت)
* `type-specifier declarator = expression`
* `type-specifier declarator { expression }`

---

**handler-list (فهرست کنترل‌کننده‌ها):**

* `handler handler-list`
* اختیاری

**handler (کنترل‌کننده):**

* `catch ( exception-declaration ) { statement-listاختیاری }`

---

### نکات تکمیلی

* یک **نقطه‌ویرگول** (semicolon) به تنهایی یک دستور محسوب می‌شود و به آن **دستور خالی** می‌گویند.
* دنباله‌ای (حتی خالی) از دستورها که درون **آکلاد**‌ها (یعنی `{` و `}`) قرار می‌گیرد، **block** یا **compound statement** (دستور مرکب) نام دارد.
* نامی که درون یک بلوک تعریف می‌شود، در پایان همان بلوک از **دامنه (scope)** خارج می‌شود (§6.3.4).
* یک اعلان (declaration) خودش یک دستور است و در C++ چیزی به نام «دستور انتساب (assignment statement)» یا «دستور فراخوانی تابع (procedure-call statement)» وجود ندارد؛ بلکه **انتساب‌ها** و **فراخوانی توابع** همگی **عبارت (expression)** هستند.
* مقدار اولیهٔ `for-init-statement` باید یا یک **اعلان** یا یک **دستور-عبارت (expression-statement)** باشد. توجه کنید که هر دو با نقطه‌ویرگول پایان می‌یابند.
* یک `for-init-declaration` باید اعلان یک متغیر منفرد **بدون مقدار اولیه** باشد.
* دستورهایی که برای مدیریت **استثناها** به کار می‌روند (try-blocks)، در بخش §13.5 توضیح داده شده‌اند.

## 9.3 Declarations as Statements
اعلام یک عبارت است. مگر اینکه متغیر به صورت استاتیک اعلان شود، مقداردهی اولیهٔ آن هر بار که جریان کنترل به اعلان می‌رسد، اجرا می‌شود (نگاه کنید به §6.4.2). دلیل اجازه دادن به اعلان‌ها در هر مکانی که یک بیانیه می‌تواند استفاده شود (و چند مکان دیگر؛ §9.4.3، §9.5.2) این است که به برنامه‌نویس امکان دهد از بروز خطاهای ناشی از مقداردهی اولیه نشدهٔ متغیرها جلوگیری کند و locality کد را بهبود بخشد. به ندرت دلیلی وجود دارد که متغیری را قبل از داشتن مقداری برای نگه داشتن آن معرفی کنیم. به عنوان مثال:

```
void f(vector<string>& v, int i, const char* p)
{
  if (p==nullptr) return;
  if (i<0 || v.size()<=i)
    error("bad index");
  string s = v[i];
  if (s == p) {
    // ...
  }
  // ...
}
```

توانایی قرار دادن اعلان‌ها پس از کد اجرایی برای بسیاری از مقادیر ثابت و سبک‌های برنامه‌نویسی با تک‌بار مقداردهی جمعی (single-assignment) که در آن مقدار یک شیء پس از مقداردهی اولیه تغییر داده نمی‌شود، ضروری است. برای انواع کاربری‌های کاربر-تعریف، تخصیص متغیر تا زمانی که مقدار مناسب برای مقداردهی در دسترس باشد می‌تواند منجر به کارایی بهتری شود. به عنوان مثال:

```
void use()
{
  string s1;
  s1 = "The best is the enemy of the good.";
  // ...
}
```

این درخواست مقداردهی اولیه پیش‌فرضی را انجام می‌دهد (به رشتهٔ خالی) که با دنبالِ آن یک مقداردهی انجام می‌شود. این ممکن است نسبت به مقداردهی ساده به مقدار دلخواه وابسته سریع‌تر نباشد:

```
string s2 {"Voltaire"};
```

دلیل رایج‌ترین برای اعلان یک متغیر بدون مقدار اولیه این است که به یک جمله نیاز دارد تا مقدار مورد نظر خود را بدست آورد. متغیرهای ورودی از جمله مثال‌های نسبتاً معقول کم‌تری هستند که این کار را می‌کنند:

```
void input()
{
  int buf[max];
  int count = 0;
  for (int i; cin>>i;) {
    if (i<0) error("unexpected negative value");
    if (count==max) error("buffer overflow");
    buf[count++] = i;
  }
  // ...
}
```

فرض می‌کنم که error() بازمی‌گردد؛ اگر بازگردد، این کد ممکن است باعث سرریز بافر شود. اغلب، push_back() (§3.2.1.3، §13.6، §31.3.6) راه‌حل بهتری برای چنین مثالی ارائه می‌دهد.

## 9.4 Selection Statements
یک مقدار می‌تواند توسط either یک عبارت شرطی یا یک بیانیه سوئیچ آزمایش شود:
- if ( شرط ) بیانیه
- if ( شرط ) بیانیه else بیانیه
- switch ( شرط ) بیانیه
یک شرط یا یک عبارت است یا یک اعلان (§9.4.3).

## 9.4.1 if Statements
در یک بیانیه־شرطی (if-statement)، اولین بیانیه (یا تنها بیانیه) زمانی اجرا می‌شود که شرط درست باشد و بیانیه دوم (اگر مشخص شود) در غیر این صورت اجرا می‌شود. اگر شرط نتیجه‌ای غیر از مقدار بولی بدهد، اگر ممکن باشد به طور ضمنی به bool تبدیل می‌شود. این بدین معناست که هر عبارت حسابی یا اشاره‌گر می‌تواند به عنوان شرط استفاده شود. برای مثال، اگر x یک عدد صحیح باشد، آنگاه

```
if (x) // ...
```

یعنی

```
if (x != 0) // ...
```

برای یک اشاره‌گر p،

```
if (p) // ...
```

یک عبارت آزمایشی مستقیم است که می‌گوید «آیا p اشاره به یک شیء معتبر دارد؟» (با فرض مقداردهی مناسب)، و معادل است با

```
if (p != nullptr) // ...
```

توجه کنید که یک مقدارِ مَشخُصِ ساده (plain) enum می‌تواند به طور ضمنی به یک عدد صحیح تبدیل شود و سپس به bool، در حالی که یک enum class نمی‌تواند (§8.4.1). برای مثال:

```
enum E1 { a, b };
enum class E2 { a, b };

void f(E1 x, E2 y)
{
  if (x) // OK
    // ...
  if (y) // خطا: تبدیل به bool مجاز نیست
    // ...
  if (y == E2::a) // OK
    // ...
}
```

عبارت‌های منطقی
&& || !
بیشترین استفاده را در شرایط دارند. عملگرهای && و || دومین آرگومان خود را تنها در صورت لازم بودن ارزیابی می‌کنند. برای مثال:

```
if (p && 1 < p->count) // ...
```

این شرط فقط زمانی مقدار 1 < p->count را بررسی می‌کند که p مقدار nullptr نباشد.

برای انتخاب بین دو گزینه که هر کدام مقداری تولید می‌کند، عبارت شرطی (conditional expression) (§11.1.3) صریح‌تر از یک if-statement است. برای مثال:

```
int max(int a, int b)
{
  return (a > b) ? a : b; // بازگرداندن بزرگ‌ترین مقدار بین a و b
}
```

یک نام تنها می‌تواند در دامنه‌ای که در آن اعلان شده استفاده شود. به ویژه، در branch دیگری از if-statement نمی‌توان از آن استفاده کرد. برای مثال:

```
void f2(int i)
{
  if (i) {
    int x = i + 2;
    ++x;
    // ...
  }
  else {
    ++x; // خطا: x در دامنه نیست
  }
  ++x; // خطا: x در دامنه نیست
}
```

یک شاخه از if-statement نمی‌تواند فقط یک اعلان باشد. اگر بخواهیم نامی را در یک شاخه معرفی کنیم، باید آن را در یک بلاک (§9.2) محصور کنیم. برای مثال:

```
void f1(int i)
{
  if (i)
    int x = i + 2; // خطا: اعلان در شاخه if-statement
}
```
