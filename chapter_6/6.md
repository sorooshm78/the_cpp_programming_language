زبان C++ و کتابخانه استاندارد آن توسط استاندارد ISO تعریف شده‌اند: ISO/IEC 14882:2011. در این کتاب، ارجاع‌ها به استاندارد به شکل §iso.23.3.6.1 نوشته شده‌اند. اگر جایی در متن کتاب ابهام، نقص یا اشتباهی دیدید، بهتر است به خود استاندارد مراجعه کنید. اما انتظار نداشته باشید استاندارد مثل یک آموزش ساده برای غیرمتخصص‌ها باشد.

رعایت دقیق استاندارد زبان و کتابخانه C++ به تنهایی تضمین‌کننده کد خوب یا قابل حمل نیست. استاندارد فقط می‌گوید برنامه‌نویس روی چه چیزهایی می‌تواند در هر پیاده‌سازی حساب کند و روی چه چیزهایی نمی‌تواند. ممکن است برنامه‌ای کاملاً مطابق استاندارد باشد ولی کیفیت خوبی نداشته باشد. همچنین، بسیاری از برنامه‌های واقعی برای دسترسی به امکانات سیستم یا سخت‌افزار که در زبان C++ قابل بیان مستقیم نیستند، به ویژگی‌هایی متکی‌اند که استاندارد تضمین نمی‌کند همیشه قابل حمل باشند.

بسیاری از ویژگی‌های مهم در استاندارد به عنوان «رفتار تعریف‌شده توسط پیاده‌سازی» (implementation-defined) شناخته می‌شوند. یعنی هر پیاده‌سازی باید یک رفتار مشخص و مستند برای آن ویژگی داشته باشد. مثلا:

```cpp
unsigned char c1 = 64;  // رفتار مشخص است: چون char حداقل 8 بیت دارد و 64 در آن جا می‌شود
unsigned char c2 = 1256; // رفتار به پیاده‌سازی بستگی دارد: اگر char فقط 8 بیت باشد، مقدار برش می‌خورد
```

مقدار c1 مشخص است چون char حداقل ۸ بیت دارد و مقدار ۶۴ در آن جا می‌شود. اما مقدار c2 به این دلیل تعریف‌شده توسط پیاده‌سازی است که اندازه char به پیاده‌سازی بستگی دارد. اگر char فقط ۸ بیت باشد، مقدار ۱۲۵۶ به مقدار ۲۳۲ برش می‌خورد.

بیشتر ویژگی‌های «تعریف‌شده توسط پیاده‌سازی» به تفاوت‌های سخت‌افزاری مربوط می‌شوند. همچنین برخی رفتارها «تعریف‌نشده» یا «نامشخص» هستند؛ یعنی چند رفتار ممکن است درست باشند ولی پیاده‌ساز مجبور نیست بگوید کدام یکی رخ می‌دهد. برای مثال، مقدار برگشتی از عملگر new مشخص نیست یا مقدار متغیری که توسط دو نخ همزمان تغییر می‌کند، مگر اینکه هماهنگی لازم انجام شده باشد.

در برنامه‌های واقعی معمولاً باید به رفتارهای تعریف‌شده توسط پیاده‌سازی متکی باشیم، چون این موضوع اجازه می‌دهد برنامه روی سیستم‌های مختلف به خوبی کار کند. مثلا اگر همه کاراکترها ۸ بیت و همه اشاره‌گرها ۳۲ بیت بودند، C++ خیلی ساده‌تر می‌شد. اما کاراکترهای ۱۶ و ۳۲ بیت و اشاره‌گرهای ۱۶ و ۶۴ بیت در دنیای واقعی زیادند.

برای اینکه برنامه‌ها بیشتر قابل حمل باشند، بهتر است صریحاً مشخص کنیم روی کدام ویژگی‌های تعریف‌شده توسط پیاده‌سازی حساب می‌کنیم و آن بخش‌ها را در قسمت‌های مشخص و جداگانه برنامه قرار دهیم. مثلا همه وابستگی‌ها به اندازه سخت‌افزار را در یک فایل هدر با ثابت‌ها و تعریف نوع‌ها جمع کنیم. کتابخانه استاندارد برای این کار، کلاس numeric\_limits (§40.2) را دارد. همچنین می‌توانیم با استفاده از static\_assert (§2.4.3.3) فرضیاتمان درباره این ویژگی‌ها را بررسی کنیم:

```cpp
static_assert(4 <= sizeof(int), "sizeof(int) too small");
```

رفتار «تعریف‌نشده» (undefined behavior) وضعیت بدتری دارد. یعنی استاندارد هیچ رفتار منطقی از پیاده‌سازی نمی‌خواهد و معمولاً استفاده از چنین ویژگی‌هایی باعث رفتارهای خطرناک و ناپایدار می‌شود. مثلا:

```cpp
const int size = 4 * 1024;
char page[size];
void f()
{
  page[size + size] = 7;  // رفتار تعریف‌نشده است
}
```

در این کد، ممکن است داده‌های دیگر را خراب کند یا باعث خطای سخت‌افزاری شود. پیاده‌سازی لازم نیست یکی از رفتارهای ممکن را انتخاب کند. وقتی بهینه‌سازهای قدرتمند استفاده شوند، اثرات رفتار تعریف‌نشده حتی غیرقابل پیش‌بینی‌تر می‌شوند. اگر چند رفتار ممکن و منطقی وجود داشته باشد، آن ویژگی معمولاً «نامشخص» یا «تعریف‌شده توسط پیاده‌سازی» در نظر گرفته می‌شود نه «تعریف‌نشده».

صرف زمان و تلاش برای اطمینان از این که برنامه از رفتارهای نامشخص یا تعریف‌نشده استفاده نکند، ارزش زیادی دارد. در بسیاری موارد ابزارهایی هم وجود دارند که به شما در این کار کمک می‌کنند.

---------------------
---------------------
---------------------
---------------------
---------------------

رفتارهای دیگر «نامشخص» (unspecified) هستند؛ یعنی چندین رفتار ممکن قابل قبول است، اما پیاده‌ساز موظف نیست مشخص کند کدام یک دقیقاً رخ می‌دهد. معمولاً دلیل این که چیزی نامشخص در نظر گرفته می‌شود این است که رفتار دقیق آن به دلایل بنیادی قابل پیش‌بینی نیست. برای مثال، مقدار دقیق برگشتی از عملگر new نامشخص است. همچنین مقدار یک متغیر که توسط دو رشته همزمان تغییر می‌کند نامشخص است مگر این که مکانیزم هماهنگی برای جلوگیری از «رقابت داده» (data race) استفاده شده باشد (§41.2).

در برنامه‌های واقعی معمولاً لازم است که به رفتارهای تعریف‌شده توسط پیاده‌سازی تکیه کنیم. این قیمت را می‌پردازیم تا بتوانیم برنامه را روی انواع مختلف سیستم‌ها به خوبی اجرا کنیم. مثلاً زبان C++ خیلی ساده‌تر بود اگر همه کاراکترها ۸ بیت و همه اشاره‌گرها ۳۲ بیت بودند، اما در دنیای واقعی مجموعه‌های کاراکتری ۱۶ و ۳۲ بیتی و اشاره‌گرهای ۱۶ و ۶۴ بیتی رایج هستند.

برای افزایش قابلیت حمل برنامه بهتر است صریح باشیم درباره این که روی کدام ویژگی‌های تعریف‌شده توسط پیاده‌سازی حساب می‌کنیم و بخش‌های حساس‌تر را در قسمت‌های مشخص و جداگانه برنامه قرار دهیم. مثلاً همه وابستگی‌ها به اندازه‌های سخت‌افزاری را به صورت ثابت‌ها و تعریف نوع‌ها در یک فایل هدر جمع کنیم. برای پشتیبانی از این روش، کتابخانه استاندارد کلاس numeric\_limits (§40.2) را ارائه می‌دهد. همچنین می‌توان بسیاری از فرضیات مربوط به ویژگی‌های تعریف‌شده توسط پیاده‌سازی را با static\_assert (§2.4.3.3) بررسی کرد. برای مثال:

```cpp
static_assert(4 <= sizeof(int), "sizeof(int) too small");
```

رفتار «تعریف‌نشده» (undefined) بدتر است. اگر استاندارد برای یک ساختار هیچ رفتار منطقی مشخص نکرده باشد، آن ساختار تعریف‌نشده است. معمولاً وقتی از ویژگی تعریف‌نشده استفاده می‌کنیم، برنامه به شکل بسیار بدی رفتار می‌کند. مثلاً:

```cpp
const int size = 4 * 1024;
char page[size];
void f()
{
  page[size + size] = 7;  // رفتار تعریف‌نشده است
}
```

نتایج ممکن این کد شامل خراب شدن داده‌های دیگر و ایجاد خطا یا استثناء سخت‌افزاری است. پیاده‌سازی مجبور نیست یکی از نتایج ممکن را انتخاب کند.

وقتی بهینه‌سازهای قدرتمند به کار می‌روند، اثرات رفتار تعریف‌نشده می‌تواند کاملاً غیرقابل پیش‌بینی شود. اگر مجموعه‌ای از رفتارهای ممکن و قابل پیاده‌سازی به سادگی وجود داشته باشد، آن ویژگی معمولاً «نامشخص» یا «تعریف‌شده توسط پیاده‌سازی» در نظر گرفته می‌شود نه «تعریف‌نشده».

صرف زمان و تلاش زیاد برای اطمینان از این که برنامه از ویژگی‌های نامشخص یا تعریف‌نشده استفاده نکند، بسیار ارزشمند است. در بسیاری موارد، ابزارهایی هم وجود دارند که در این زمینه به کمک برنامه‌نویس می‌آیند.


## Implementations
ترجمه متن:

یک پیاده‌سازی C++ می‌تواند یا «میزبان» (hosted) باشد یا «بدون میزبان» (freestanding) (§iso.17.6.1.3).
یک پیاده‌سازی میزبان شامل تمامی امکانات کتابخانه استاندارد است که در استاندارد (§30.2) و در این کتاب توضیح داده شده‌اند.
یک پیاده‌سازی بدون میزبان ممکن است امکانات کمتری از کتابخانه استاندارد را ارائه دهد، به شرطی که موارد زیر فراهم باشند:
پیاده‌سازی‌های بدون میزبان برای کدی طراحی شده‌اند که تنها با حداقل‌ترین پشتیبانی از سیستم‌عامل اجرا می‌شود.
بسیاری از پیاده‌سازی‌ها همچنین گزینه‌ای (غیر استاندارد) برای عدم استفاده از استثناها (exceptions) ارائه می‌دهند، برای برنامه‌های بسیار حداقلی که نزدیک به سخت‌افزار اجرا می‌شوند.

-------------------
-------------------
-------------------
-------------------

حتماً! این متن درباره دو نوع اصلی پیاده‌سازی زبان برنامه‌نویسی C++ صحبت می‌کند: **میزبان (hosted)** و **بدون میزبان (freestanding)**.

---

### ۱. پیاده‌سازی میزبان (Hosted Implementation)

* این نوع پیاده‌سازی همان حالت معمولی است که بیشتر برنامه‌های C++ روی آن اجرا می‌شوند، یعنی روی یک سیستم عامل کامل مثل ویندوز، لینوکس یا مک.
* پیاده‌سازی میزبان تمامی امکانات کتابخانه استاندارد C++ را در اختیار برنامه‌نویس می‌گذارد؛ مثل توابع استاندارد، ساختارهای داده، ورودی/خروجی و … که در مستندات استاندارد زبان مشخص شده‌اند.
* معمولاً برنامه‌های کاربردی که روی سیستم‌عامل‌های کامل اجرا می‌شوند، از این نوع پیاده‌سازی استفاده می‌کنند.

---

### ۲. پیاده‌سازی بدون میزبان (Freestanding Implementation)

* این نوع پیاده‌سازی برای محیط‌هایی است که سیستم‌عامل یا حداقل پشتیبانی از سیستم‌عامل بسیار محدود یا حتی وجود ندارد؛ مثلاً سیستم‌های تعبیه‌شده (embedded systems)، میکروکنترلرها، سیستم‌های خیلی نزدیک به سخت‌افزار و …
* در این حالت، همه امکانات کتابخانه استاندارد C++ ارائه نمی‌شود و فقط بخشی از آن که برای محیط هدف ضروری است، در دسترس است.
* استاندارد C++ حداقل امکاناتی را مشخص کرده که این نوع پیاده‌سازی باید ارائه دهد تا برنامه‌ها بتوانند روی چنین محیط‌هایی اجرا شوند.
* بسیاری از پیاده‌سازی‌های بدون میزبان گزینه‌ای غیر استاندارد دارند که می‌شود استثناها (exceptions) را غیرفعال کرد؛ چون مدیریت استثناها بار اضافی و پیچیدگی به برنامه‌های خیلی نزدیک به سخت‌افزار اضافه می‌کند که معمولاً در این محیط‌ها نمی‌خواهند یا نمی‌توانند از آن استفاده کنند.

---

### جمع‌بندی

* اگر برنامه‌ای روی سیستم عامل کامل اجرا می‌شود، معمولاً از پیاده‌سازی میزبان استفاده می‌کند که تمام امکانات استاندارد را دارد.
* اگر برنامه‌ای روی سخت‌افزار کم‌منابع یا بدون سیستم‌عامل کامل اجرا می‌شود، از پیاده‌سازی بدون میزبان استفاده می‌کند که امکانات محدودتری دارد و می‌تواند استثناها را غیرفعال کند تا سبک‌تر و نزدیک‌تر به سخت‌افزار باشد.

---


-------------------
-------------------
-------------------
-------------------

## The Basic Source Character Set
ترجمه متن:

استاندارد C++ و مثال‌های این کتاب با استفاده از مجموعه‌کاراکترهای پایه منبع نوشته شده‌اند که شامل حروف، اعداد، کاراکترهای گرافیکی و فاصله‌ها از نسخه آمریکایی مجموعه‌کاراکتر ۷ بیتی بین‌المللی ISO 646-1983 به نام ASCII (ANSI3.4-1968) می‌باشد.
این موضوع می‌تواند برای کسانی که C++ را در محیطی با مجموعه‌کاراکتر متفاوت استفاده می‌کنند، مشکل‌ساز باشد:

* ASCII شامل کاراکترهای علامت‌گذاری و نمادهای عملگر (مانند ]، { و !) است که در برخی مجموعه‌کاراکترها موجود نیستند.
* نیاز به روشی برای نمایش کاراکترهایی وجود دارد که نمایش راحتی ندارند (مانند newline یا «کاراکتری با مقدار ۱۷»).
* ASCII کاراکترهایی مانند ñ، Þ و Æ را که برای نوشتن زبان‌های غیر از انگلیسی استفاده می‌شوند، ندارد.

برای استفاده از مجموعه‌کاراکتر گسترده‌تر در کد منبع، محیط برنامه‌نویسی می‌تواند مجموعه‌کاراکتر گسترده را به مجموعه‌کاراکتر پایه منبع به چند روش نگاشت کند، مثلاً با استفاده از نام‌های کاراکتر جهانی (§6.2.3.2).

## Types
ترجمه متن:

در نظر بگیرید:

```cpp
x = y + f(2);
```

برای اینکه این عبارت در یک برنامه C++ معنا پیدا کند، نام‌های `x`، `y` و `f` باید به صورت مناسب اعلام شده باشند. یعنی، برنامه‌نویس باید مشخص کند که موجودیت‌هایی با نام‌های `x`، `y` و `f` وجود دارند و این موجودیت‌ها از نوع‌هایی هستند که عملیات‌های `=` (اختصاص مقدار)، `+` (جمع) و `()` (فراخوانی تابع) به ترتیب روی آن‌ها معنی‌دار باشد.

هر نام (شناسه) در یک برنامه C++ دارای یک نوع (type) مرتبط است. این نوع تعیین می‌کند که چه عملیاتی می‌توان روی آن نام (یعنی روی موجودیتی که نام به آن اشاره می‌کند) انجام داد و این عملیات‌ها چگونه تفسیر می‌شوند. به عنوان مثال:

```cpp
float x;    // x یک متغیر عدد اعشاری است  
int y = 7;  // y یک متغیر عدد صحیح است با مقدار اولیه ۷  
float f(int); // f تابعی است که یک عدد صحیح به عنوان ورودی می‌گیرد و یک عدد اعشاری بازمی‌گرداند  
```

این اعلان‌ها باعث می‌شوند مثال بالا معنا پیدا کند. چون `y` به عنوان `int` اعلام شده، می‌توان از آن در عملیات جمع استفاده کرد و به آن مقدار اختصاص داد. همچنین `f` به عنوان تابعی اعلام شده که یک عدد صحیح می‌گیرد، پس می‌توان آن را با ورودی عدد صحیح ۲ فراخوانی کرد.

این فصل به معرفی انواع بنیادی (§6.2.1) و اعلان‌ها (§6.3) می‌پردازد. مثال‌های این فصل صرفاً برای نشان دادن ویژگی‌های زبان هستند و هدفشان انجام کاری مفید نیست. مثال‌های بیشتر و واقع‌گرایانه‌تر در فصول بعدی ارائه می‌شوند. این فصل تنها عناصر پایه‌ای را که برنامه‌های C++ بر اساس آن‌ها ساخته می‌شوند، ارائه می‌دهد. برای تکمیل یک پروژه واقعی در C++ و به ویژه برای خواندن کد نوشته‌شده توسط دیگران، باید این عناصر به همراه اصطلاحات و سینتکس ساده مربوط به آن‌ها را بدانید.
با این حال، درک کامل همه جزئیات ذکرشده در این فصل برای فهمیدن فصول بعدی لازم نیست. بنابراین، ممکن است ترجیح دهید این فصل را به طور اجمالی مرور کنید، مفاهیم اصلی را مشاهده کنید و در صورت نیاز به جزئیات بیشتر، بعدها دوباره مراجعه کنید.

## Booleans
ترجمه متن:

نوع بولی (Boolean) که در C++ با `bool` نشان داده می‌شود، می‌تواند یکی از دو مقدار `true` یا `false` را داشته باشد. نوع بولی برای بیان نتایج عملیات‌های منطقی استفاده می‌شود. به عنوان مثال:

```cpp
void f(int a, int b)
{
    bool b1 {a == b};
    // ...
}
```

اگر مقدار `a` و `b` برابر باشد، `b1` مقدار `true` می‌گیرد؛ در غیر این صورت، مقدار آن `false` می‌شود.

استفاده رایج از نوع `bool`، به عنوان نوع خروجی تابعی است که یک شرط (پیش‌شرط) را بررسی می‌کند. به عنوان مثال:

```cpp
bool is_open(File*);
bool greater(int a, int b) { return a > b; }
```

براساس تعریف، مقدار `true` هنگام تبدیل به عدد صحیح (integer) برابر با ۱ و مقدار `false` برابر با ۰ است. بالعکس، اعداد صحیح می‌توانند به صورت ضمنی به `bool` تبدیل شوند: اعداد غیر صفر به `true` تبدیل می‌شوند و ۰ به `false`. برای مثال:

```cpp
bool b1 = 7;   // 7 نابرابر صفر است، پس b1 مقدار true می‌گیرد
bool b2 {7};   // خطا: Narrowing (تبدیل ناامن)
int i1 = true; // i1 مقدار 1 می‌شود
int i2 {true}; // i2 مقدار 1 می‌شود
```

اگر بخواهید از نگارش مقداردهی اولیه `{}` استفاده کنید تا از Narrowing جلوگیری کنید و در عین حال بخواهید یک عدد صحیح را به `bool` تبدیل کنید، می‌توانید به صورت صریح این کار را انجام دهید:

```cpp
void f(int i)
{
    bool b {i != 0};
    // ...
};
```

در عبارات حسابی و منطقی، `bool` ها به `int` تبدیل می‌شوند؛ عملیات‌های حسابی و منطقی روی مقادیر تبدیل شده انجام می‌شوند. اگر لازم باشد نتیجه دوباره به `bool` تبدیل شود، مقدار ۰ به `false` و مقدار غیر صفر به `true` تبدیل می‌شود. به عنوان مثال:

```cpp
bool a = true;
bool b = true;
bool x = a + b;   // a + b برابر 2 است، پس x مقدار true می‌گیرد
bool y = a || b;  // a || b برابر 1 است، پس y مقدار true می‌گیرد ("||" یعنی "یا")
bool z = a - b;   // a - b برابر 0 است، پس z مقدار false می‌گیرد
```

اشاره‌گرها (pointer) نیز می‌توانند به صورت ضمنی به `bool` تبدیل شوند (§10.5.2.5). اشاره‌گر غیر تهی (non-null) به `true` و اشاره‌گر `nullptr` به `false` تبدیل می‌شود. مثلاً:

```cpp
void g(int* p)
{
    bool b = p;            // تبدیل ضمنی به true یا false
    bool b2 {p != nullptr}; // تست صریح برابر نبودن با nullptr
    if (p) {               // معادل p != nullptr
        // ...
    }
}
```

من ترجیح می‌دهم از `if (p)` به جای `if (p != nullptr)` استفاده کنم، چون مستقیم‌تر مفهوم «اگر p معتبر است» را بیان می‌کند و همچنین کوتاه‌تر است. شکل کوتاه‌تر احتمال خطا را کمتر می‌کند.

--------------------
--------------------
--------------------
--------------------

---

## Narrowing Conversion چیست؟

**Narrowing conversion** در C++ به تبدیل نوع داده‌ای گفته می‌شود که ممکن است منجر به از دست رفتن اطلاعات یا تغییر ناخواسته مقدار شود.
به عبارت دیگر، وقتی داده‌ای از نوعی بزرگ‌تر یا دقیق‌تر به نوعی کوچک‌تر یا کم‌دقت‌تر تبدیل شود و احتمال افت دقت یا کاهش دامنه مقدار وجود داشته باشد، این تبدیل «narrowing» است.

---

### چرا مشکل است؟

* Narrowing باعث می‌شود مقدار تبدیل‌شده با مقدار اصلی متفاوت باشد.
* مثلاً تبدیل یک عدد اعشاری (double یا float) به عدد صحیح (int) باعث حذف بخش اعشاری می‌شود.
* یا تبدیل یک عدد بزرگ‌تر از محدوده نوع مقصد، ممکن است به مقدار نامعقول یا عدد دیگری تبدیل شود.

---

## Narrowing Conversion در C++11 و بعد از آن

C++11 مقداردهی اولیه با آکولاد `{}` را معرفی کرد که به آن **list initialization** یا **uniform initialization** گفته می‌شود.
این روش مقداردهی اولیه **نمی‌گذارد Narrowing conversions به صورت ضمنی انجام شود** و در صورت وقوع، کامپایلر خطا می‌دهد.
هدف این است که خطاهای ناشی از تبدیل‌های ناخواسته زودتر شناسایی شوند.

---

## مثال‌های Narrowing Conversion

### 1. تبدیل عدد اعشاری به صحیح (از دست رفتن بخش کسری)

```cpp
double pi = 3.14159;

int a = pi;    // درست است ولی a می‌شود 3، بخش اعشاری حذف می‌شود (narrowing)
int b{pi};     // خطا: narrowing conversion با مقداردهی اولیه با {} مجاز نیست
```

### 2. تبدیل مقدار بزرگ‌تر به نوع با محدوده کوچکتر (آندر فلو/اور فلو)

```cpp
int large = 1000;

char c = large;   // ممکن است مقدار غیرمنتظره‌ای داشته باشد چون char معمولاً 1 بایت است و نمی‌تواند همه مقادیر int را نگه دارد (narrowing)
char d{large};    // خطا: narrowing conversion با مقداردهی اولیه با {} مجاز نیست
```

### 3. تبدیل نوع صحیح بزرگ به نوع کوچک‌تر

```cpp
long long big = 5000000000;

int x = big;    // ممکن است مقدار نادرست شود چون int کوچک‌تر است
int y{big};     // خطا: narrowing conversion با مقداردهی اولیه با {}
```

### 4. تبدیل عدد صحیح غیر صفر به bool با مقداردهی اولیه با {}

```cpp
int num = 7;

bool b1 = num;  // درست است، چون غیر صفر است، b1 برابر true می‌شود
bool b2{num};   // خطا: narrowing conversion، مقداردهی اولیه با {} این تبدیل را قبول نمی‌کند
```

---

## تبدیل‌های امن که Narrowing نیستند

برخی تبدیل‌ها narrowing نیستند و در مقداردهی اولیه با `{}` مجازند:

```cpp
int i = 5;
double d1 = i;      // تبدیل صحیح به اعشاری narrowing نیست
double d2{ i };     // درست است
char c1 = 'a';
int i2 = c1;        // تبدیل char به int narrowing نیست
int i3{ c1 };       // درست است
```

---

## نکات مهم درباره Narrowing Conversion

* مقداردهی اولیه با آکولاد `{}` از Narrowing جلوگیری می‌کند و در صورت وقوع خطا می‌دهد.
* Narrowing معمولا در تبدیل‌های **float به int**، **نوع بزرگ به نوع کوچک‌تر** یا **تبدیل‌های غیرمطمئن** رخ می‌دهد.
* استفاده از مقداردهی اولیه با `{}` کمک می‌کند خطاهای مخفی تبدیل نوع سریع‌تر دیده شوند.
* برای انجام تبدیل‌های narrowing به صورت کنترل‌شده، بهتر است تبدیل صریح (`static_cast`) استفاده شود یا مقداردهی با شرط انجام شود.

---

## مثال استفاده از cast برای تبدیل ایمن

```cpp
double pi = 3.14159;

// تبدیل صریح برای جلوگیری از خطا و آگاه بودن از narrow شدن
int a = static_cast<int>(pi);  // مقدار 3 می‌گیرد ولی برنامه‌نویس آگاه است

// یا مقداردهی ایمن با {} و شرط
double val = 5.5;
int b{ (val < std::numeric_limits<int>::max()) ? static_cast<int>(val) : 0 };
```

---

### خلاصه

* **Narrowing conversion** یعنی تبدیل نوع داده‌ای که منجر به از دست دادن داده یا دقت می‌شود.
* در C++11 به بعد، مقداردهی اولیه با `{}` این تبدیل‌ها را ممنوع می‌کند و خطا می‌دهد.
* استفاده از `{}` به برنامه‌نویس کمک می‌کند از خطاهای ناخواسته تبدیل داده جلوگیری کند و برنامه قابل اطمینان‌تر شود.

---


------------------------
------------------------
------------------------
------------------------
------------------------

## Character Types
در زبان ++C انواع مختلفی از نوع داده‌های کاراکتری وجود دارد که بازتاب‌دهنده‌ی تنوع ـ و گاهی گیج‌کننده ـ مجموعه‌های کاراکتری و شیوه‌های رمزگذاری آن‌ها هستند. این‌ها عبارت‌اند از:

* **char**: نوع پیش‌فرض کاراکتر که برای متن برنامه استفاده می‌شود. `char` برای نگهداری کاراکترهای مجموعه کاراکتری پیاده‌سازی زبان به کار می‌رود و معمولاً ۸ بیتی است.
* **signed char**: مشابه `char` است، اما تضمین شده که علامت‌دار باشد، یعنی می‌تواند مقادیر مثبت و منفی را نگهداری کند.
* **unsigned char**: مشابه `char` است، اما تضمین شده که بدون علامت باشد، یعنی فقط مقادیر مثبت را نگهداری می‌کند.
* **wchar\_t**: برای نگهداری کاراکترهای مجموعه کاراکتری بزرگ‌تر مانند یونیکد فراهم شده است (نگاه کنید به بخش 7.3.2.2). اندازه‌ی `wchar_t` بستگی به پیاده‌سازی دارد و به اندازه‌ای بزرگ است که بتواند بزرگ‌ترین مجموعه کاراکتری پشتیبانی‌شده توسط تنظیمات محلی (locale) پیاده‌سازی را نگهداری کند (نگاه کنید به فصل 39).
* **char16\_t**: نوعی برای نگهداری مجموعه‌های کاراکتری ۱۶ بیتی، مانند UTF-16.
* **char32\_t**: نوعی برای نگهداری مجموعه‌های کاراکتری ۳۲ بیتی، مانند UTF-32.

این‌ها شش نوع متفاوت هستند (با وجود اینکه پسوند `_t` اغلب برای نام مستعار نوع‌ها استفاده می‌شود؛ نگاه کنید به بخش 6.5). در هر پیاده‌سازی، نوع `char` معادل یکی از دو نوع `signed char` یا `unsigned char` خواهد بود، اما این سه نام همچنان به‌عنوان نوع‌های مجزا شناخته می‌شوند.


یک متغیر از نوع `char` می‌تواند یکی از کاراکترهای مجموعه‌ی کاراکتری پیاده‌سازی را در خود نگه دارد. برای مثال:

```cpp
char ch = 'a';
```

تقریباً به‌طور عمومی، یک `char` دارای ۸ بیت است، بنابراین می‌تواند یکی از ۲۵۶ مقدار مختلف را نگهداری کند. به‌طور معمول، مجموعه‌ی کاراکتری استفاده‌شده نوعی از ISO-646 است، مانند ASCII، که کاراکترهایی را که روی صفحه‌کلید شما ظاهر می‌شوند فراهم می‌کند. بسیاری از مشکلات ناشی از این واقعیت است که این مجموعه کاراکتری تنها به‌طور جزئی استاندارد شده است.

تفاوت‌های جدی بین مجموعه‌های کاراکتری‌ای که از زبان‌های طبیعی مختلف پشتیبانی می‌کنند، و حتی بین مجموعه‌هایی که از یک زبان طبیعی به روش‌های مختلف پشتیبانی می‌کنند، وجود دارد. در این‌جا، ما فقط به چگونگی تأثیر این تفاوت‌ها بر قوانین زبان C++ علاقه‌مندیم. موضوع گسترده‌تر و جالب‌ترِ نحوه‌ی برنامه‌نویسی در محیطی چندزبانه و با مجموعه‌های کاراکتری گوناگون، فراتر از حوزه‌ی این کتاب است، گرچه در چند بخش به آن اشاره شده است (بخش‌های 6.2.3، 36.2.1، و فصل 39).

می‌توان با اطمینان فرض کرد که مجموعه کاراکتری پیاده‌سازی شامل ارقام اعشاری، ۲۶ حرف الفبای انگلیسی، و برخی علائم نگارشی پایه‌ای است. اما نمی‌توان با اطمینان فرض کرد که:

* در یک مجموعه کاراکتری ۸ بیتی، بیش از ۱۲۷ کاراکتر وجود ندارد (برای مثال، برخی مجموعه‌ها ۲۵۵ کاراکتر دارند).
* تعداد حروف الفبا بیشتر از حروف زبان انگلیسی نیست (بیشتر زبان‌های اروپایی حروف بیشتری دارند، مانند æ، þ، و ß).
* حروف الفبا پشت سر هم هستند (در EBCDIC بین 'i' و 'j' فاصله وجود دارد).
* همه‌ی کاراکترهایی که برای نوشتن C++ لازم‌اند در دسترس هستند (برخی مجموعه‌های کاراکتری ملی نمادهایی مانند {، }، \[، ]، | و \ را ندارند).
* یک `char` در ۱ بایت جا می‌گیرد. در برخی پردازنده‌های توکار (embedded) که سخت‌افزار دسترسی به بایت ندارند، ممکن است `char` چهار بایت باشد. همچنین استفاده از رمزگذاری یونیکد ۱۶ بیتی برای `char`های پایه منطقی است.

هرجا که امکان دارد، باید از فرض کردن در مورد نمایش (representation) اشیاء خودداری کنیم. این قانون کلی حتی برای کاراکترها نیز صدق می‌کند.


هر کاراکتر دارای یک مقدار عددی (صحیح) در مجموعه کاراکتری مورد استفاده‌ی پیاده‌سازی است. برای مثال، مقدار `'b'` در مجموعه کاراکتری ASCII برابر با ۹۸ است. در اینجا یک حلقه داریم که مقدار عددی هر کاراکتری را که وارد کنید نمایش می‌دهد:

```cpp
void intval()
{
    for (char c; cin >> c; )
        cout << "the value of '" << c << "' is " << int{c} << '\n';
}
```

یادداشت `int{c}` مقدار عددی (صحیح) کاراکتر `c` را برمی‌گرداند («عددی از نوع int که می‌توان از `c` ساخت»).

امکان تبدیل `char` به عدد صحیح این سؤال را مطرح می‌کند: آیا `char` علامت‌دار (signed) است یا بدون‌علامت (unsigned)؟
مقادیر ۲۵۶‌تایی قابل نمایش با یک بایت ۸ بیتی را می‌توان به صورت بازه‌ی ۰ تا ۲۵۵ یا −۱۲۷ تا ۱۲۷ تفسیر کرد.
نه، نه به صورت −۱۲۸ تا ۱۲۷ همان‌طور که شاید انتظار داشته باشید: استاندارد C++ احتمال استفاده از سخت‌افزارهایی با مکمل یک (one’s-complement) را باز می‌گذارد که در این صورت یکی از مقادیر از دست می‌رود؛ بنابراین استفاده از −۱۲۸ قابل حمل (portable) نیست.

متأسفانه، علامت‌دار یا بدون‌علامت بودن یک `char` معمولی به پیاده‌سازی بستگی دارد.
زبان C++ دو نوع را فراهم می‌کند که جواب این سؤال در موردشان مشخص است:

* `signed char` که می‌تواند دست‌کم مقادیر بین −۱۲۷ تا ۱۲۷ را نگه دارد.
* `unsigned char` که می‌تواند دست‌کم مقادیر بین ۰ تا ۲۵۵ را نگه دارد.

خوشبختانه، این تفاوت تنها زمانی اهمیت پیدا می‌کند که با مقادیری خارج از بازه ۰ تا ۱۲۷ سروکار داشته باشید و بیشتر کاراکترهای رایج در همین بازه قرار دارند.

ذخیره کردن مقادیر خارج از این بازه در یک `char` معمولی می‌تواند منجر به مشکلات پنهان در قابلیت حمل شود. اگر نیاز دارید از بیش از یک نوع `char` استفاده کنید یا مقادیر عددی را در متغیرهای `char` ذخیره کنید، به بخش §6.2.3.1 مراجعه نمایید.

توجه داشته باشید که انواع کاراکتری، نوع‌های عددی صحیح (integral types؛ §6.2.1) هستند، بنابراین عملیات محاسباتی و منطقی بیتی (bitwise؛ §10.3) روی آن‌ها قابل اعمال است. برای مثال:

```cpp
void digits()
{
    for (int i=0; i!=10; ++i)
        cout << static_cast<char>('0'+i);
}
```

این تابع ده رقم (0 تا 9) را در خروجی `cout` چاپ می‌کند.
در این‌جا، کاراکتر `'0'` به مقدار عددی‌اش تبدیل می‌شود و `i` به آن اضافه می‌شود. حاصل جمع، یک `int` است که سپس به `char` تبدیل شده و چاپ می‌شود.

عبارت `'0'+i` به‌تنهایی یک `int` است، بنابراین اگر `static_cast<char>` را حذف کرده بودیم، خروجی چیزی مانند ۴۸، ۴۹ و ... می‌بود، نه ۰، ۱ و ...


