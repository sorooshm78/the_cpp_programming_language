زبان C++ و کتابخانه استاندارد آن توسط استاندارد ISO تعریف شده‌اند: ISO/IEC 14882:2011. در این کتاب، ارجاع‌ها به استاندارد به شکل §iso.23.3.6.1 نوشته شده‌اند. اگر جایی در متن کتاب ابهام، نقص یا اشتباهی دیدید، بهتر است به خود استاندارد مراجعه کنید. اما انتظار نداشته باشید استاندارد مثل یک آموزش ساده برای غیرمتخصص‌ها باشد.

رعایت دقیق استاندارد زبان و کتابخانه C++ به تنهایی تضمین‌کننده کد خوب یا قابل حمل نیست. استاندارد فقط می‌گوید برنامه‌نویس روی چه چیزهایی می‌تواند در هر پیاده‌سازی حساب کند و روی چه چیزهایی نمی‌تواند. ممکن است برنامه‌ای کاملاً مطابق استاندارد باشد ولی کیفیت خوبی نداشته باشد. همچنین، بسیاری از برنامه‌های واقعی برای دسترسی به امکانات سیستم یا سخت‌افزار که در زبان C++ قابل بیان مستقیم نیستند، به ویژگی‌هایی متکی‌اند که استاندارد تضمین نمی‌کند همیشه قابل حمل باشند.

بسیاری از ویژگی‌های مهم در استاندارد به عنوان «رفتار تعریف‌شده توسط پیاده‌سازی» (implementation-defined) شناخته می‌شوند. یعنی هر پیاده‌سازی باید یک رفتار مشخص و مستند برای آن ویژگی داشته باشد. مثلا:

```cpp
unsigned char c1 = 64;  // رفتار مشخص است: چون char حداقل 8 بیت دارد و 64 در آن جا می‌شود
unsigned char c2 = 1256; // رفتار به پیاده‌سازی بستگی دارد: اگر char فقط 8 بیت باشد، مقدار برش می‌خورد
```

مقدار c1 مشخص است چون char حداقل ۸ بیت دارد و مقدار ۶۴ در آن جا می‌شود. اما مقدار c2 به این دلیل تعریف‌شده توسط پیاده‌سازی است که اندازه char به پیاده‌سازی بستگی دارد. اگر char فقط ۸ بیت باشد، مقدار ۱۲۵۶ به مقدار ۲۳۲ برش می‌خورد.

بیشتر ویژگی‌های «تعریف‌شده توسط پیاده‌سازی» به تفاوت‌های سخت‌افزاری مربوط می‌شوند. همچنین برخی رفتارها «تعریف‌نشده» یا «نامشخص» هستند؛ یعنی چند رفتار ممکن است درست باشند ولی پیاده‌ساز مجبور نیست بگوید کدام یکی رخ می‌دهد. برای مثال، مقدار برگشتی از عملگر new مشخص نیست یا مقدار متغیری که توسط دو نخ همزمان تغییر می‌کند، مگر اینکه هماهنگی لازم انجام شده باشد.

در برنامه‌های واقعی معمولاً باید به رفتارهای تعریف‌شده توسط پیاده‌سازی متکی باشیم، چون این موضوع اجازه می‌دهد برنامه روی سیستم‌های مختلف به خوبی کار کند. مثلا اگر همه کاراکترها ۸ بیت و همه اشاره‌گرها ۳۲ بیت بودند، C++ خیلی ساده‌تر می‌شد. اما کاراکترهای ۱۶ و ۳۲ بیت و اشاره‌گرهای ۱۶ و ۶۴ بیت در دنیای واقعی زیادند.

برای اینکه برنامه‌ها بیشتر قابل حمل باشند، بهتر است صریحاً مشخص کنیم روی کدام ویژگی‌های تعریف‌شده توسط پیاده‌سازی حساب می‌کنیم و آن بخش‌ها را در قسمت‌های مشخص و جداگانه برنامه قرار دهیم. مثلا همه وابستگی‌ها به اندازه سخت‌افزار را در یک فایل هدر با ثابت‌ها و تعریف نوع‌ها جمع کنیم. کتابخانه استاندارد برای این کار، کلاس numeric\_limits (§40.2) را دارد. همچنین می‌توانیم با استفاده از static\_assert (§2.4.3.3) فرضیاتمان درباره این ویژگی‌ها را بررسی کنیم:

```cpp
static_assert(4 <= sizeof(int), "sizeof(int) too small");
```

رفتار «تعریف‌نشده» (undefined behavior) وضعیت بدتری دارد. یعنی استاندارد هیچ رفتار منطقی از پیاده‌سازی نمی‌خواهد و معمولاً استفاده از چنین ویژگی‌هایی باعث رفتارهای خطرناک و ناپایدار می‌شود. مثلا:

```cpp
const int size = 4 * 1024;
char page[size];
void f()
{
  page[size + size] = 7;  // رفتار تعریف‌نشده است
}
```

در این کد، ممکن است داده‌های دیگر را خراب کند یا باعث خطای سخت‌افزاری شود. پیاده‌سازی لازم نیست یکی از رفتارهای ممکن را انتخاب کند. وقتی بهینه‌سازهای قدرتمند استفاده شوند، اثرات رفتار تعریف‌نشده حتی غیرقابل پیش‌بینی‌تر می‌شوند. اگر چند رفتار ممکن و منطقی وجود داشته باشد، آن ویژگی معمولاً «نامشخص» یا «تعریف‌شده توسط پیاده‌سازی» در نظر گرفته می‌شود نه «تعریف‌نشده».

صرف زمان و تلاش برای اطمینان از این که برنامه از رفتارهای نامشخص یا تعریف‌نشده استفاده نکند، ارزش زیادی دارد. در بسیاری موارد ابزارهایی هم وجود دارند که به شما در این کار کمک می‌کنند.

---------------------
---------------------
---------------------
---------------------
---------------------

رفتارهای دیگر «نامشخص» (unspecified) هستند؛ یعنی چندین رفتار ممکن قابل قبول است، اما پیاده‌ساز موظف نیست مشخص کند کدام یک دقیقاً رخ می‌دهد. معمولاً دلیل این که چیزی نامشخص در نظر گرفته می‌شود این است که رفتار دقیق آن به دلایل بنیادی قابل پیش‌بینی نیست. برای مثال، مقدار دقیق برگشتی از عملگر new نامشخص است. همچنین مقدار یک متغیر که توسط دو رشته همزمان تغییر می‌کند نامشخص است مگر این که مکانیزم هماهنگی برای جلوگیری از «رقابت داده» (data race) استفاده شده باشد (§41.2).

در برنامه‌های واقعی معمولاً لازم است که به رفتارهای تعریف‌شده توسط پیاده‌سازی تکیه کنیم. این قیمت را می‌پردازیم تا بتوانیم برنامه را روی انواع مختلف سیستم‌ها به خوبی اجرا کنیم. مثلاً زبان C++ خیلی ساده‌تر بود اگر همه کاراکترها ۸ بیت و همه اشاره‌گرها ۳۲ بیت بودند، اما در دنیای واقعی مجموعه‌های کاراکتری ۱۶ و ۳۲ بیتی و اشاره‌گرهای ۱۶ و ۶۴ بیتی رایج هستند.

برای افزایش قابلیت حمل برنامه بهتر است صریح باشیم درباره این که روی کدام ویژگی‌های تعریف‌شده توسط پیاده‌سازی حساب می‌کنیم و بخش‌های حساس‌تر را در قسمت‌های مشخص و جداگانه برنامه قرار دهیم. مثلاً همه وابستگی‌ها به اندازه‌های سخت‌افزاری را به صورت ثابت‌ها و تعریف نوع‌ها در یک فایل هدر جمع کنیم. برای پشتیبانی از این روش، کتابخانه استاندارد کلاس numeric\_limits (§40.2) را ارائه می‌دهد. همچنین می‌توان بسیاری از فرضیات مربوط به ویژگی‌های تعریف‌شده توسط پیاده‌سازی را با static\_assert (§2.4.3.3) بررسی کرد. برای مثال:

```cpp
static_assert(4 <= sizeof(int), "sizeof(int) too small");
```

رفتار «تعریف‌نشده» (undefined) بدتر است. اگر استاندارد برای یک ساختار هیچ رفتار منطقی مشخص نکرده باشد، آن ساختار تعریف‌نشده است. معمولاً وقتی از ویژگی تعریف‌نشده استفاده می‌کنیم، برنامه به شکل بسیار بدی رفتار می‌کند. مثلاً:

```cpp
const int size = 4 * 1024;
char page[size];
void f()
{
  page[size + size] = 7;  // رفتار تعریف‌نشده است
}
```

نتایج ممکن این کد شامل خراب شدن داده‌های دیگر و ایجاد خطا یا استثناء سخت‌افزاری است. پیاده‌سازی مجبور نیست یکی از نتایج ممکن را انتخاب کند.

وقتی بهینه‌سازهای قدرتمند به کار می‌روند، اثرات رفتار تعریف‌نشده می‌تواند کاملاً غیرقابل پیش‌بینی شود. اگر مجموعه‌ای از رفتارهای ممکن و قابل پیاده‌سازی به سادگی وجود داشته باشد، آن ویژگی معمولاً «نامشخص» یا «تعریف‌شده توسط پیاده‌سازی» در نظر گرفته می‌شود نه «تعریف‌نشده».

صرف زمان و تلاش زیاد برای اطمینان از این که برنامه از ویژگی‌های نامشخص یا تعریف‌نشده استفاده نکند، بسیار ارزشمند است. در بسیاری موارد، ابزارهایی هم وجود دارند که در این زمینه به کمک برنامه‌نویس می‌آیند.


## Implementations
ترجمه متن:

یک پیاده‌سازی C++ می‌تواند یا «میزبان» (hosted) باشد یا «بدون میزبان» (freestanding) (§iso.17.6.1.3).
یک پیاده‌سازی میزبان شامل تمامی امکانات کتابخانه استاندارد است که در استاندارد (§30.2) و در این کتاب توضیح داده شده‌اند.
یک پیاده‌سازی بدون میزبان ممکن است امکانات کمتری از کتابخانه استاندارد را ارائه دهد، به شرطی که موارد زیر فراهم باشند:
پیاده‌سازی‌های بدون میزبان برای کدی طراحی شده‌اند که تنها با حداقل‌ترین پشتیبانی از سیستم‌عامل اجرا می‌شود.
بسیاری از پیاده‌سازی‌ها همچنین گزینه‌ای (غیر استاندارد) برای عدم استفاده از استثناها (exceptions) ارائه می‌دهند، برای برنامه‌های بسیار حداقلی که نزدیک به سخت‌افزار اجرا می‌شوند.

-------------------
-------------------
-------------------
-------------------

حتماً! این متن درباره دو نوع اصلی پیاده‌سازی زبان برنامه‌نویسی C++ صحبت می‌کند: **میزبان (hosted)** و **بدون میزبان (freestanding)**.

---

### ۱. پیاده‌سازی میزبان (Hosted Implementation)

* این نوع پیاده‌سازی همان حالت معمولی است که بیشتر برنامه‌های C++ روی آن اجرا می‌شوند، یعنی روی یک سیستم عامل کامل مثل ویندوز، لینوکس یا مک.
* پیاده‌سازی میزبان تمامی امکانات کتابخانه استاندارد C++ را در اختیار برنامه‌نویس می‌گذارد؛ مثل توابع استاندارد، ساختارهای داده، ورودی/خروجی و … که در مستندات استاندارد زبان مشخص شده‌اند.
* معمولاً برنامه‌های کاربردی که روی سیستم‌عامل‌های کامل اجرا می‌شوند، از این نوع پیاده‌سازی استفاده می‌کنند.

---

### ۲. پیاده‌سازی بدون میزبان (Freestanding Implementation)

* این نوع پیاده‌سازی برای محیط‌هایی است که سیستم‌عامل یا حداقل پشتیبانی از سیستم‌عامل بسیار محدود یا حتی وجود ندارد؛ مثلاً سیستم‌های تعبیه‌شده (embedded systems)، میکروکنترلرها، سیستم‌های خیلی نزدیک به سخت‌افزار و …
* در این حالت، همه امکانات کتابخانه استاندارد C++ ارائه نمی‌شود و فقط بخشی از آن که برای محیط هدف ضروری است، در دسترس است.
* استاندارد C++ حداقل امکاناتی را مشخص کرده که این نوع پیاده‌سازی باید ارائه دهد تا برنامه‌ها بتوانند روی چنین محیط‌هایی اجرا شوند.
* بسیاری از پیاده‌سازی‌های بدون میزبان گزینه‌ای غیر استاندارد دارند که می‌شود استثناها (exceptions) را غیرفعال کرد؛ چون مدیریت استثناها بار اضافی و پیچیدگی به برنامه‌های خیلی نزدیک به سخت‌افزار اضافه می‌کند که معمولاً در این محیط‌ها نمی‌خواهند یا نمی‌توانند از آن استفاده کنند.

---

### جمع‌بندی

* اگر برنامه‌ای روی سیستم عامل کامل اجرا می‌شود، معمولاً از پیاده‌سازی میزبان استفاده می‌کند که تمام امکانات استاندارد را دارد.
* اگر برنامه‌ای روی سخت‌افزار کم‌منابع یا بدون سیستم‌عامل کامل اجرا می‌شود، از پیاده‌سازی بدون میزبان استفاده می‌کند که امکانات محدودتری دارد و می‌تواند استثناها را غیرفعال کند تا سبک‌تر و نزدیک‌تر به سخت‌افزار باشد.

---


-------------------
-------------------
-------------------
-------------------

## The Basic Source Character Set
ترجمه متن:

استاندارد C++ و مثال‌های این کتاب با استفاده از مجموعه‌کاراکترهای پایه منبع نوشته شده‌اند که شامل حروف، اعداد، کاراکترهای گرافیکی و فاصله‌ها از نسخه آمریکایی مجموعه‌کاراکتر ۷ بیتی بین‌المللی ISO 646-1983 به نام ASCII (ANSI3.4-1968) می‌باشد.
این موضوع می‌تواند برای کسانی که C++ را در محیطی با مجموعه‌کاراکتر متفاوت استفاده می‌کنند، مشکل‌ساز باشد:

* ASCII شامل کاراکترهای علامت‌گذاری و نمادهای عملگر (مانند ]، { و !) است که در برخی مجموعه‌کاراکترها موجود نیستند.
* نیاز به روشی برای نمایش کاراکترهایی وجود دارد که نمایش راحتی ندارند (مانند newline یا «کاراکتری با مقدار ۱۷»).
* ASCII کاراکترهایی مانند ñ، Þ و Æ را که برای نوشتن زبان‌های غیر از انگلیسی استفاده می‌شوند، ندارد.

برای استفاده از مجموعه‌کاراکتر گسترده‌تر در کد منبع، محیط برنامه‌نویسی می‌تواند مجموعه‌کاراکتر گسترده را به مجموعه‌کاراکتر پایه منبع به چند روش نگاشت کند، مثلاً با استفاده از نام‌های کاراکتر جهانی (§6.2.3.2).

## Types
ترجمه متن:

در نظر بگیرید:

```cpp
x = y + f(2);
```

برای اینکه این عبارت در یک برنامه C++ معنا پیدا کند، نام‌های `x`، `y` و `f` باید به صورت مناسب اعلام شده باشند. یعنی، برنامه‌نویس باید مشخص کند که موجودیت‌هایی با نام‌های `x`، `y` و `f` وجود دارند و این موجودیت‌ها از نوع‌هایی هستند که عملیات‌های `=` (اختصاص مقدار)، `+` (جمع) و `()` (فراخوانی تابع) به ترتیب روی آن‌ها معنی‌دار باشد.

هر نام (شناسه) در یک برنامه C++ دارای یک نوع (type) مرتبط است. این نوع تعیین می‌کند که چه عملیاتی می‌توان روی آن نام (یعنی روی موجودیتی که نام به آن اشاره می‌کند) انجام داد و این عملیات‌ها چگونه تفسیر می‌شوند. به عنوان مثال:

```cpp
float x;    // x یک متغیر عدد اعشاری است  
int y = 7;  // y یک متغیر عدد صحیح است با مقدار اولیه ۷  
float f(int); // f تابعی است که یک عدد صحیح به عنوان ورودی می‌گیرد و یک عدد اعشاری بازمی‌گرداند  
```

این اعلان‌ها باعث می‌شوند مثال بالا معنا پیدا کند. چون `y` به عنوان `int` اعلام شده، می‌توان از آن در عملیات جمع استفاده کرد و به آن مقدار اختصاص داد. همچنین `f` به عنوان تابعی اعلام شده که یک عدد صحیح می‌گیرد، پس می‌توان آن را با ورودی عدد صحیح ۲ فراخوانی کرد.

این فصل به معرفی انواع بنیادی (§6.2.1) و اعلان‌ها (§6.3) می‌پردازد. مثال‌های این فصل صرفاً برای نشان دادن ویژگی‌های زبان هستند و هدفشان انجام کاری مفید نیست. مثال‌های بیشتر و واقع‌گرایانه‌تر در فصول بعدی ارائه می‌شوند. این فصل تنها عناصر پایه‌ای را که برنامه‌های C++ بر اساس آن‌ها ساخته می‌شوند، ارائه می‌دهد. برای تکمیل یک پروژه واقعی در C++ و به ویژه برای خواندن کد نوشته‌شده توسط دیگران، باید این عناصر به همراه اصطلاحات و سینتکس ساده مربوط به آن‌ها را بدانید.
با این حال، درک کامل همه جزئیات ذکرشده در این فصل برای فهمیدن فصول بعدی لازم نیست. بنابراین، ممکن است ترجیح دهید این فصل را به طور اجمالی مرور کنید، مفاهیم اصلی را مشاهده کنید و در صورت نیاز به جزئیات بیشتر، بعدها دوباره مراجعه کنید.

## Booleans
ترجمه متن:

نوع بولی (Boolean) که در C++ با `bool` نشان داده می‌شود، می‌تواند یکی از دو مقدار `true` یا `false` را داشته باشد. نوع بولی برای بیان نتایج عملیات‌های منطقی استفاده می‌شود. به عنوان مثال:

```cpp
void f(int a, int b)
{
    bool b1 {a == b};
    // ...
}
```

اگر مقدار `a` و `b` برابر باشد، `b1` مقدار `true` می‌گیرد؛ در غیر این صورت، مقدار آن `false` می‌شود.

استفاده رایج از نوع `bool`، به عنوان نوع خروجی تابعی است که یک شرط (پیش‌شرط) را بررسی می‌کند. به عنوان مثال:

```cpp
bool is_open(File*);
bool greater(int a, int b) { return a > b; }
```

براساس تعریف، مقدار `true` هنگام تبدیل به عدد صحیح (integer) برابر با ۱ و مقدار `false` برابر با ۰ است. بالعکس، اعداد صحیح می‌توانند به صورت ضمنی به `bool` تبدیل شوند: اعداد غیر صفر به `true` تبدیل می‌شوند و ۰ به `false`. برای مثال:

```cpp
bool b1 = 7;   // 7 نابرابر صفر است، پس b1 مقدار true می‌گیرد
bool b2 {7};   // خطا: Narrowing (تبدیل ناامن)
int i1 = true; // i1 مقدار 1 می‌شود
int i2 {true}; // i2 مقدار 1 می‌شود
```

اگر بخواهید از نگارش مقداردهی اولیه `{}` استفاده کنید تا از Narrowing جلوگیری کنید و در عین حال بخواهید یک عدد صحیح را به `bool` تبدیل کنید، می‌توانید به صورت صریح این کار را انجام دهید:

```cpp
void f(int i)
{
    bool b {i != 0};
    // ...
};
```

در عبارات حسابی و منطقی، `bool` ها به `int` تبدیل می‌شوند؛ عملیات‌های حسابی و منطقی روی مقادیر تبدیل شده انجام می‌شوند. اگر لازم باشد نتیجه دوباره به `bool` تبدیل شود، مقدار ۰ به `false` و مقدار غیر صفر به `true` تبدیل می‌شود. به عنوان مثال:

```cpp
bool a = true;
bool b = true;
bool x = a + b;   // a + b برابر 2 است، پس x مقدار true می‌گیرد
bool y = a || b;  // a || b برابر 1 است، پس y مقدار true می‌گیرد ("||" یعنی "یا")
bool z = a - b;   // a - b برابر 0 است، پس z مقدار false می‌گیرد
```

اشاره‌گرها (pointer) نیز می‌توانند به صورت ضمنی به `bool` تبدیل شوند (§10.5.2.5). اشاره‌گر غیر تهی (non-null) به `true` و اشاره‌گر `nullptr` به `false` تبدیل می‌شود. مثلاً:

```cpp
void g(int* p)
{
    bool b = p;            // تبدیل ضمنی به true یا false
    bool b2 {p != nullptr}; // تست صریح برابر نبودن با nullptr
    if (p) {               // معادل p != nullptr
        // ...
    }
}
```

من ترجیح می‌دهم از `if (p)` به جای `if (p != nullptr)` استفاده کنم، چون مستقیم‌تر مفهوم «اگر p معتبر است» را بیان می‌کند و همچنین کوتاه‌تر است. شکل کوتاه‌تر احتمال خطا را کمتر می‌کند.

--------------------
--------------------
--------------------
--------------------

---

## Narrowing Conversion چیست؟

**Narrowing conversion** در C++ به تبدیل نوع داده‌ای گفته می‌شود که ممکن است منجر به از دست رفتن اطلاعات یا تغییر ناخواسته مقدار شود.
به عبارت دیگر، وقتی داده‌ای از نوعی بزرگ‌تر یا دقیق‌تر به نوعی کوچک‌تر یا کم‌دقت‌تر تبدیل شود و احتمال افت دقت یا کاهش دامنه مقدار وجود داشته باشد، این تبدیل «narrowing» است.

---

### چرا مشکل است؟

* Narrowing باعث می‌شود مقدار تبدیل‌شده با مقدار اصلی متفاوت باشد.
* مثلاً تبدیل یک عدد اعشاری (double یا float) به عدد صحیح (int) باعث حذف بخش اعشاری می‌شود.
* یا تبدیل یک عدد بزرگ‌تر از محدوده نوع مقصد، ممکن است به مقدار نامعقول یا عدد دیگری تبدیل شود.

---

## Narrowing Conversion در C++11 و بعد از آن

C++11 مقداردهی اولیه با آکولاد `{}` را معرفی کرد که به آن **list initialization** یا **uniform initialization** گفته می‌شود.
این روش مقداردهی اولیه **نمی‌گذارد Narrowing conversions به صورت ضمنی انجام شود** و در صورت وقوع، کامپایلر خطا می‌دهد.
هدف این است که خطاهای ناشی از تبدیل‌های ناخواسته زودتر شناسایی شوند.

---

## مثال‌های Narrowing Conversion

### 1. تبدیل عدد اعشاری به صحیح (از دست رفتن بخش کسری)

```cpp
double pi = 3.14159;

int a = pi;    // درست است ولی a می‌شود 3، بخش اعشاری حذف می‌شود (narrowing)
int b{pi};     // خطا: narrowing conversion با مقداردهی اولیه با {} مجاز نیست
```

### 2. تبدیل مقدار بزرگ‌تر به نوع با محدوده کوچکتر (آندر فلو/اور فلو)

```cpp
int large = 1000;

char c = large;   // ممکن است مقدار غیرمنتظره‌ای داشته باشد چون char معمولاً 1 بایت است و نمی‌تواند همه مقادیر int را نگه دارد (narrowing)
char d{large};    // خطا: narrowing conversion با مقداردهی اولیه با {} مجاز نیست
```

### 3. تبدیل نوع صحیح بزرگ به نوع کوچک‌تر

```cpp
long long big = 5000000000;

int x = big;    // ممکن است مقدار نادرست شود چون int کوچک‌تر است
int y{big};     // خطا: narrowing conversion با مقداردهی اولیه با {}
```

### 4. تبدیل عدد صحیح غیر صفر به bool با مقداردهی اولیه با {}

```cpp
int num = 7;

bool b1 = num;  // درست است، چون غیر صفر است، b1 برابر true می‌شود
bool b2{num};   // خطا: narrowing conversion، مقداردهی اولیه با {} این تبدیل را قبول نمی‌کند
```

---

## تبدیل‌های امن که Narrowing نیستند

برخی تبدیل‌ها narrowing نیستند و در مقداردهی اولیه با `{}` مجازند:

```cpp
int i = 5;
double d1 = i;      // تبدیل صحیح به اعشاری narrowing نیست
double d2{ i };     // درست است
char c1 = 'a';
int i2 = c1;        // تبدیل char به int narrowing نیست
int i3{ c1 };       // درست است
```

---

## نکات مهم درباره Narrowing Conversion

* مقداردهی اولیه با آکولاد `{}` از Narrowing جلوگیری می‌کند و در صورت وقوع خطا می‌دهد.
* Narrowing معمولا در تبدیل‌های **float به int**، **نوع بزرگ به نوع کوچک‌تر** یا **تبدیل‌های غیرمطمئن** رخ می‌دهد.
* استفاده از مقداردهی اولیه با `{}` کمک می‌کند خطاهای مخفی تبدیل نوع سریع‌تر دیده شوند.
* برای انجام تبدیل‌های narrowing به صورت کنترل‌شده، بهتر است تبدیل صریح (`static_cast`) استفاده شود یا مقداردهی با شرط انجام شود.

---

## مثال استفاده از cast برای تبدیل ایمن

```cpp
double pi = 3.14159;

// تبدیل صریح برای جلوگیری از خطا و آگاه بودن از narrow شدن
int a = static_cast<int>(pi);  // مقدار 3 می‌گیرد ولی برنامه‌نویس آگاه است

// یا مقداردهی ایمن با {} و شرط
double val = 5.5;
int b{ (val < std::numeric_limits<int>::max()) ? static_cast<int>(val) : 0 };
```

---

### خلاصه

* **Narrowing conversion** یعنی تبدیل نوع داده‌ای که منجر به از دست دادن داده یا دقت می‌شود.
* در C++11 به بعد، مقداردهی اولیه با `{}` این تبدیل‌ها را ممنوع می‌کند و خطا می‌دهد.
* استفاده از `{}` به برنامه‌نویس کمک می‌کند از خطاهای ناخواسته تبدیل داده جلوگیری کند و برنامه قابل اطمینان‌تر شود.

---


------------------------
------------------------
------------------------
------------------------
------------------------

