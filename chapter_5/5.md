## Introduction
از دیدگاه یک کاربر نهایی، کتابخانه استاندارد ایده‌آل باید اجزایی را ارائه دهد که به‌طور مستقیم تقریباً هر نیازی را پشتیبانی کنند. برای یک حوزه کاربردی خاص، یک کتابخانه تجاری بزرگ می‌تواند به این ایده‌آل نزدیک شود. با این حال، این چیزی نیست که کتابخانه استاندارد C++ در تلاش برای انجام آن است. یک کتابخانه قابل مدیریت و در دسترس برای همگان نمی‌تواند همه چیز برای همه افراد باشد. در عوض، کتابخانه استاندارد C++ تلاش می‌کند اجزایی را ارائه دهد که برای اکثر افراد در اکثر حوزه‌های کاربردی مفید باشند. به عبارت دیگر، هدف این کتابخانه خدمت به تقاطع همه نیازها است، نه اتحاد آن‌ها. علاوه بر این، پشتیبانی از چند حوزه کاربردی بسیار مهم، مانند محاسبات ریاضی و پردازش متن، به مرور وارد این کتابخانه شده است.

## Resource Management
یکی از وظایف کلیدی هر برنامه غیرساده مدیریت منابع است. منبع چیزی است که باید دریافت شده و بعداً (به صورت صریح یا ضمنی) آزاد شود. مثال‌هایی از منابع شامل حافظه، قفل‌ها، سوکت‌ها، دستگیره‌های نخ (thread handles) و دستگیره‌های فایل هستند. در یک برنامه بلندمدت، آزاد نکردن یک منبع به‌موقع («نشت») می‌تواند باعث کاهش شدید کارایی و حتی منجر به یک خرابی ناگوار شود. حتی در برنامه‌های کوتاه‌مدت، نشت منابع می‌تواند مشکل‌ساز شود؛ مثلاً با ایجاد کمبود منابع، زمان اجرای برنامه به طرز چشمگیری افزایش یابد.

اجزای کتابخانه استاندارد به گونه‌ای طراحی شده‌اند که منابع را نشت ندهند. برای دستیابی به این هدف، آن‌ها به پشتیبانی پایه‌ای زبان برای مدیریت منابع با استفاده از جفت‌های سازنده/ویرانگر (constructor/destructor) تکیه می‌کنند تا اطمینان حاصل شود که یک منبع طول عمر بیشتری نسبت به شیء مسئول آن نداشته باشد. استفاده از جفت سازنده/ویرانگر در کلاس **Vector** برای مدیریت طول عمر عناصرش یک نمونه است (بخش §3.2.1.2) و تمامی کانتینرهای کتابخانه استاندارد به روش‌های مشابه پیاده‌سازی شده‌اند. مهم‌تر از همه، این روش به درستی با مدیریت خطا از طریق استثناها تعامل دارد. به‌عنوان مثال، این تکنیک در کلاس‌های قفل کتابخانه استاندارد استفاده می‌شود:

```cpp
mutex m; // برای محافظت از دسترسی به داده‌های مشترک
// ...
void f()
{
    unique_lock<mutex> lck {m}; // قفل mutex m را دریافت کن
    // ... دستکاری داده‌های مشترک ...
}
```

یک نخ (thread) تا زمانی که سازنده **lck** قفل **m** را دریافت نکند، پیش نخواهد رفت (بخش §5.3.4). ویرانگر متناظر این منبع را آزاد می‌کند. بنابراین، در این مثال، ویرانگر **unique_lock** قفل **mutex** را زمانی که کنترل از تابع **f()** خارج می‌شود (چه از طریق بازگشت، چه به‌صورت طبیعی با رسیدن به انتهای تابع، یا از طریق پرتاب استثنا) آزاد می‌کند.

این یک کاربرد از تکنیک «دریافت منبع به معنای مقداردهی اولیه است» (RAII؛ بخش‌های §3.2.1.2 و §13.3) است. این تکنیک پایه‌ای برای مدیریت ایدئال منابع در زبان C++ محسوب می‌شود. کانتینرها (مانند **vector** و **map**)، رشته (**string**)، و جریان‌های ورودی/خروجی (**iostream**) منابع خود (مانند دستگیره‌های فایل و بافرها) را به همین شیوه مدیریت می‌کنند.

## unique_ptr and shared_ptr
مثال‌هایی که تا کنون بررسی شدند، مدیریت اشیاء تعریف‌شده در یک دامنه (scope) و آزادسازی منابع آن‌ها هنگام خروج از دامنه را پوشش می‌دهند، اما در مورد اشیایی که در حافظه آزاد (free store) تخصیص داده می‌شوند چه باید کرد؟ در کتابخانه استاندارد و در هدر **<memory>**، دو «اشاره‌گر هوشمند» برای کمک به مدیریت اشیاء در حافظه آزاد ارائه شده است:  
1. **unique_ptr** برای نمایش مالکیت یکتا (§34.3.1)  
2. **shared_ptr** برای نمایش مالکیت اشتراکی (§34.3.2)  

استفاده اساسی از این «اشاره‌گرهای هوشمند» جلوگیری از نشت حافظه ناشی از برنامه‌نویسی بی‌دقت است. به عنوان مثال:

```cpp
void f(int i, int j) // X* در مقابل unique_ptr<X>
{
    X* p = new X; // تخصیص یک X جدید
    unique_ptr<X> sp {new X}; // تخصیص یک X جدید و واگذاری اشاره‌گر آن به unique_ptr
    // ...
    if (i<99) throw Z{}; // ممکن است یک استثنا پرتاب شود
    if (j<77) return; // ممکن است زودتر از تابع بازگردیم
    p->do_something(); // ممکن است یک استثنا پرتاب شود
    sp->do_something(); // ممکن است یک استثنا پرتاب شود
    // ...
    delete p; // نابود کردن *p
}
```

در اینجا، اگر **i < 99** یا **j < 77** باشد، فراموش کردیم که **p** را آزاد کنیم. از سوی دیگر، **unique_ptr** تضمین می‌کند که شیء مرتبط به درستی نابود می‌شود، صرف‌نظر از این که چگونه از تابع **f()** خارج می‌شویم (چه از طریق پرتاب استثنا، بازگشت یا رسیدن به انتهای تابع). جالب اینجاست که می‌توانستیم این مشکل را به سادگی با عدم استفاده از اشاره‌گر و **new** حل کنیم:

```cpp
void f(int i, int j) // استفاده از یک متغیر محلی
{
    X x;
    // ...
}
```

متأسفانه، استفاده بیش از حد از **new** (و همچنین اشاره‌گرها و مراجع) به نظر می‌رسد که یک مشکل رو به رشد است. با این حال، زمانی که واقعاً به معنای اشاره‌گرها نیاز دارید، **unique_ptr** مکانیزمی بسیار سبک با هیچ هزینه اضافی (از نظر فضا یا زمان) در مقایسه با استفاده صحیح از یک اشاره‌گر داخلی است. استفاده‌های بیشتر آن شامل انتقال اشیاء تخصیص‌داده‌شده در حافظه آزاد به داخل و خارج از توابع است:

```cpp
unique_ptr<X> make_X(int i) // ساخت یک X و انتقال فوری آن به unique_ptr
{
    // ... بررسی i و غیره ...
    return unique_ptr<X>{new X{i}};
}
```

یک **unique_ptr** مانند یک دسته برای یک شیء (یا آرایه) عمل می‌کند، همان‌طور که **vector** یک دسته برای دنباله‌ای از اشیاء است. هر دو طول عمر اشیاء دیگر را کنترل می‌کنند (با استفاده از RAII) و هر دو برای ساده و کارآمد کردن بازگشت، به مفاهیم حرکت (move semantics) متکی هستند.

**shared_ptr** مشابه **unique_ptr** است، با این تفاوت که **shared_ptr** به جای انتقال، کپی می‌شود. **shared_ptr**‌ها مالکیت یک شیء را به اشتراک می‌گذارند و آن شیء زمانی نابود می‌شود که آخرین **shared_ptr** مرتبط نابود شود. برای مثال:

```cpp
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);
void user(const string& name, ios_base::openmode mode)
{
    shared_ptr<fstream> fp {new fstream(name, mode)};
    if (!*fp) throw No_file{}; // اطمینان از باز شدن صحیح فایل
    f(fp);
    g(fp);
    // ...
}
```

در اینجا، فایلی که توسط سازنده **fp** باز شده است، توسط آخرین تابعی که نسخه‌ای از **fp** را (به صورت صریح یا ضمنی) نابود می‌کند، بسته خواهد شد. توجه کنید که **f()** یا **g()** ممکن است یک تسک ایجاد کنند که نسخه‌ای از **fp** را نگه دارد یا به نحوی دیگر کپی‌ای را ذخیره کند که طول عمر بیشتری نسبت به **user()** داشته باشد. بنابراین، **shared_ptr** نوعی از جمع‌آوری زباله (garbage collection) ارائه می‌دهد که به مدیریت منابع مبتنی بر ویرانگر احترام می‌گذارد. این روش نه رایگان است و نه بیش از حد گران، اما طول عمر شیء مشترک را پیش‌بینی‌ناپذیر می‌کند. از **shared_ptr** فقط زمانی استفاده کنید که واقعاً به مالکیت مشترک نیاز دارید.

با داشتن **unique_ptr** و **shared_ptr**، می‌توانیم یک سیاست کامل «عدم استفاده از **new** مستقیم» (§3.2.1.2) را برای بسیاری از برنامه‌ها اعمال کنیم. با این حال، این «اشاره‌گرهای هوشمند» هنوز هم به صورت مفهومی اشاره‌گر هستند و بنابراین تنها گزینه دوم من برای مدیریت منابع به شمار می‌روند – پس از کانتینرها و انواع دیگری که منابع را در یک سطح مفهومی بالاتر مدیریت می‌کنند. به طور خاص، **shared_ptr** به تنهایی هیچ قانونی برای تعیین اینکه کدام مالکین می‌توانند شیء مشترک را بخوانند و/یا بنویسند ارائه نمی‌دهد. رقابت داده‌ها (§41.2.4) و دیگر اشکال سردرگمی فقط با حذف مشکلات مدیریت منابع حل نمی‌شوند.

کجا باید از «اشاره‌گرهای هوشمند» (مانند **unique_ptr**) به جای دسته‌های منابع با عملیات طراحی‌شده مخصوص برای منبع (مانند **vector** یا **thread**) استفاده کنیم؟ جای تعجب نیست که پاسخ این است: «وقتی به معنای اشاره‌گر نیاز داریم.»  
- وقتی شیء را به اشتراک می‌گذاریم، برای اشاره به آن به اشاره‌گر (یا مرجع) نیاز داریم، بنابراین **shared_ptr** انتخاب واضحی است (مگر اینکه یک مالک واضح وجود داشته باشد).  
- وقتی به یک شیء چندشکلی (polymorphic) اشاره می‌کنیم، نیاز به یک اشاره‌گر (یا مرجع) داریم، زیرا نوع دقیق شیء مورد اشاره یا حتی اندازه آن را نمی‌دانیم. بنابراین **unique_ptr** انتخاب واضحی است.  
- یک شیء چندشکلی مشترک معمولاً به **shared_ptr** نیاز دارد.  

ما نیازی به استفاده از اشاره‌گر برای بازگرداندن یک مجموعه از اشیاء از یک تابع نداریم؛ یک کانتینر که دسته‌ای برای منابع است این کار را به سادگی و به طور کارآمد انجام می‌دهد (§3.3.2).

## Concurrency
هم‌روندی (Concurrency) – اجرای همزمان چندین وظیفه – به طور گسترده برای **افزایش توان عملیاتی** (با استفاده از چندین پردازنده برای یک محاسبه) یا **بهبود پاسخ‌دهی** (با اجازه دادن به یک بخش از برنامه برای پیشرفت در حالی که بخش دیگر منتظر پاسخ است) استفاده می‌شود. تمام زبان‌های برنامه‌نویسی مدرن از این قابلیت پشتیبانی می‌کنند. پشتیبانی ارائه شده توسط کتابخانه استاندارد ++C، یک نسخه قابل حمل (portable) و نوع-ایمن (type-safe) از چیزی است که برای بیش از 20 سال در ++C استفاده شده و تقریباً توسط تمام سخت‌افزارهای مدرن پشتیبانی می‌شود. 

پشتیبانی کتابخانه استاندارد، عمدتاً با هدف پشتیبانی از هم‌روندی در سطح سیستم ارائه شده است، نه برای ارائه مستقیم مدل‌های پیشرفته‌تر هم‌روندی؛ چنین مدل‌های پیشرفته‌ای می‌توانند به صورت کتابخانه‌هایی ساخته شوند که از امکانات کتابخانه استاندارد استفاده می‌کنند.

کتابخانه استاندارد به طور مستقیم از اجرای هم‌زمان چندین نخ (threads) در یک فضای آدرس پشتیبانی می‌کند. برای این منظور، ++C یک **مدل حافظه مناسب** (§41.2) و مجموعه‌ای از **عملیات اتمی** (§41.3) فراهم می‌کند. با این حال، اکثر کاربران هم‌روندی را تنها از طریق کتابخانه استاندارد و کتابخانه‌هایی که بر پایه آن ساخته شده‌اند مشاهده می‌کنند. 

این بخش به طور خلاصه مثال‌هایی از امکانات اصلی پشتیبانی هم‌روندی در کتابخانه استاندارد ارائه می‌دهد: **نخ‌ها (threads)**، **قفل‌ها (mutexes)**، **عملیات lock()**، **وظایف بسته‌بندی‌شده (packaged_tasks)** و **آینده‌ها (futures)**. این ویژگی‌ها به طور مستقیم بر اساس امکانات ارائه‌شده توسط سیستم‌عامل‌ها ساخته شده‌اند و **هیچگونه کاهش کارایی** نسبت به امکانات سیستم‌عامل ندارند.

## Tasks and threads
ما به محاسباتی که می‌توانند به طور همزمان با سایر محاسبات اجرا شوند، **وظیفه (task)** می‌گوییم. یک **نخ (thread)** نمایشی در سطح سیستم از یک وظیفه در یک برنامه است. برای اجرای یک وظیفه به صورت همزمان با سایر وظایف، باید با ساختن یک `std::thread` (از کتابخانه `<thread>`) وظیفه موردنظر را به عنوان آرگومان به آن منتقل کنیم. یک وظیفه می‌تواند یک تابع یا یک شیء تابع (function object) باشد:

```cpp
void f(); // تابع
struct F { // شیء تابع
    void operator()(); // عملگر () برای F
};
```

### مثال:
در این مثال، دو نخ ایجاد می‌شوند که هر یک وظیفه‌ای را به صورت همزمان اجرا می‌کنند:

```cpp
void user() {
    thread t1 {f}; // اجرای f() در یک نخ جداگانه
    thread t2 {F()}; // اجرای F()() در یک نخ جداگانه
    t1.join(); // منتظر پایان t1
    t2.join(); // منتظر پایان t2
}
```

متد `join()` تضمین می‌کند که از تابع `user()` خارج نشویم تا زمانی که نخ‌ها کارشان را به پایان برسانند. مفهوم "join" یعنی "منتظر ماندن برای پایان نخ".

---

### تفاوت نخ‌ها با فرآیندها:
- نخ‌های یک برنامه **یک فضای آدرس مشترک** دارند. 
- برخلاف نخ‌ها، فرآیندها معمولاً داده‌ها را به طور مستقیم با یکدیگر به اشتراک نمی‌گذارند.
- به دلیل اشتراک فضای آدرس، نخ‌ها می‌توانند از طریق **اشیای مشترک** با یکدیگر ارتباط برقرار کنند. این ارتباط معمولاً توسط **قفل‌ها (locks)** یا سایر مکانیزم‌ها کنترل می‌شود تا از **data race** (دسترسی همزمان و کنترل‌نشده به یک متغیر) جلوگیری شود.

---

### مشکل در هم‌زمانی و مثال خطا:
نوشتن برنامه‌های هم‌زمان ممکن است بسیار دشوار باشد. به عنوان مثال، وظایف زیر تعریف شده‌اند:

```cpp
void f() { cout << "Hello "; }
struct F {
    void operator()() { cout << "Parallel World!\n"; }
};
```

اگر دو نخ به طور همزمان این وظایف را اجرا کنند:

```cpp
thread t1 {f};
thread t2 {F()};
t1.join();
t2.join();
```

این کد یک **خطای بد** است. هر دو وظیفه از شیء `cout` به طور همزمان استفاده می‌کنند، اما **بدون هیچ‌گونه هم‌زمان‌سازی (synchronization)**. 

خروجی حاصل می‌تواند غیرقابل پیش‌بینی باشد و در اجرای‌های مختلف برنامه متفاوت باشد. برای مثال، ممکن است خروجی زیر تولید شود:

```
PaHerallllel o World!
```

---

### راه‌حل و نکته مهم:
برای تعریف وظایف در یک برنامه هم‌زمان، هدف این است که:
1. **وظایف را کاملاً جدا از هم نگه داریم**، مگر در جاهایی که ارتباطات ساده و واضح بین آن‌ها وجود دارد.
2. **وظایف را به صورت ایزوله تعریف کنیم**: یعنی داده‌های مشترک نباید بدون کنترل استفاده شوند.

ساده‌ترین راه برای فکر کردن به یک وظیفه هم‌زمان، این است که به آن به چشم یک تابع نگاه کنیم که به طور همزمان با فراخواننده خود اجرا می‌شود. برای این کار باید:
- آرگومان‌ها را منتقل کنیم،
- نتیجه را دریافت کنیم،
- و اطمینان حاصل کنیم که داده‌های مشترک به صورت ناامن استفاده نمی‌شوند (یعنی **data race** وجود نداشته باشد).

## Passing Arguments
معمولاً، یک وظیفه (task) برای اجرا نیاز به داده‌ای دارد که روی آن کار کند. ما می‌توانیم داده‌ها (یا اشاره‌گرها و مراجع به داده‌ها) را به‌راحتی به‌عنوان آرگومان ارسال کنیم. به‌عنوان‌مثال:

```cpp
void f(vector<double>& v); // تابعی که کاری را بر روی v انجام می‌دهد

struct F { // شیء تابعی که کاری را بر روی v انجام می‌دهد
    vector<double>& v;
    F(vector<double>& vv) : v{vv} { }
    void operator()(); // عملگر کاربردی (application operator)
};

int main()
{
    vector<double> some_vec {1,2,3,4,5,6,7,8,9};
    vector<double> vec2 {10,11,12,13,14};

    thread t1 {f, some_vec}; // اجرای f(some_vec) در یک رشته (thread) جداگانه
    thread t2 {F{vec2}}; // اجرای F(vec2)() در یک رشته جداگانه

    t1.join();
    t2.join();
}
```

واضح است که `F{vec2}` یک **مرجع** به بردار `vec2` را در کلاس `F` ذخیره می‌کند. اکنون `F` می‌تواند از این بردار استفاده کند، به این امید که هیچ وظیفه‌ی دیگری در حین اجرای `F` به `vec2` دسترسی نداشته باشد. اگر `vec2` را **با مقدار** (by value) ارسال کنیم، این ریسک از بین می‌رود.

**مقداردهی اولیه با `{f, some_vec}` از یک سازنده‌ی تابع متغیر (variadic template constructor) در کلاس `thread` استفاده می‌کند که می‌تواند یک توالی دلخواه از آرگومان‌ها را بپذیرد.** کامپایلر بررسی می‌کند که آیا آرگومان اول می‌تواند با آرگومان‌های بعدی فراخوانی شود یا خیر و در صورت امکان، شیء تابعی موردنیاز را برای ارسال به `thread` می‌سازد.

بنابراین، اگر `F::operator()()` و `f()` **الگوریتم یکسانی را اجرا کنند**، نحوه‌ی پردازش این دو وظیفه تقریباً معادل خواهد بود: در هر دو مورد، یک شیء تابعی (function object) برای اجرای درون **رشته (thread)** ساخته می‌شود.

---

### **توضیح برنامه و مفهوم آن**

این کد **موازی‌سازی (multithreading)** در C++ را نشان می‌دهد. در اینجا، دو روش برای اجرای یک تابع در یک **رشته (thread) جداگانه** ارائه شده است:

1. **ارسال یک تابع معمولی (`f`) به یک رشته (thread)**
2. **ارسال یک شیء تابعی (`F`) به یک رشته (thread)**

---

### **۱. ارسال یک تابع معمولی به یک رشته (`thread t1 {f, some_vec};`)**
در این خط:
```cpp
thread t1 {f, some_vec}; 
```
- `t1` یک **رشته جدید** ایجاد می‌کند که در آن تابع `f` اجرا خواهد شد.
- `some_vec` به‌عنوان آرگومان به تابع `f` ارسال می‌شود.
- `f` باید یک تابع تعریف‌شده باشد که ورودی آن یک مرجع به `vector<double>` است:

    ```cpp
    void f(vector<double>& v);
    ```

- مقداردهی `{f, some_vec}` از **یک سازنده تابع متغیر (variadic template constructor)** در کلاس `thread` استفاده می‌کند. 
- کامپایلر بررسی می‌کند که آیا `f` را می‌توان با `some_vec` فراخوانی کرد، سپس شیء تابعی موردنیاز را برای اجرا درون `thread` می‌سازد.

---

### **۲. ارسال یک شیء تابعی (`F`) به یک رشته (`thread t2 {F{vec2}};`)**
در این قسمت:
```cpp
thread t2 {F{vec2}}; 
```
- `F` یک **ساختار (struct)** است که شامل یک **مرجع (`vector<double>& v`)** به `vec2` می‌باشد.
- `F` یک **عملگر تابعی (`operator()`)** دارد که امکان اجرای آن به‌عنوان یک تابع را می‌دهد.
- در اینجا، `F{vec2}` یک شیء از `F` ایجاد می‌کند که مرجعی به `vec2` نگه می‌دارد.
- این شیء، سپس به `thread` ارسال می‌شود که باعث اجرای `F::operator()()` در یک رشته جدید می‌شود.

---

### **چرا `vec2` را با مرجع (`&`) ارسال می‌کنیم؟**
- در ساختار `F`، `vec2` **با مرجع (`vector<double>& v`) ذخیره می‌شود**.
- یعنی هر تغییری که در `F` روی `v` انجام شود، روی `vec2` اصلی اعمال خواهد شد.
- **مشکل این روش:** اگر هم‌زمان وظیفه دیگری روی `vec2` اجرا شود، احتمال بروز **شرایط رقابتی (race condition)** وجود دارد.
- **راه‌حل:** اگر `vec2` را **با مقدار (`by value`)** ارسال کنیم، کپی جدیدی از `vec2` ایجاد شده و مشکلی در هم‌زمانی پیش نمی‌آید.

---

### **اجرای هم‌زمان و هماهنگی (`join`)**
```cpp
t1.join();
t2.join();
```
- `join()` باعث می‌شود که `main()` تا زمان پایان `t1` و `t2` منتظر بماند.
- بدون `join()`، `main()` ممکن است قبل از اتمام `t1` و `t2` اجرا را تمام کند و برنامه از بین برود.

---

### **مقایسه دو روش (`f` و `F::operator()`)**
- هر دو روش به `thread` یک **تابع برای اجرا** می‌دهند.
- در روش `F`, یک شیء تابعی (`function object`) ساخته شده و اجرا می‌شود.
- در روش `f`, از یک **تابع عادی** استفاده شده است.
- عملکرد نهایی هر دو تقریباً یکسان است.

---

### **جمع‌بندی**
✅ **نحوه ارسال داده به thread:**
- **با مقدار (by value):** ایمن‌تر، اما کندتر (چون نیاز به کپی دارد).
- **با مرجع (by reference):** سریع‌تر، اما نیازمند هماهنگی برای جلوگیری از شرایط رقابتی.

✅ **نحوه ارسال تابع به thread:**
- **تابع عادی (`f`)** مستقیماً ارسال می‌شود.
- **شیء تابعی (`F`)** از `operator()` برای اجرا استفاده می‌کند.

✅ **هدف کلی:** اجرای موازی کد و پردازش هم‌زمان داده‌ها برای بهبود کارایی.

---
**نتیجه:**  
این مثال نشان می‌دهد که چطور می‌توان از **رشته‌ها (`threads`)** برای اجرای هم‌زمان توابع یا اشیاء تابعی در C++ استفاده کرد و تفاوت بین ارسال داده با مقدار و با مرجع را بررسی کرد. 🚀

---

## Returning Results
در مثال ارائه‌شده در **§5.3.2**، آرگومان‌ها را با **مرجع غیر `const`** ارسال می‌کنم. من فقط زمانی این کار را انجام می‌دهم که انتظار داشته باشم **وظیفه (task) مقدار داده‌ای که به آن ارجاع داده شده را تغییر دهد** (§7.7). این یک روش **کمی زیرکانه، اما رایج** برای بازگرداندن نتیجه است.

یک تکنیک **کمتر مبهم** این است که **داده‌های ورودی را با مرجع `const` ارسال کنیم** و **محل ذخیره نتیجه را به‌عنوان یک آرگومان جداگانه ارسال کنیم**:

```cpp
void f(const vector<double>& v, double* res); // دریافت ورودی از v و ذخیره نتیجه در *res

class F {
public:
    F(const vector<double>& vv, double* p) : v{vv}, res{p} { }
    void operator()(); // ذخیره نتیجه در *res

private:
    const vector<double>& v; // منبع ورودی
    double* res; // مقصد خروجی
};

int main()
{
    vector<double> some_vec;
    vector<double> vec2;
    // ...
    double res1;
    double res2;

    thread t1 {f, some_vec, &res1}; // اجرای f(some_vec, &res1) در یک رشته (thread) جداگانه
    thread t2 {F{vec2, &res2}}; // اجرای F{vec2, &res2}() در یک رشته جداگانه

    t1.join();
    t2.join();

    cout << res1 << ' ' << res2 << '\n';
}
```

من ارسال نتیجه **از طریق آرگومان‌ها** را **روش چندان ظریفی نمی‌دانم**، بنابراین در **§5.3.5.1** دوباره به این موضوع بازخواهم گشت.

## Sharing Data
گاهی اوقات، وظایف نیاز دارند داده‌ها را به اشتراک بگذارند. در چنین شرایطی، دسترسی باید همگام‌سازی شود تا در هر لحظه حداکثر یک وظیفه بتواند به داده‌ها دسترسی داشته باشد. برنامه‌نویسان باتجربه این را به‌عنوان یک ساده‌سازی تشخیص خواهند داد (مثلاً مشکلی در خواندن هم‌زمان داده‌های تغییرناپذیر توسط چندین وظیفه وجود ندارد)، اما باید در نظر گرفت که چگونه می‌توان اطمینان حاصل کرد که در هر لحظه حداکثر یک وظیفه به یک مجموعه داده مشخص دسترسی داشته باشد.  

عنصر اساسی این راه‌حل، یک **موتکس** (mutex) یا **شیء حذف متقابل** است. یک رشته (thread) با استفاده از عملیات `lock()` یک موتکس را به دست می‌آورد:  

```cpp
mutex m; // موتکس کنترل‌کننده
int sh; // داده‌ی مشترک

void f()
{
    unique_lock<mutex> lck {m}; // گرفتن موتکس
    sh += 7; // دستکاری داده‌ی مشترک
} // آزادسازی موتکس به‌صورت ضمنی
```

سازنده‌ی `unique_lock`، موتکس را از طریق فراخوانی `m.lock()` به دست می‌آورد. اگر یک رشته‌ی دیگر قبلاً این موتکس را گرفته باشد، رشته‌ی جدید منتظر می‌ماند (مسدود می‌شود) تا رشته‌ی دیگر دسترسی خود را تکمیل کند. زمانی که یک رشته دسترسی خود به داده‌های مشترک را تکمیل کرد، `unique_lock` موتکس را آزاد می‌کند (با یک فراخوانی `m.unlock()`). امکانات حذف متقابل و قفل کردن در کتابخانه‌ی `<mutex>` استاندارد C++ قرار دارند.  

ارتباط بین داده‌های مشترک و یک موتکس مبتنی بر قرارداد است: برنامه‌نویس باید بداند که کدام موتکس مربوط به کدام داده است. واضح است که این روش مستعد خطاست، و از طرفی نیز می‌توانیم با استفاده از روش‌های مختلف زبان، این ارتباط را شفاف‌تر کنیم. به‌عنوان مثال:  

```cpp
class Record {
public:
    mutex rm;
    // ...
};
```

بدیهی است که اگر نمونه‌ای از `Record` با نام `rec` داشته باشیم، `rec.rm` یک موتکس است که باید قبل از دسترسی به داده‌های دیگر این کلاس، آن را به دست آوریم، هرچند یک توضیح یا نام بهتر می‌تواند به خواننده کمک بیشتری کند.  

گاهی اوقات نیاز است که چندین منبع را به‌صورت هم‌زمان برای انجام یک عملیات در اختیار بگیریم. این وضعیت می‌تواند منجر به **بن‌بست (deadlock)** شود. برای مثال، اگر `thread1` ابتدا `mutex1` را گرفته و سپس تلاش کند `mutex2` را بگیرد، درحالی‌که `thread2` ابتدا `mutex2` را گرفته و سپس سعی کند `mutex1` را بگیرد، هیچ‌کدام از این دو وظیفه هرگز پیش نخواهند رفت.  

کتابخانه‌ی استاندارد C++ یک راهکار برای جلوگیری از این مشکل ارائه می‌دهد که امکان گرفتن چندین قفل را به‌صورت هم‌زمان فراهم می‌کند:  

```cpp
void f()
{
    // ...
    unique_lock<mutex> lck1 {m1,defer_lock}; // defer_lock: هنوز قفل را دریافت نکن
    unique_lock<mutex> lck2 {m2,defer_lock};
    unique_lock<mutex> lck3 {m3,defer_lock};
    // ...
    lock(lck1,lck2,lck3); // گرفتن هم‌زمان همه‌ی قفل‌ها
    // ... دستکاری داده‌های مشترک ...
} // آزادسازی ضمنی همه‌ی موتکس‌ها
```

تابع `lock()` تنها زمانی اجرا می‌شود که بتواند تمام موتکس‌های ورودی را به‌طور هم‌زمان دریافت کند و هرگز زمانی که یک موتکس در حال حاضر گرفته شده باشد، مسدود نمی‌شود. همچنین، **سازنده‌های تخریب‌کننده** (destructors) برای `unique_lock`های جداگانه تضمین می‌کنند که موتکس‌ها هنگام خروج از حوزه‌ی عملکرد، آزاد شوند.  

**ارتباط از طریق داده‌های مشترک، یک سطح پایین از ارتباطات است.** به‌ویژه، برنامه‌نویس باید روش‌هایی برای تعیین اینکه کدام کار انجام شده و کدام کار هنوز انجام نشده است، طراحی کند. از این نظر، استفاده از داده‌های مشترک در مقایسه با مفهوم **فراخوانی و بازگشت تابع** کمتر کارآمد است. از سوی دیگر، برخی معتقدند که اشتراک‌گذاری داده‌ها باید کارآمدتر از کپی کردن آرگومان‌ها و مقادیر بازگشتی باشد. این موضوع **در مورد داده‌های حجیم می‌تواند درست باشد**، اما **عملیات قفل کردن و باز کردن قفل نسبتاً پرهزینه هستند**. از سوی دیگر، ماشین‌های مدرن **در کپی کردن داده‌ها، به‌ویژه داده‌های فشرده مانند عناصر یک بردار (vector)، بسیار سریع هستند**. بنابراین، **از داده‌های مشترک به‌خاطر "کارایی" بدون تفکر و اندازه‌گیری دقیق استفاده نکنید**.

### **توضیح متن درباره‌ی همگام‌سازی دسترسی به داده‌های مشترک در برنامه‌های چندنخی (Multi-threading)**

در برنامه‌های چندنخی، زمانی که چندین **وظیفه (task)** یا **رشته (thread)** به‌طور هم‌زمان اجرا می‌شوند، ممکن است نیاز داشته باشند که به یک مجموعه داده مشترک دسترسی پیدا کنند. این مسئله می‌تواند مشکلاتی ایجاد کند، زیرا اگر چندین رشته هم‌زمان بخواهند داده‌ی مشترک را تغییر دهند، ممکن است داده‌ها خراب شده یا نتایج نامعتبر تولید شوند.

#### **🔹 راه‌حل: استفاده از Mutex (حذف متقابل)**
برای جلوگیری از این مشکل، از **موتکس (Mutex - Mutual Exclusion Object)** استفاده می‌شود. موتکس یک **قفل (lock)** است که در هر لحظه فقط یک رشته می‌تواند آن را دریافت کند و به داده‌های محافظت‌شده دسترسی داشته باشد. سایر رشته‌ها باید منتظر بمانند تا این قفل آزاد شود.

🔸 **مثال اولیه‌ی استفاده از Mutex در C++:**
```cpp
mutex m;  // موتکس کنترل‌کننده
int sh;   // داده‌ی مشترک

void f() {
    unique_lock<mutex> lck {m}; // گرفتن قفل
    sh += 7; // تغییر در داده‌ی مشترک
} // قفل به‌صورت خودکار در پایان تابع آزاد می‌شود
```
در این مثال:
- `unique_lock<mutex>` مسئول مدیریت قفل است.
- وقتی یک `unique_lock` ساخته می‌شود، به‌صورت خودکار `m.lock()` را اجرا می‌کند.
- زمانی که تابع تمام می‌شود، `unique_lock` به‌طور خودکار `m.unlock()` را اجرا کرده و قفل را آزاد می‌کند.

#### **🔹 مشکل ارتباط بین داده‌ها و Mutex**
موتکس‌ها به یک مجموعه داده اختصاص دارند، اما **برنامه‌نویس باید بداند که کدام موتکس برای کدام داده است**. اگر این ارتباط به‌درستی تعریف نشود، ممکن است برنامه دچار **خطاهای همگام‌سازی (Synchronization Errors)** شود.

🔸 **روش بهتر: تعریف Mutex در داخل کلاس‌ها**
برای روشن‌تر کردن این ارتباط، می‌توان موتکس را در کنار داده‌ها در کلاس‌ها تعریف کرد:
```cpp
class Record {
public:
    mutex rm;
    // سایر داده‌های کلاس...
};
```
در اینجا، اگر نمونه‌ای از `Record` با نام `rec` داشته باشیم، به‌طور طبیعی `rec.rm` یک موتکس است که باید قبل از دسترسی به داده‌های دیگر این کلاس، آن را دریافت کنیم.

---

### **🔹 مشکل بن‌بست (Deadlock)**
در برخی مواقع، ممکن است یک رشته **قفل یک موتکس را دریافت کند و منتظر بماند تا قفل دیگری را بگیرد، در حالی که یک رشته‌ی دیگر قفل دوم را گرفته و منتظر قفل اولی است**. در این حالت، هیچ‌کدام از رشته‌ها نمی‌توانند ادامه دهند و برنامه **در بن‌بست گیر می‌کند**.

🔸 **مثال از ایجاد بن‌بست:**
- `thread1` ابتدا `mutex1` را می‌گیرد و سپس سعی می‌کند `mutex2` را بگیرد.
- `thread2` ابتدا `mutex2` را می‌گیرد و سپس سعی می‌کند `mutex1` را بگیرد.
- هیچ‌کدام از این دو رشته نمی‌توانند ادامه دهند، چون هرکدام منتظر دیگری است.

✅ **راه‌حل: استفاده از `lock()` برای دریافت چندین قفل به‌صورت هم‌زمان**
```cpp
void f() {
    unique_lock<mutex> lck1 {m1, defer_lock}; // قفل هنوز گرفته نشده
    unique_lock<mutex> lck2 {m2, defer_lock};
    unique_lock<mutex> lck3 {m3, defer_lock};

    lock(lck1, lck2, lck3); // همه‌ی قفل‌ها را به‌صورت هم‌زمان بگیر
    // تغییر داده‌های مشترک...
} // قفل‌ها به‌صورت خودکار آزاد می‌شوند
```
در این روش:
- از `defer_lock` استفاده می‌شود تا قفل‌ها فوراً گرفته نشوند.
- سپس تابع `lock()` هم‌زمان همه‌ی قفل‌ها را دریافت می‌کند.
- این روش **هیچ‌گاه در حالت انتظار یک قفل را نگه نمی‌دارد و منتظر قفل دیگر نمی‌ماند**، بنابراین **احتمال بن‌بست کاهش می‌یابد**.

---

### **🔹 آیا اشتراک‌گذاری داده سریع‌تر از کپی کردن آن است؟**
برخی از برنامه‌نویسان تصور می‌کنند که **استفاده از داده‌های مشترک، سریع‌تر از کپی کردن داده‌ها بین رشته‌ها است**. اما این همیشه درست نیست!

- **اگر داده‌های بزرگی مانند آرایه‌ها یا فایل‌های حجیم وجود داشته باشد، اشتراک‌گذاری آن‌ها می‌تواند کارآمدتر از کپی کردن باشد.**
- **اما عملیات قفل کردن (`lock()`) و آزادسازی قفل (`unlock()`) زمان‌بر هستند.**
- **پردازنده‌های مدرن در کپی کردن داده‌های کوچک بسیار سریع هستند، مخصوصاً وقتی داده‌ها فشرده و در حافظه نزدیک هم باشند (مثل عناصر یک `vector`).**

✅ **پس نباید از داده‌های مشترک فقط به دلیل "بهینه بودن" استفاده کرد، بلکه باید کارایی را اندازه‌گیری کرد و تصمیم منطقی گرفت.**

---

### **📌 خلاصه‌ی نکات مهم**
1. **وقتی چندین رشته به یک داده‌ی مشترک دسترسی دارند، باید از `mutex` برای کنترل همگام‌سازی استفاده کنیم.**
2. **استفاده از `unique_lock<mutex>` باعث می‌شود که قفل‌ها به‌صورت خودکار مدیریت شوند.**
3. **اگر چندین موتکس نیاز است، استفاده از `lock()` برای گرفتن هم‌زمان آن‌ها مانع از بروز بن‌بست می‌شود.**
4. **انتخاب بین اشتراک‌گذاری داده‌ها و کپی کردن آن‌ها بستگی به اندازه‌ی داده و هزینه‌ی عملیات قفل کردن دارد.**

✅ **در کل، مدیریت صحیح همگام‌سازی در برنامه‌های چندنخی بسیار مهم است، زیرا اشتباهات در این بخش می‌توانند باعث خرابی داده‌ها، کند شدن برنامه، یا حتی توقف اجرای آن شوند.**

## Waiting for Events
گاهی اوقات، یک رشته (Thread) نیاز دارد که منتظر یک رویداد خارجی بماند، مانند اتمام کار یک رشته دیگر یا سپری شدن مقدار مشخصی از زمان. ساده‌ترین «رویداد» در اینجا، گذر زمان است.

در نظر بگیرید:

```cpp
using namespace std::chrono; // مراجعه کنید به §35.2
auto t0 = high_resolution_clock::now();
this_thread::sleep_for(milliseconds{20});
auto t1 = high_resolution_clock::now();
cout << duration_cast<nanoseconds>(t1−t0).count() << " nanoseconds passed\n";
```

توجه داشته باشید که حتی نیازی به راه‌اندازی یک رشته جدید هم نداشتم؛ به‌طور پیش‌فرض، `this_thread` به همان یک و تنها رشته اشاره می‌کند (§42.2.6).  
از `duration_cast` برای تنظیم واحدهای زمان ساعت به نانوثانیه‌هایی که می‌خواستم، استفاده کردم. قبل از انجام هر کار پیچیده‌ای با زمان، به بخش‌های §5.4.1 و §35.2 مراجعه کنید. قابلیت‌های مربوط به زمان در هدر `<chrono>` یافت می‌شوند.

پشتیبانی پایه برای ارتباط از طریق رویدادهای خارجی توسط `condition_variable` فراهم شده است که در هدر `<condition_variable>` یافت می‌شود (§42.3.4).  
یک `condition_variable` مکانیزمی است که به یک رشته اجازه می‌دهد منتظر یک رشته دیگر بماند. به‌طور خاص، این امکان را می‌دهد که یک رشته منتظر بماند تا یک شرایط مشخص (که اغلب به آن رویداد گفته می‌شود) در نتیجه کاری که توسط رشته‌های دیگر انجام شده، رخ دهد.

مثال کلاسیک در این زمینه ارتباط بین دو رشته از طریق صف پیام‌ها است. برای سادگی، صف و مکانیزم جلوگیری از شرایط رقابتی (Race Condition) را به‌صورت سراسری برای تولیدکننده و مصرف‌کننده تعریف می‌کنم:

```cpp
class Message { // شیء مورد نظر برای ارسال
    // ...
};

queue<Message> mqueue; // صف پیام‌ها
condition_variable mcond; // متغیری برای ارتباط رویدادها
mutex mmutex; // مکانیزم قفل‌گذاری
```

نوع‌های `queue`، `condition_variable` و `mutex` توسط کتابخانه استاندارد فراهم شده‌اند.

**مصرف‌کننده (Consumer)** پیام‌ها را خوانده و پردازش می‌کند:

```cpp
void consumer()
{
    while(true) {
        unique_lock<mutex> lck{mmutex}; // دریافت قفل mmutex
        while (mcond.wait(lck)) /* هیچ کاری انجام نده */; // آزادسازی قفل و انتظار
        // پس از بیدار شدن، قفل مجدداً دریافت می‌شود

        auto m = mqueue.front(); // دریافت پیام
        mqueue.pop();
        lck.unlock(); // آزادسازی قفل

        // ... پردازش پیام m ...
    }
}
```

در اینجا، به‌طور صریح عملیات روی صف و `condition_variable` را با `unique_lock` روی `mutex` محافظت می‌کنیم.  
متد `wait` در `condition_variable`، هنگام انتظار، قفل داده‌شده را آزاد می‌کند (به‌طوری که دیگر رشته‌ها بتوانند صف را تغییر دهند) و پس از اتمام انتظار، مجدداً قفل را دریافت می‌کند.

**تولیدکننده (Producer)** به این صورت خواهد بود:

```cpp
void producer()
{
    while(true) {
        Message m;
        // ... پر کردن پیام ...

        unique_lock<mutex> lck {mmutex}; // محافظت از عملیات
        mqueue.push(m);
        mcond.notify_one(); // ارسال اعلان
    } // آزادسازی قفل در انتهای دامنه
}
```

استفاده از `condition_variable` روش‌های متنوع و کارآمدی را برای اشتراک‌گذاری اطلاعات فراهم می‌کند، اما می‌تواند کمی پیچیده باشد (§42.3.4).

---

### **توضیح کامل و دقیق درباره‌ی کد و مفاهیم مربوطه**

---

## **۱. مفهوم انتظار در برنامه‌های چندنخی (Multithreading)**
در برنامه‌نویسی چندنخی، ممکن است یک **رشته (Thread)** نیاز داشته باشد که برای وقوع یک رویداد خارجی منتظر بماند. این رویداد می‌تواند مواردی مانند:
- اتمام کار یک رشته‌ی دیگر
- سپری شدن یک بازه‌ی زمانی مشخص
- دریافت داده از ورودی
- دریافت یک سیگنال از یک پردازش دیگر

باشد. برای مدیریت این نوع سناریوها، **انتظار فعال (Busy Waiting)** گزینه‌ی خوبی نیست، زیرا باعث مصرف بیهوده‌ی پردازنده می‌شود. بنابراین، مکانیزم‌هایی برای **مدیریت بهینه‌ی انتظار** ارائه شده‌اند.

---

## **۲. منتظر ماندن برای گذر زمان با `sleep_for`**
در کد ارائه‌شده، اولین مثال مربوط به **انتظار برای گذر زمان** است. 

```cpp
using namespace std::chrono; // استفاده از قابلیت‌های زمان در C++ 
auto t0 = high_resolution_clock::now(); // ذخیره‌ی زمان فعلی
this_thread::sleep_for(milliseconds{20}); // متوقف کردن رشته برای ۲۰ میلی‌ثانیه
auto t1 = high_resolution_clock::now(); // ذخیره‌ی زمان پس از توقف
cout << duration_cast<nanoseconds>(t1−t0).count() << " nanoseconds passed\n";
```

### **تحلیل کد:**
1. `high_resolution_clock::now()` زمان فعلی را با بالاترین دقت ممکن ذخیره می‌کند.
2. `this_thread::sleep_for(milliseconds{20})` رشته‌ی فعلی را برای **۲۰ میلی‌ثانیه** متوقف می‌کند.
3. `high_resolution_clock::now()` دوباره زمان را پس از توقف ذخیره می‌کند.
4. `duration_cast<nanoseconds>` اختلاف زمان قبل و بعد را به **نانوثانیه** تبدیل کرده و چاپ می‌کند.

### **چرا از `this_thread::sleep_for` استفاده می‌کنیم؟**
- این تابع باعث می‌شود رشته فعلی برای مدت زمان مشخصی به حالت **انتظار غیرفعال (Passive Waiting)** برود، که باعث کاهش مصرف پردازنده می‌شود.

---

## **۳. همگام‌سازی (Synchronization) و ارتباط بین رشته‌ها با `condition_variable`**
در یک سناریوی **تولید و مصرف (Producer-Consumer)**، معمولاً دو رشته‌ی جداگانه داریم:
- **تولیدکننده (Producer):** داده‌ای را تولید کرده و در یک صف قرار می‌دهد.
- **مصرف‌کننده (Consumer):** داده‌ها را از صف دریافت کرده و پردازش می‌کند.

### **۳.۱: تعریف ساختار داده‌ها**
```cpp
class Message { // شیء پیام برای ارسال بین رشته‌ها
    // ...
};

queue<Message> mqueue; // صف پیام‌ها
condition_variable mcond; // متغیر شرطی برای همگام‌سازی
mutex mmutex; // متغیر قفل برای جلوگیری از شرایط رقابتی
```
- `queue<Message> mqueue`: صفی برای ذخیره‌ی پیام‌های ارسال‌شده توسط تولیدکننده.
- `condition_variable mcond`: متغیری برای کنترل انتظار و بیدار کردن رشته‌ها.
- `mutex mmutex`: قفل برای جلوگیری از مشکلات همزمانی.

---

## **۴. مصرف‌کننده (Consumer)**
```cpp
void consumer()
{
    while(true) {
        unique_lock<mutex> lck{mmutex}; // دریافت قفل mmutex
        while (mcond.wait(lck)) /* هیچ کاری انجام نده */; // آزادسازی قفل و انتظار
        // پس از بیدار شدن، قفل مجدداً دریافت می‌شود

        auto m = mqueue.front(); // دریافت پیام
        mqueue.pop();
        lck.unlock(); // آزادسازی قفل

        // ... پردازش پیام m ...
    }
}
```

### **مراحل اجرای `consumer()`**
1. `unique_lock<mutex> lck{mmutex};` → **قفل mutex** برای جلوگیری از شرایط رقابتی در صف پیام.
2. `mcond.wait(lck);` → **انتظار برای وقوع یک رویداد:**
   - قفل را آزاد می‌کند تا تولیدکننده بتواند داده‌ای را اضافه کند.
   - هنگام بیدار شدن، قفل را دوباره دریافت می‌کند.
3. `auto m = mqueue.front();` → پیام جلویی صف را دریافت می‌کند.
4. `mqueue.pop();` → پیام را از صف حذف می‌کند.
5. `lck.unlock();` → قفل را آزاد می‌کند تا سایر رشته‌ها بتوانند صف را تغییر دهند.
6. پیام را پردازش می‌کند.

### **چرا `mcond.wait(lck)` قفل را آزاد می‌کند؟**
- وقتی رشته در حال انتظار است، **قفل را آزاد می‌کند تا سایر رشته‌ها بتوانند تغییراتی روی صف اعمال کنند**.  
- وقتی رویداد موردنظر رخ دهد (`notify_one()` اجرا شود)، قفل را دوباره دریافت می‌کند و ادامه‌ی کار را انجام می‌دهد.

---

## **۵. تولیدکننده (Producer)**
```cpp
void producer()
{
    while(true) {
        Message m;
        // ... پر کردن پیام ...

        unique_lock<mutex> lck {mmutex}; // محافظت از عملیات
        mqueue.push(m);
        mcond.notify_one(); // ارسال اعلان
    } // آزادسازی قفل در انتهای دامنه
}
```

### **مراحل اجرای `producer()`**
1. `Message m;` → یک پیام جدید ایجاد می‌کند.
2. پیام را مقداردهی می‌کند.
3. `unique_lock<mutex> lck {mmutex};` → **قفل mutex** را دریافت می‌کند تا تغییرات در صف را ایمن نگه دارد.
4. `mqueue.push(m);` → پیام را به صف اضافه می‌کند.
5. `mcond.notify_one();` → **به یک رشته‌ی منتظر (مصرف‌کننده) اطلاع می‌دهد که داده‌ای در صف موجود است.**
6. قفل به‌طور خودکار در انتهای بلاک آزاد می‌شود.

---

## **۶. چرا `condition_variable` برای این کار مناسب است؟**
بدون استفاده از `condition_variable`، رشته‌ی مصرف‌کننده باید مرتباً صف را بررسی کند (Polling)، که موجب **اتلاف منابع پردازنده** می‌شود. اما با `condition_variable`:
- **مصرف‌کننده فقط وقتی که داده‌ای در صف موجود است از خواب بیدار می‌شود.**
- **مصرف بیهوده‌ی پردازنده کاهش می‌یابد.**
- **هماهنگی بین رشته‌ها بهینه‌تر انجام می‌شود.**

---

## **۷. نکات کلیدی**
1. **`this_thread::sleep_for`** برای متوقف کردن یک رشته برای مدت مشخصی استفاده می‌شود.
2. **`condition_variable`** مکانیزمی برای همگام‌سازی بین رشته‌هاست که منتظر وقوع یک رویداد می‌ماند.
3. **`mutex`** از دسترسی همزمان به منابع مشترک محافظت می‌کند.
4. **`notify_one()`** یک رشته‌ی منتظر را بیدار می‌کند.
5. **`wait(lck)`** قفل را آزاد کرده و منتظر می‌ماند تا رویداد موردنظر رخ دهد.

---

## **۸. خلاصه‌ی عملکرد کلی**
- **تولیدکننده** پیام را تولید کرده و در صف قرار می‌دهد، سپس `notify_one()` را فراخوانی می‌کند.
- **مصرف‌کننده** تا زمانی که پیام جدیدی در صف نباشد، در **حالت انتظار** باقی می‌ماند.
- وقتی **تولیدکننده** پیامی ارسال کند، **مصرف‌کننده بیدار شده** و پیام را پردازش می‌کند.
- این فرایند **بدون مصرف بیهوده‌ی پردازنده** و بهینه انجام می‌شود.

---

### **۹. آیا این روش بهینه است؟**
بله، این روش بهینه است، زیرا:
✅ **انتظار فعال (Busy Waiting) ندارد.**  
✅ **رشته‌ی مصرف‌کننده فقط در صورت وجود داده بیدار می‌شود.**  
✅ **امکان استفاده در سناریوهای پیشرفته‌ی همگام‌سازی را دارد.**  

💡 اگر چندین مصرف‌کننده داشته باشیم، می‌توان از `notify_all()` استفاده کرد تا همه‌ی آن‌ها بیدار شوند.

---

### **نتیجه‌گیری**
این مثال نشان می‌دهد که چگونه می‌توان با استفاده از `condition_variable` و `mutex`، ارتباط **بِهینه و همگام** بین رشته‌ها را برقرار کرد و از مشکلات **شرایط رقابتی و مصرف بیهوده‌ی منابع** جلوگیری کرد. 🚀


---

### **`condition_variable` در C++ – توضیح کامل با مثال‌های فراوان**

---
## **۱. `condition_variable` چیست؟**
در برنامه‌نویسی چندنخی (Multithreading)، `condition_variable` یک مکانیزم برای **همگام‌سازی (Synchronization)** بین رشته‌ها است. این امکان را می‌دهد که **یک یا چند رشته منتظر یک رویداد بمانند** و وقتی که شرایط موردنظر فراهم شد، **بهینه بیدار شوند**.

💡 **مشکل اصلی در چندنخی:**  
وقتی چندین **رشته (Thread)** با یک **منبع مشترک (Shared Resource)** کار می‌کنند، باید به‌گونه‌ای مدیریت شوند که **تداخل و مشکلات همزمانی (Race Condition) ایجاد نشود**.

✅ **راه‌حل:**  
- استفاده از `mutex` برای **محافظت از منابع مشترک**.
- استفاده از `condition_variable` برای **مدیریت انتظار و بیداری رشته‌ها**.

---

## **۲. نحوه‌ی کار `condition_variable`**
### **سه بخش اصلی `condition_variable`:**
1. **انتظار (`wait()`)**  
   - باعث می‌شود که یک رشته **منتظر یک رویداد بماند**.
   - در حین انتظار، **قفل را آزاد می‌کند تا رشته‌های دیگر کار خود را انجام دهند**.
   - وقتی که بیدار شد، **دوباره قفل را دریافت می‌کند**.

2. **اعلان (`notify_one()` و `notify_all()`)**  
   - `notify_one()` → **یک رشته‌ی منتظر را بیدار می‌کند.**
   - `notify_all()` → **همه‌ی رشته‌های منتظر را بیدار می‌کند.**

3. **محافظت (`mutex`)**  
   - `condition_variable` **بدون `mutex` کار نمی‌کند**.
   - همیشه باید با `std::unique_lock<std::mutex>` استفاده شود.

---

## **۳. مثال ساده: دو رشته‌ی تولیدکننده و مصرف‌کننده**
### **📌 مسئله:**  
- **یک رشته (producer)** عددی را تولید می‌کند و در یک متغیر ذخیره می‌کند.
- **یک رشته‌ی دیگر (consumer)** باید منتظر بماند تا داده‌ی جدید آماده شود.

### **📌 کد کامل**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

using namespace std;

mutex mtx;  // قفل برای حفاظت از منبع مشترک
condition_variable cv;  // متغیر شرطی برای همگام‌سازی
int data = 0;  // داده‌ی مشترک
bool ready = false;  // وضعیت داده

void consumer() {
    unique_lock<mutex> lock(mtx);  // دریافت قفل
    cout << "Consumer waiting...\n";
    
    cv.wait(lock, [] { return ready; });  // منتظر بمان تا ready شود

    cout << "Consumer received data: " << data << endl;
    ready = false;  // داده مصرف شد
}

void producer() {
    this_thread::sleep_for(chrono::seconds(1));  // شبیه‌سازی تاخیر

    unique_lock<mutex> lock(mtx);  // دریافت قفل
    data = 100;  // مقداردهی داده
    ready = true;
    
    cout << "Producer produced data: " << data << endl;
    cv.notify_one();  // بیدار کردن یک مصرف‌کننده
}

int main() {
    thread t1(consumer);
    thread t2(producer);

    t1.join();
    t2.join();

    return 0;
}
```

---

### **۴. تحلیل دقیق این مثال**
#### **📌 مراحل اجرا:**
1. **مصرف‌کننده (consumer)**:
   - ابتدا **قفل `mutex` را دریافت می‌کند**.
   - سپس **با `cv.wait()` منتظر می‌ماند** تا `ready == true` شود.
   - در این مدت، **قفل را آزاد می‌کند** تا تولیدکننده بتواند کارش را انجام دهد.
   - وقتی که `ready` مقدار `true` گرفت، **بیدار شده و داده را پردازش می‌کند**.

2. **تولیدکننده (producer)**:
   - بعد از ۱ ثانیه تأخیر، **قفل `mutex` را دریافت می‌کند**.
   - مقدار `data` را برابر `100` قرار داده و `ready` را `true` می‌کند.
   - **یک رشته‌ی منتظر را بیدار می‌کند** (`cv.notify_one();`).

✅ **نتیجه:** مصرف‌کننده بدون مصرف بیهوده‌ی پردازنده، **منتظر داده می‌ماند** و فقط وقتی که `producer` داده را تولید کند، بیدار می‌شود.

---

## **۵. مثال `notify_all()`: بیدار کردن چندین مصرف‌کننده**
اگر چندین رشته‌ی مصرف‌کننده داشته باشیم، از `notify_all()` استفاده می‌کنیم.

### **📌 کد: چند مصرف‌کننده و یک تولیدکننده**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

using namespace std;

mutex mtx;
condition_variable cv;
int data = 0;
bool ready = false;

void consumer(int id) {
    unique_lock<mutex> lock(mtx);
    cv.wait(lock, [] { return ready; });  // انتظار برای داده

    cout << "Consumer " << id << " received data: " << data << endl;
}

void producer() {
    this_thread::sleep_for(chrono::seconds(1));

    unique_lock<mutex> lock(mtx);
    data = 42;
    ready = true;
    
    cout << "Producer produced data: " << data << endl;
    cv.notify_all();  // بیدار کردن تمام مصرف‌کننده‌ها
}

int main() {
    vector<thread> consumers;
    for (int i = 1; i <= 3; ++i)
        consumers.emplace_back(consumer, i);

    thread t1(producer);

    for (auto &t : consumers) t.join();
    t1.join();

    return 0;
}
```

---

### **۶. `condition_variable` در مقابل `sleep_for`**
اگر `condition_variable` را حذف کنیم و فقط از `sleep_for` استفاده کنیم، **کارایی به شدت کاهش می‌یابد** زیرا:
- مصرف‌کننده‌ها **بیهوده در یک حلقه چک می‌کنند** که آیا داده آمده است یا نه.
- پردازنده **مدام درگیر پردازش غیرضروری می‌شود**.
- در حالت چند مصرف‌کننده، پردازش **غیر بهینه و کند** خواهد بود.

🚀 **`condition_variable` باعث می‌شود مصرف‌کننده فقط وقتی که لازم است، بیدار شود.**

---

### **۷. جمع‌بندی و نکات مهم**
✅ **`condition_variable` باعث مدیریت کارآمد انتظار و بیداری در برنامه‌های چندنخی می‌شود.**  
✅ **`wait()`** منتظر یک رویداد می‌ماند، درحالی‌که قفل را آزاد می‌کند.  
✅ **`notify_one()`** یک رشته‌ی منتظر را بیدار می‌کند.  
✅ **`notify_all()`** همه‌ی رشته‌های منتظر را بیدار می‌کند.  
✅ **همیشه باید `condition_variable` را با `mutex` استفاده کنیم.**  

---

### **۸. چه زمانی از `condition_variable` استفاده کنیم؟**
✅ زمانی که یک یا چند **رشته باید منتظر یک شرط خاص بمانند**.  
✅ زمانی که **نباید پردازنده را بیهوده مصرف کنیم**.  
✅ در سناریوهای **ارتباط بین تولیدکننده و مصرف‌کننده**.  
✅ در **برنامه‌های بلادرنگ (Real-time)** برای بهینه‌سازی پردازش‌های همزمان.

🚀 **`condition_variable` یکی از مهم‌ترین ابزارهای همگام‌سازی در C++ است که کارایی برنامه‌های چندنخی را بهبود می‌دهد!**

## Communicating Tasks
کتابخانه استاندارد چند قابلیت را فراهم می‌کند که به برنامه‌نویسان امکان می‌دهد تا در سطح مفهومی وظایف (کاری که می‌تواند به‌طور همزمان انجام شود) کار کنند، به‌جای اینکه مستقیماً در سطح پایین‌تری با نخ‌ها (threads) و قفل‌ها (locks) سروکار داشته باشند:

1. **future** و **promise** برای بازگرداندن یک مقدار از یک وظیفه‌ای که روی یک نخ جداگانه اجرا شده است.  
2. **packaged_task** برای کمک به اجرای وظایف و اتصال مکانیزم‌های مربوط به بازگرداندن نتیجه.  
3. **async()** برای اجرای یک وظیفه به روشی بسیار مشابه با فراخوانی یک تابع.  

این قابلیت‌ها در **<future>** قرار دارند.

## future and promise
نکته مهم درباره **future** و **promise** این است که آن‌ها امکان انتقال یک مقدار بین دو وظیفه را بدون نیاز به استفاده صریح از یک قفل فراهم می‌کنند؛ به‌عبارت دیگر، **«سیستم»** این انتقال را به‌صورت کارآمد پیاده‌سازی می‌کند.  

ایده‌ی اصلی ساده است: زمانی که یک وظیفه می‌خواهد مقداری را به وظیفه‌ی دیگری منتقل کند، آن مقدار را در یک **promise** قرار می‌دهد. به نوعی، پیاده‌سازی این مکانیزم باعث می‌شود که مقدار در **future** متناظر ظاهر شود و از آنجا قابل خواندن باشد (معمولاً توسط وظیفه‌ای که آن را اجرا کرده است).  

ما می‌توانیم این مفهوم را به‌صورت گرافیکی نمایش دهیم:

![](../image/5/5.1.png)

اگر یک **future<X>** به نام **fx** داشته باشیم، می‌توانیم مقدار نوع **X** را از آن دریافت کنیم:

```cpp
X v = fx.get(); // در صورت لزوم، منتظر می‌مانیم تا مقدار محاسبه شود
```

اگر مقدار هنوز آماده نباشد، نخ (thread) ما تا زمانی که مقدار برسد، مسدود (blocked) می‌شود. اگر مقدار قابل محاسبه نباشد، **get()** ممکن است یک استثنا (exception) پرتاب کند (این استثنا ممکن است از سیستم باشد یا از وظیفه‌ای که سعی داشتیم مقدار را از آن بگیریم منتقل شده باشد).

هدف اصلی **promise** این است که عملیات ساده‌ی «قرار دادن» مقدار را فراهم کند (این عملیات‌ها **set_value()** و **set_exception()** نام دارند) تا با **get()** از **future** مطابقت داشته باشد.  

نام‌های **future** و **promise** تاریخی هستند؛ لطفاً مرا سرزنش نکنید! این نام‌ها منبعی غنی برای بازی با کلمات هستند.

اگر یک **promise** داشته باشید و نیاز به ارسال یک نتیجه از نوع **X** به یک **future** داشته باشید، می‌توانید به دو روش این کار را انجام دهید:  

1. مقدار را ارسال کنید.  
2. یک استثنا را ارسال کنید.  

به‌عنوان مثال:

```cpp
void f(promise<X>& px) // یک وظیفه: قرار دادن نتیجه در px
{
    try {
        X res;
        // ... مقدار res را محاسبه کنید ...
        px.set_value(res);
    }
    catch (...) { // مشکل: مقدار res محاسبه نشد
        // استثنا را به نخ future منتقل کنید:
        px.set_exception(current_exception());
    }
}
```

**current_exception()** به استثنای گرفته‌شده اشاره دارد (§30.4.1.2).  

برای پردازش استثنایی که از طریق **future** منتقل شده است، تابعی که **get()** را صدا می‌زند باید آماده‌ی گرفتن آن در جایی باشد. به‌عنوان مثال:

```cpp
void g(future<X>& fx) // یک وظیفه: دریافت نتیجه از fx
{
    try {
        X v = fx.get(); // در صورت لزوم، منتظر می‌مانیم تا مقدار محاسبه شود
        // ... استفاده از v ...
    }
    catch (...) { // مشکل: کسی نتوانست v را محاسبه کند
        // ... مدیریت خطا ...
    }
}
```

---

### **توضیح کامل future و promise در C++**

در برنامه‌نویسی همروند (concurrent programming)، مدیریت داده‌ها بین چندین **نخ (thread)** یکی از چالش‌های اساسی است. در بسیاری از مواقع، نیاز داریم داده‌ای را از یک وظیفه (task) به وظیفه‌ی دیگری منتقل کنیم. معمولاً این کار با **قفل‌ها (locks)** انجام می‌شود، اما استفاده‌ی مستقیم از قفل‌ها ممکن است باعث مشکلاتی مانند **بن‌بست (deadlock)**، **شرایط رقابتی (race conditions)** و **افت عملکرد** شود.

C++ برای حل این مشکل **future** و **promise** را در کتابخانه‌ی **`<future>`** ارائه کرده است که بدون نیاز به استفاده‌ی صریح از **قفل‌ها**، امکان انتقال داده‌ها بین **دو وظیفه‌ی همزمان** را فراهم می‌کنند.  

---

## **1. مفهوم future و promise**

### **Promise چیست؟**
**`promise<T>`** وسیله‌ای است که به شما اجازه می‌دهد یک مقدار **T** را در آینده تنظیم کنید. این مقدار ممکن است یک مقدار عادی باشد یا یک **استثنا (exception)**.

### **Future چیست؟**
**`future<T>`** وسیله‌ای برای دریافت مقدار **T** در آینده است. این مقدار همان مقداری است که یک **promise** در نخ دیگر آن را تنظیم کرده است.

### **ارتباط بین Future و Promise**
وقتی داده‌ای را در یک **promise** قرار می‌دهیم، **سیستم** به طور خودکار این مقدار را در **future** متناظر نمایان می‌کند. این کار به‌صورت کارآمد انجام می‌شود و نیازی به **قفل دستی** ندارد.

---

## **2. نحوه استفاده از future و promise**
### **خواندن مقدار از یک future**
اگر یک **future** از نوع **X** داشته باشیم، می‌توانیم مقدار آن را با `get()` دریافت کنیم:

```cpp
X v = fx.get(); // در صورت لزوم، منتظر می‌مانیم تا مقدار محاسبه شود
```

### **نحوه عملکرد `get()`**
1. اگر مقدار آماده باشد، بلافاصله مقدار را برمی‌گرداند.
2. اگر مقدار هنوز آماده نباشد، **نخ مسدود (blocked)** می‌شود تا زمانی که مقدار برسد.
3. اگر مقدار به هر دلیلی قابل محاسبه نباشد، `get()` ممکن است **یک استثنا پرتاب کند**.

---

## **3. قرار دادن مقدار در promise**
هدف اصلی **promise** این است که امکان قرار دادن مقدار را فراهم کند. برای انجام این کار، از دو متد استفاده می‌کنیم:

1. **`set_value()`** → مقدار نهایی را در promise قرار می‌دهد.
2. **`set_exception()`** → یک استثنا را در promise قرار می‌دهد.

---

## **4. مثال عملی: ارسال مقدار از promise به future**
فرض کنید می‌خواهیم مقدار یک متغیر از نوع **X** را از یک نخ به نخ دیگر منتقل کنیم:

### **وظیفه‌ای که مقدار را تولید و در `promise` قرار می‌دهد**
```cpp
void f(std::promise<X>& px) // یک وظیفه: قرار دادن نتیجه در px
{
    try {
        X res;
        // ... مقدار res را محاسبه کنید ...
        px.set_value(res); // مقدار را در promise قرار می‌دهیم
    }
    catch (...) { // خطا: مقدار res محاسبه نشد
        px.set_exception(std::current_exception()); // استثنا را به future ارسال می‌کنیم
    }
}
```

🔹 **کاری که این تابع انجام می‌دهد:**
- مقدار **`res`** را محاسبه می‌کند.
- اگر محاسبه موفقیت‌آمیز بود، مقدار را در **promise** قرار می‌دهد.
- اگر خطایی رخ دهد، **استثنا** را در **promise** ذخیره می‌کند.

---

### **وظیفه‌ای که مقدار را از `future` دریافت می‌کند**
```cpp
void g(std::future<X>& fx) // یک وظیفه: دریافت نتیجه از fx
{
    try {
        X v = fx.get(); // اگر مقدار آماده نبود، منتظر می‌مانیم
        // ... از v استفاده کنید ...
    }
    catch (...) { // خطا: کسی نتوانست v را محاسبه کند
        // ... مدیریت خطا ...
    }
}
```

🔹 **کاری که این تابع انجام می‌دهد:**
- مقدار را از **future** می‌خواند.
- اگر مقدار آماده نباشد، نخ را مسدود می‌کند تا مقدار برسد.
- اگر **promise** استثنا ارسال کرده باشد، آن را می‌گیرد و مدیریت می‌کند.

---

## **5. بررسی دقیق استثناها و `current_exception()`**
گاهی اوقات مقدار قابل محاسبه نیست و **یک استثنا رخ می‌دهد**. در چنین شرایطی، می‌توان **استثنا را نیز از طریق promise به future منتقل کرد**.

### **ارسال استثنا**
```cpp
catch (...) { 
    px.set_exception(std::current_exception()); // استثنا را به future منتقل کن
}
```

### **دریافت و مدیریت استثنا**
```cpp
catch (...) { 
    // مدیریت خطا
}
```
**`current_exception()`** به **آخرین استثنای رخ داده در بلوک `try-catch`** اشاره دارد.

---

## **6. تفاوت `future` و `promise` با `thread` و `mutex`**
🔹 **`std::thread`** → برای اجرای توابع در نخ‌های جدید استفاده می‌شود، اما مدیریت داده‌ها را بر عهده ندارد.  
🔹 **`std::mutex`** → برای مدیریت همزمانی و جلوگیری از تداخل داده‌ها استفاده می‌شود.  
🔹 **`std::promise` و `std::future`** → برای انتقال داده‌ها بین نخ‌ها به **روشی ایمن و کارآمد بدون نیاز به قفل دستی** طراحی شده‌اند.

---

## **7. نتیجه‌گیری**
- **future و promise** امکان انتقال داده‌ها را بین **دو وظیفه‌ی همزمان** بدون نیاز به **قفل‌ها** فراهم می‌کنند.
- **promise** مقدار یا استثنا را ذخیره می‌کند.
- **future** مقدار را دریافت می‌کند و اگر مقدار آماده نباشد، نخ را تا دریافت مقدار مسدود می‌کند.
- **`get()`** یا مقدار را بازمی‌گرداند یا یک استثنا پرتاب می‌کند.
- **`set_value()`** مقدار را در promise تنظیم می‌کند.
- **`set_exception()`** یک استثنا را به future ارسال می‌کند.
- این مکانیسم به **بهبود عملکرد و جلوگیری از مشکلات همزمانی** کمک می‌کند.

---

**مثال کلی: ترکیب promise و future با نخ (thread)**

```cpp
#include <iostream>
#include <future>
#include <thread>

void compute(std::promise<int>& px) {
    try {
        int res = 42;  // مقداری تولید کن
        px.set_value(res);  // مقدار را در promise ذخیره کن
    } catch (...) {
        px.set_exception(std::current_exception()); // اگر خطا رخ داد، آن را ارسال کن
    }
}

int main() {
    std::promise<int> px;
    std::future<int> fx = px.get_future();

    std::thread t(compute, std::ref(px)); // اجرای تابع در یک نخ جداگانه

    try {
        int value = fx.get(); // مقدار را دریافت کن
        std::cout << "Result: " << value << std::endl;
    } catch (...) {
        std::cout << "Error: Exception occurred!" << std::endl;
    }

    t.join(); // منتظر اتمام نخ بمان
    return 0;
}
```
✅ **توضیح:**  
- `promise<int>` مقدار را در یک نخ تنظیم می‌کند.  
- `future<int>` مقدار را در نخ اصلی دریافت می‌کند.  
- `std::thread` وظیفه‌ی پردازش مقدار را اجرا می‌کند.  
- `get()` مقدار را خوانده و اگر آماده نبود، منتظر می‌ماند.  

با این روش، می‌توان به **برنامه‌نویسی همروند امن و کارآمد** دست یافت. 🚀

## packaged_task
چطور می‌توانیم یک **future** را به وظیفه‌ای که نیاز به نتیجه دارد و **promise** مربوطه را به نخ (thread) که باید آن نتیجه را تولید کند، ارتباط دهیم؟ نوع **packaged_task** برای ساده‌تر کردن راه‌اندازی وظایف متصل به **future**ها و **promise**ها که باید روی نخ‌ها اجرا شوند، ارائه شده است. یک **packaged_task** کد بسته‌بندی شده‌ای را فراهم می‌کند تا مقدار بازگشتی یا استثنا از وظیفه را در یک **promise** قرار دهد (مانند کدی که در §5.3.5.1 نشان داده شده است). اگر از آن بخواهید با فراخوانی **get_future**، یک **packaged_task** به شما **future** مربوط به **promise** خود را می‌دهد. به عنوان مثال، می‌توانیم دو وظیفه راه‌اندازی کنیم تا هر کدام نیمی از عناصر یک **vector<double>** را با استفاده از تابع **accumulate()** جمع‌آوری کنند:

```cpp
double accum(double* beg, double* end, double init)
// محاسبه مجموع بازه [beg:end) با مقدار اولیه init
{
    return accumulate(beg, end, init);
}
```

```cpp
double comp2(vector<double>& v)
{
    using Task_type = double(double*, double*, double); // نوع وظیفه
    packaged_task<Task_type> pt0 {accum}; // بسته‌بندی وظیفه (یعنی accum)
    packaged_task<Task_type> pt1 {accum};
    future<double> f0 {pt0.get_future()}; // گرفتن future مربوط به pt0
    future<double> f1 {pt1.get_future()}; // گرفتن future مربوط به pt1
    double* first = &v[0];
    thread t1 {move(pt0), first, first + v.size()/2, 0}; // شروع نخ برای pt0
    thread t2 {move(pt1), first + v.size()/2, first + v.size(), 0}; // شروع نخ برای pt1
    // ...
    return f0.get() + f1.get(); // گرفتن نتایج
}
```

الگوی **packaged_task** نوع وظیفه را به عنوان پارامتر الگوی خود می‌گیرد (که در اینجا **Task_type** یک مستعار برای `double(double*, double*, double)` است) و وظیفه را به عنوان پارامتر سازنده خود می‌گیرد (که در اینجا **accum** است). عملیات **move()** مورد نیاز است زیرا یک **packaged_task** قابل کپی کردن نیست.  
توجه داشته باشید که در این کد هیچ اشاره‌ای به قفل‌ها (locks) نشده است: ما قادر هستیم روی وظایفی که باید انجام شوند تمرکز کنیم، نه مکانیزم‌هایی که برای مدیریت ارتباطات آن‌ها استفاده می‌شوند. این دو وظیفه روی نخ‌های جداگانه اجرا خواهند شد و بنابراین ممکن است به صورت موازی اجرا شوند.

---

تابع `accumulate()` در C++ یک الگوریتم استاندارد از کتابخانه `<numeric>` است که برای محاسبه مجموع یا هر نوع تجمیع دیگر روی یک بازه از داده‌ها (مانند آرایه یا وکتور) استفاده می‌شود. این تابع به طور پیش‌فرض برای جمع کردن مقادیر در یک بازه استفاده می‌شود، اما می‌توان از آن برای سایر عملیات‌های تجمیعی (مانند میانگین، ضرب و ...) نیز استفاده کرد.

### سینتکس:
```cpp
#include <numeric>
T accumulate(InputIterator first, InputIterator last, T init);
T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation op);
```

- **`first` و `last`:** این دو پارامتر نشان‌دهنده شروع و پایان بازه‌ای هستند که باید تجمیع شوند.
- **`init`:** مقدار اولیه‌ای که به محاسبات افزوده می‌شود.
- **`op` (اختیاری):** این پارامتر یک تابع دودویی است که دو مقدار را می‌گیرد و نتیجه ترکیب آن‌ها را برمی‌گرداند (برای مثال جمع، ضرب و غیره). اگر این پارامتر مشخص نشود، به طور پیش‌فرض از عملگر جمع (`+`) استفاده می‌شود.

### مثال ساده از `accumulate`:

فرض کنید که یک آرایه از اعداد صحیح دارید و می‌خواهید مجموع آن‌ها را محاسبه کنید:

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    // یک وکتور از اعداد
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // استفاده از accumulate برای محاسبه مجموع
    int sum = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "Sum: " << sum << std::endl;  // خروجی: Sum: 15

    return 0;
}
```

در این مثال:
- `vec.begin()` و `vec.end()` به ترتیب نشان‌دهنده آغاز و پایان وکتور هستند.
- مقدار اولیه `0` است.
- به دلیل اینکه عملگر پیش‌فرض `accumulate` جمع است، به طور خودکار اعداد داخل وکتور را جمع می‌کند.

### مثال با استفاده از `op` (تابع دودویی):

در اینجا می‌خواهیم از `accumulate` برای ضرب تمام عناصر یک وکتور استفاده کنیم:

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <functional>

int main() {
    // یک وکتور از اعداد
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // استفاده از accumulate برای ضرب تمام عناصر
    int product = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "Product: " << product << std::endl;  // خروجی: Product: 120

    return 0;
}
```

در این مثال:
- مقدار اولیه `1` است (چون ضرب با 1 شروع می‌شود).
- تابع `std::multiplies<int>()` که یک تابع دودویی برای ضرب است، به عنوان تابع تجمعی (reduction function) استفاده می‌شود.

### جمع‌بندی:
تابع `accumulate()` در C++ به شما این امکان را می‌دهد که به راحتی تجمیع‌هایی مانند جمع، ضرب، یا حتی سایر عملیات‌های سفارشی را بر روی یک بازه از داده‌ها انجام دهید. این تابع می‌تواند از یک مقدار اولیه شروع کند و سپس با استفاده از یک تابع دودویی (که به طور پیش‌فرض جمع است) تمام مقادیر در بازه را ترکیب کند.

---

این متن در مورد استفاده از `packaged_task` در C++ است که برای مدیریت و ارتباط بین `futures` و `promises` به کار می‌رود. هدف اصلی این است که بدون نگرانی از مکانیزم‌های پیچیده همزمانی (مثل قفل‌ها)، بتوانیم وظایف را به طور همزمان (parallel) اجرا کنیم و نتایج آن‌ها را دریافت کنیم.

### 1. مفهوم `packaged_task`:

- `packaged_task` یک نوع کپسوله‌سازی است که یک کار (task) را بسته‌بندی می‌کند. این کار ممکن است هر نوع تابع یا الگوریتمی باشد که به نتیجه نیاز دارد.
- `packaged_task` یک `promise` داخلی دارد که می‌تواند نتیجه یا استثنا (exception) ناشی از اجرای تابع را ذخیره کند.
- با استفاده از `get_future()` می‌توان یک شیء `future` دریافت کرد که به `promise` مرتبط با `packaged_task` اشاره می‌کند. این `future` به شما اجازه می‌دهد تا از نتیجه یا استثنا بعد از اتمام کار استفاده کنید.

### 2. کارکرد کد نمونه:

در این کد، دو وظیفه برای جمع مقادیر یک آرایه از نوع `vector<double>` به صورت موازی (با استفاده از دو نخ یا thread) تعریف شده است. هر وظیفه نصفی از آرایه را جمع می‌کند. 

#### مراحل کد:

1. **تعریف تابع `accum`:** 
   این تابع از `accumulate` استفاده می‌کند تا مجموع مقادیری را که در یک بازه از آرایه قرار دارند محاسبه کند.

   ```cpp
   double accum(double* beg, double* end, double init)
   {
       return accumulate(beg, end, init);
   }
   ```

2. **تعریف تابع `comp2`:** 
   در این تابع، دو `packaged_task` تعریف می‌شود که هرکدام یک شی از نوع `accum` را بسته‌بندی می‌کنند. سپس، با استفاده از `get_future`، یک `future` برای هرکدام از این `packaged_task` ها گرفته می‌شود تا بعداً بتوانیم نتایج آنها را دریافت کنیم.

   ```cpp
   double comp2(vector<double>& v)
   {
       using Task_type = double(double*, double*, double); // نوع تسک
       packaged_task<Task_type> pt0 {accum}; // بسته‌بندی اولین تسک
       packaged_task<Task_type> pt1 {accum}; // بسته‌بندی دومین تسک
       future<double> f0 {pt0.get_future()}; // دریافت future برای اولین تسک
       future<double> f1 {pt1.get_future()}; // دریافت future برای دومین تسک
   ```

3. **ایجاد نخ‌ها:**
   سپس دو نخ (`thread`) برای اجرای هرکدام از وظایف تعریف می‌شود. این نخ‌ها به طور موازی (parallel) اجرا می‌شوند.

   ```cpp
   double* first = &v[0];
   thread t1 {move(pt0), first, first + v.size()/2, 0}; // اجرای نخ برای اولین نیمه از آرایه
   thread t2 {move(pt1), first + v.size()/2, first + v.size(), 0}; // اجرای نخ برای دومین نیمه از آرایه
   ```

   در اینجا، از `move` استفاده می‌شود زیرا `packaged_task` قابل کپی کردن نیست و باید به صورت انتقالی (move) از نخ اصلی به نخ‌های جدید منتقل شود.

4. **دریافت نتایج:**
   بعد از اتمام اجرای نخ‌ها، نتایج هرکدام از وظایف با استفاده از `get()` از `future` ها دریافت می‌شود. این تابع بلوکه می‌شود تا زمانی که نتیجه در دسترس باشد.

   ```cpp
   return f0.get() + f1.get(); // جمع نتایج هر دو تسک
   ```

### 3. مزایای استفاده از `packaged_task`:

- **انتقال نتایج به صورت ایمن:** به جای استفاده از قفل‌ها و مکانیزم‌های پیچیده برای هماهنگ کردن داده‌ها بین نخ‌ها، می‌توانیم از `future` و `promise` برای مدیریت ارتباطات بین نخ‌ها استفاده کنیم.
- **ساده‌سازی کد:** شما فقط به تابع یا کاری که باید انجام شود توجه می‌کنید و نیازی به نگرانی در مورد چگونگی مدیریت وضعیت نخ‌ها یا هماهنگ‌سازی نتایج نیست.
- **پشتیبانی از چندین نخ:** با استفاده از `packaged_task` و `future` می‌توانیم وظایف را به نخ‌های مختلف اختصاص دهیم و نتایج را بعداً جمع‌آوری کنیم.

### 4. نحوه عملکرد در محیط چندنخی:

این روش به طوری طراحی شده است که دو بخش از آرایه در دو نخ مختلف پردازش می‌شوند، به طور موازی و بدون نیاز به هماهنگ‌سازی پیچیده. هر نخ با استفاده از `packaged_task` خود یک نتیجه تولید می‌کند که در نهایت با استفاده از `get()` به صورت همزمان جمع‌آوری می‌شود.

### نتیجه‌گیری:
استفاده از `packaged_task` در این مثال کمک می‌کند که کد همزمانی به صورت ساده و مؤثر پیاده‌سازی شود. به جای مدیریت پیچیده قفل‌ها، از مکانیزم‌های ساده‌ای مانند `future` و `promise` برای هماهنگ‌سازی نتایج نخ‌ها استفاده می‌شود. این روش به راحتی می‌تواند برای تقسیم بار کاری به نخ‌های مختلف در پردازش‌های موازی و توزیع‌شده مورد استفاده قرار گیرد.

--- 

مفهوم `packaged_task` در C++ برای مدیریت و هماهنگی بین وظایف مختلف در محیط چندنخی (multithreading) طراحی شده است. برای اینکه بهتر متوجه شوید، ابتدا باید مفهوم `future` و `promise` را درک کنید، زیرا این دو بخش اصلی کارکرد `packaged_task` هستند. 

### 1. **مفهوم `future` و `promise`:**
- **`promise`:** یک شیء است که برای نگهداری نتیجه یک محاسبه یا عمل پیچیده استفاده می‌شود. در واقع، شما به یک `promise` می‌گویید که انتظار دارید یک نتیجه خاص را تولید کند.
- **`future`:** یک شیء است که به شما امکان می‌دهد به نتیجه‌ای که توسط یک `promise` تولید می‌شود دسترسی پیدا کنید. در واقع، `future` به شما اجازه می‌دهد که منتظر بمانید تا نتیجه از کار برگردد.

### 2. **مفهوم `packaged_task`:**
`packaged_task` یک کپسوله‌سازی است که شما می‌توانید یک تابع یا الگوریتم را در آن قرار دهید و آن را به صورت غیرهمزمان (asynchronously) در یک نخ دیگر اجرا کنید. همچنین، `packaged_task` به شما این امکان را می‌دهد که یک `future` دریافت کنید که به نتیجه (یا استثنا) آن تابع دسترسی پیدا کنید.

### 3. **ساختار `packaged_task`:**
در حقیقت، `packaged_task` یک ترکیب از `task` (وظیفه‌ای که باید اجرا شود) و `promise` (که نتیجه آن را ذخیره می‌کند) است. زمانی که `packaged_task` به اجرا در می‌آید، نتیجه آن در `promise` قرار می‌گیرد و شما می‌توانید با استفاده از `future` نتیجه را دریافت کنید.

### 4. **مثال ساده:**

فرض کنید شما یک تابع دارید که به طور همزمان دو عدد را جمع می‌کند و می‌خواهید نتیجه آن را در یک `future` دریافت کنید. با استفاده از `packaged_task` می‌توانید این کار را انجام دهید.

```cpp
#include <iostream>
#include <thread>
#include <future>

// تابعی که دو عدد را جمع می‌کند
int add(int a, int b) {
    return a + b;
}

int main() {
    // ساخت packaged_task که تابع add را بسته‌بندی می‌کند
    std::packaged_task<int(int, int)> pt(add);

    // دریافت future برای دریافت نتیجه از packaged_task
    std::future<int> result = pt.get_future();

    // ایجاد نخ برای اجرای packaged_task
    std::thread t(std::move(pt), 3, 5);  // نخ جمع کردن 3 و 5

    // منتظر می‌مانیم تا نتیجه را از future دریافت کنیم
    std::cout << "Result: " << result.get() << std::endl;

    // اطمینان از اینکه نخ به پایان رسیده
    t.join();

    return 0;
}
```

### توضیحات:
1. **تعریف تابع `add`:** این تابع دو عدد را دریافت می‌کند و مجموع آن‌ها را برمی‌گرداند.
2. **تعریف `packaged_task`:** ما یک شیء `packaged_task` به نام `pt` ایجاد می‌کنیم که تابع `add` را بسته‌بندی می‌کند. نوع داده‌ای که `packaged_task` می‌تواند بسته‌بندی کند (در اینجا `int(int, int)`) نشان می‌دهد که این تابع دو عدد صحیح را می‌گیرد و یک عدد صحیح باز می‌گرداند.
3. **دریافت `future`:** با استفاده از `get_future()` از `packaged_task` یک `future` می‌گیریم که به نتیجه تابع `add` اشاره می‌کند.
4. **ایجاد نخ:** یک نخ (`std::thread`) ساخته می‌شود تا تابع `add` را به طور همزمان (concurrently) اجرا کند.
5. **دریافت نتیجه با `get()`:** بعد از اجرای تابع در نخ، ما از `future` استفاده می‌کنیم تا نتیجه را دریافت کنیم. در اینجا، `result.get()` نتیجه جمع کردن دو عدد را می‌دهد.
6. **پایان نخ:** `t.join()` اطمینان می‌دهد که نخ به پایان رسیده باشد قبل از اینکه برنامه خاتمه یابد.

### 5. **چرا از `packaged_task` استفاده کنیم؟**
- **هماهنگی آسان:** `packaged_task` به شما این امکان را می‌دهد که کد را بدون نیاز به استفاده از قفل‌ها یا هماهنگ‌کننده‌های پیچیده بنویسید. شما می‌توانید به راحتی از `future` برای دریافت نتایج استفاده کنید.
- **انتقال وظایف به نخ‌ها:** با استفاده از `packaged_task`، می‌توانید وظایف را به نخ‌های مختلف منتقل کنید و مطمئن باشید که وقتی نتیجه محاسبه شد، به درستی در `promise` قرار می‌گیرد و شما می‌توانید آن را از `future` دریافت کنید.

### 6. **مزایای استفاده از `packaged_task`:**
- **مدیریت ساده همزمانی:** بدون نیاز به استفاده از قفل‌ها، به راحتی می‌توانید نتایج کارهای موازی را دریافت کنید.
- **کپسوله‌سازی:** می‌توانید توابع را به راحتی بسته‌بندی کنید و آنها را به نخ‌های مختلف اختصاص دهید.
- **مقیاس‌پذیری:** با استفاده از `packaged_task`، می‌توانید برنامه‌های موازی با تعداد زیادی نخ ایجاد کنید و این کار را به شکلی ساده انجام دهید.

### جمع‌بندی:
`packaged_task` ابزار قدرتمندی است که کمک می‌کند کارهای پیچیده همزمانی را به راحتی مدیریت کنید. با استفاده از این نوع، می‌توانید نتیجه‌ی کارهای موازی را با استفاده از `future` ها دریافت کنید و از پیچیدگی‌های همزمان‌سازی (مانند قفل‌ها) جلوگیری کنید.

---

## async()
در این فصل، خط تفکری که دنبال کرده‌ام، ساده‌ترین و در عین حال از قدرتمندترین‌هاست: یک وظیفه را به‌عنوان یک تابع در نظر بگیرید که ممکن است به طور هم‌زمان با دیگر وظایف اجرا شود. این تنها مدل پشتیبانی‌شده توسط کتابخانه استاندارد C++ نیست، اما برای نیازهای متنوع بسیار مناسب است. مدل‌های پیچیده‌تر و دشوارتر، مانند سبک‌های برنامه‌نویسی که به حافظه مشترک وابسته‌اند، می‌توانند در صورت نیاز استفاده شوند.

برای راه‌اندازی وظایفی که ممکن است به‌طور غیرهمزمان اجرا شوند، می‌توانیم از `async()` استفاده کنیم:
```cpp
double comp4(vector<double>& v)
// اگر v به اندازه کافی بزرگ باشد، وظایف زیادی راه‌اندازی می‌شود
{
    if (v.size() < 10000) return accum(v.begin(), v.end(), 0.0);
    auto v0 = &v[0];
    auto sz = v.size();
    auto f0 = async(accum, v0, v0 + sz / 4, 0.0); // ربع اول
    auto f1 = async(accum, v0 + sz / 4, v0 + sz / 2, 0.0); // ربع دوم
    auto f2 = async(accum, v0 + sz / 2, v0 + sz * 3 / 4, 0.0); // ربع سوم
    auto f3 = async(accum, v0 + sz * 3 / 4, v0 + sz, 0.0); // ربع چهارم
    return f0.get() + f1.get() + f2.get() + f3.get(); // جمع‌آوری و ترکیب نتایج
}
```

اساساً، `async()` بخش "فراخوانی تابع" را از بخش "دریافت نتیجه" جدا می‌کند و هر دو را از اجرای واقعی وظیفه تفکیک می‌کند. با استفاده از `async()` نیازی به فکر کردن در مورد نخ‌ها و قفل‌ها ندارید. بلکه تنها در مورد وظایفی فکر می‌کنید که به‌طور بالقوه نتایج خود را به‌صورت غیرهمزمان محاسبه می‌کنند. محدودیت آشکار این است که نباید از `async()` برای وظایفی که منابع مشترک نیاز به قفل دارند استفاده کنید، زیرا با `async()` حتی نمی‌دانید که چند نخ برای انجام وظایف استفاده خواهد شد، زیرا این موضوع بستگی به تصمیم `async()` دارد که بر اساس منابع سیستم در دسترس در زمان فراخوانی اتخاذ می‌شود. به‌عنوان مثال، `async()` ممکن است بررسی کند که آیا هسته‌های آزاد (پردازنده‌ها) در دسترس هستند یا نه، قبل از اینکه تصمیم بگیرد چه تعداد نخ استفاده کند.

لطفاً توجه داشته باشید که `async()` فقط یک مکانیزم ویژه برای محاسبات موازی به منظور افزایش عملکرد نیست. به‌عنوان مثال، همچنین می‌توان از آن برای راه‌اندازی یک وظیفه جهت دریافت اطلاعات از کاربر استفاده کرد، در حالی که "برنامه اصلی" با انجام کار دیگری فعال می‌ماند.

---

خط تفکری که در این فصل دنبال کرده‌ام، به نظر من ساده‌ترین و در عین حال یکی از قدرتمندترین‌هاست: به یک وظیفه به عنوان یک تابع نگاه کنید که ممکن است به طور هم‌زمان با سایر وظایف اجرا شود. این مدل تنها مدل پشتیبانی‌شده توسط کتابخانه استاندارد C++ نیست، اما برای طیف وسیعی از نیازها به خوبی جواب می‌دهد. مدل‌های پیچیده‌تر و دقیق‌تر، مانند سبک‌های برنامه‌نویسی که به حافظه مشترک وابسته هستند، در صورت نیاز قابل استفاده هستند.

برای راه‌اندازی وظایفی که ممکن است به صورت ناهم‌زمان اجرا شوند، می‌توانیم از **`async()`** استفاده کنیم:

```cpp
double comp4(vector<double>& v)
// راه‌اندازی چندین وظیفه اگر v به اندازه کافی بزرگ باشد
{
    if (v.size() < 10000) return accum(v.begin(), v.end(), 0.0);
    auto v0 = &v[0];
    auto sz = v.size();
    auto f0 = async(accum, v0, v0 + sz / 4, 0.0); // یک چهارم اول
    auto f1 = async(accum, v0 + sz / 4, v0 + sz / 2, 0.0); // یک چهارم دوم
    auto f2 = async(accum, v0 + sz / 2, v0 + sz * 3 / 4, 0.0); // یک چهارم سوم
    auto f3 = async(accum, v0 + sz * 3 / 4, v0 + sz, 0.0); // یک چهارم چهارم
    return f0.get() + f1.get() + f2.get() + f3.get(); // جمع‌آوری و ترکیب نتایج
}
```

اساساً، **`async()`** قسمت «فراخوانی» یک تابع را از قسمت «دریافت نتیجه» جدا می‌کند و هر دو را از اجرای واقعی وظیفه جدا می‌کند. با استفاده از **`async()`**, شما نیاز به فکر کردن در مورد نخ‌ها و قفل‌ها ندارید. به جای آن، شما فقط در مورد وظایف فکر می‌کنید که به طور بالقوه نتایج خود را به صورت ناهم‌زمان محاسبه می‌کنند. محدودیت واضحی وجود دارد: به هیچ عنوان از **`async()`** برای وظایفی که منابع مشترک نیاز به قفل دارند استفاده نکنید – با **`async()`** حتی نمی‌دانید که چند نخ برای انجام وظیفه استفاده خواهند شد، زیرا این تصمیم به عهده خود **`async()`** است که بر اساس آنچه از منابع سیستم در زمان فراخوانی می‌داند، تصمیم می‌گیرد. به عنوان مثال، **`async()`** ممکن است بررسی کند که آیا هسته‌های آزاد (پردازنده‌ها) در دسترس هستند یا نه قبل از اینکه تصمیم بگیرد چند نخ استفاده کند.

لطفاً توجه داشته باشید که **`async()`** فقط یک مکانیزم تخصصی برای محاسبات موازی به منظور افزایش عملکرد نیست. به عنوان مثال، می‌توان از آن برای راه‌اندازی وظیفه‌ای برای دریافت اطلاعات از کاربر استفاده کرد، به طوری که «برنامه اصلی» فعال باقی می‌ماند و کار دیگری را انجام می‌دهد.

در این متن، نویسنده به معرفی و توضیح تابع `async()` در C++ می‌پردازد و چگونگی استفاده از آن برای اجرای همزمان یا به اصطلاح *asynchronous* کارها را توضیح می‌دهد. در ادامه، به توضیح دقیق‌تر مطلب می‌پردازم.

### مفهوم کلی:
در اینجا، نویسنده می‌خواهد یک کار را به عنوان یک تابع در نظر بگیرد که می‌تواند به طور همزمان با دیگر وظایف اجرا شود. این رویکرد بسیار ساده و در عین حال قدرتمند است. به جای اینکه مستقیماً به موضوعات پیچیده مانند حافظه مشترک یا قفل‌ها (locks) فکر کنیم، کافیست که این وظایف را به عنوان وظایفی مستقل در نظر بگیریم که ممکن است به طور همزمان اجرا شوند.

### معرفی `async()`:
تابع `async()` در C++ برای اجرای کارها به صورت همزمان یا *asynchronous* به کار می‌رود. به عبارت ساده‌تر، این تابع به شما امکان می‌دهد که یک وظیفه را در پس‌زمینه اجرا کنید، در حالی که برنامه همچنان در حال انجام کارهای دیگر است.

در کد ارائه‌شده، فرض بر این است که یک وکتور `v` با مقادیر عددی وجود دارد. در اینجا، هدف این است که مجموع مقادیر این وکتور محاسبه شود. اگر اندازه وکتور کوچک باشد (کمتر از 10000)، نتیجه به طور معمول محاسبه می‌شود. اما اگر اندازه وکتور بزرگ باشد، این کار به چهار بخش تقسیم می‌شود و هر بخش به طور همزمان (با استفاده از `async()`) محاسبه می‌شود.

### جزئیات کد:
```cpp
double comp4(vector<double>& v) {
    if (v.size() < 10000) return accum(v.begin(), v.end(), 0.0);
    
    auto v0 = &v[0];
    auto sz = v.size();
    
    // استفاده از async برای محاسبه چهار بخش مختلف
    auto f0 = async(accum, v0, v0 + sz / 4, 0.0); // بخش اول
    auto f1 = async(accum, v0 + sz / 4, v0 + sz / 2, 0.0); // بخش دوم
    auto f2 = async(accum, v0 + sz / 2, v0 + sz * 3 / 4, 0.0); // بخش سوم
    auto f3 = async(accum, v0 + sz * 3 / 4, v0 + sz, 0.0); // بخش چهارم
    
    // جمع‌بندی نتایج
    return f0.get() + f1.get() + f2.get() + f3.get();
}
```

### توضیحات بیشتر:
- `async()` وظیفه تقسیم و محاسبه مقادیر وکتور را به طور همزمان انجام می‌دهد. هر بخش از وکتور (به چهار قسمت تقسیم شده است) به طور همزمان در یک یا چند نخ (thread) مختلف پردازش می‌شود.
- تابع `get()` برای هر یک از وظایف (که به صورت async اجرا شده‌اند) برای دریافت نتیجه نهایی استفاده می‌شود.
- `async()` به طور خودکار وظایف را مدیریت می‌کند و تعداد نخ‌ها را بسته به منابع سیستم (مانند تعداد هسته‌های پردازنده) انتخاب می‌کند.

### محدودیت‌ها:
- `async()` بیشتر برای کارهایی مناسب است که نیازی به اشتراک‌گذاری منابع (مثل حافظه) بین نخ‌ها نداشته باشند. چرا که در صورتی که چند وظیفه نیاز به استفاده از منابع مشترک داشته باشند، مسائل پیچیده‌تری همچون قفل‌ها (locks) به وجود می‌آید که در اینجا از آن‌ها اجتناب شده است.
- `async()` تصمیم می‌گیرد که چند نخ برای اجرای کارها استفاده شود و شما به طور مستقیم نمی‌توانید کنترل کنید که چند نخ برای اجرا انتخاب می‌شود.

### مزایای استفاده از `async()`:
- با استفاده از `async()`, نیازی نیست که مستقیماً به مدیریت نخ‌ها و قفل‌ها فکر کنید.
- تنها کافیست که وظایفی را مشخص کنید که ممکن است به صورت همزمان اجرا شوند.
- این می‌تواند برای پردازش‌های سنگین، مانند پردازش‌های داده‌های بزرگ، بسیار مفید باشد.

### نکته دیگر:
- از `async()` فقط برای کارهایی که به منابع مشترک نیازی ندارند استفاده کنید، زیرا مدیریت منابع مشترک در برنامه‌هایی که از `async()` استفاده می‌کنند، می‌تواند پیچیده باشد.

## Small Utility Components
تمام مؤلفه‌های کتابخانه استاندارد به صورت واضح و با برچسب‌های مشخص، مانند «ظرفیت‌ها» یا «ورودی/خروجی» ارائه نمی‌شوند. این بخش چند مثال از مؤلفه‌های کوچک و مفید که به طور گسترده استفاده می‌شوند را ارائه می‌دهد:
• ساعت و مدت زمان برای اندازه‌گیری زمان.
• توابع نوع، مانند iterator_traits و is_arithmetic، برای به‌دست آوردن اطلاعات در مورد انواع داده‌ها.
• جفت (pair) و تاپل (tuple) برای نمایندگی مجموعه‌های کوچک و ممکن است ناهمگن از مقادیر.
نکته اینجا این است که یک تابع یا نوع داده لزوماً نیازی به پیچیدگی یا ارتباط نزدیک با مجموعه‌ای از توابع و انواع دیگر ندارد تا مفید واقع شود. این مؤلفه‌های کتابخانه بیشتر به عنوان بلوک‌های ساخت برای تسهیلات کتابخانه‌ای قدرتمندتر عمل می‌کنند، از جمله سایر مؤلفه‌های کتابخانه استاندارد.

## Time
کتابخانه استاندارد امکاناتی برای کار با زمان فراهم می‌کند. به عنوان مثال، این روش پایه‌ای برای اندازه‌گیری زمان است:

```cpp
using namespace std::chrono; // مشاهده §35.2
auto t0 = high_resolution_clock::now();
do_work();
auto t1 = high_resolution_clock::now();
cout << duration_cast<milliseconds>(t1−t0).count() << "msec\n";
```

ساعت زمان یک **time_point** (نقطه‌ای از زمان) را برمی‌گرداند. کم کردن دو **time_point** از هم، یک **duration** (مدت زمان) را به شما می‌دهد. ساعت‌های مختلف نتایج خود را در واحدهای مختلف زمان می‌دهند (ساعتی که من استفاده کرده‌ام، نانوثانیه را اندازه‌گیری می‌کند)، بنابراین معمولاً ایده خوبی است که مدت زمان را به یک واحد شناخته‌شده تبدیل کنید. این همان کاری است که `duration_cast` انجام می‌دهد.

امکانات کتابخانه استاندارد برای کار با زمان در زیربخش `std::chrono` در هدر `<chrono>` پیدا می‌شود (§35.2).

در مورد «کارایی» کد اظهار نظر نکنید مگر اینکه ابتدا اندازه‌گیری‌های زمانی انجام داده باشید. حدس‌های مربوط به عملکرد کد معمولاً غیرقابل اعتماد هستند.

## Type Functions
یک تابع نوع (type function) تابعی است که در زمان کامپایل با توجه به یک نوع به عنوان آرگومان یا بازگشت نوع، ارزیابی می‌شود. کتابخانه استاندارد انواع مختلفی از توابع نوع را برای کمک به پیاده‌سازی‌کنندگان کتابخانه و برنامه‌نویسان به طور کلی فراهم کرده است تا کدی بنویسند که از جنبه‌های زبان، کتابخانه استاندارد و کد به طور کلی بهره‌برداری کند.

برای انواع عددی، `numeric_limits` از هدر `<limits>` اطلاعات مفید مختلفی را ارائه می‌دهد (§5.6.5). برای مثال:

```cpp
constexpr float min = numeric_limits<float>::min(); // کوچکترین عدد مثبت float (§40.2)
```

به طور مشابه، اندازه اشیاء می‌تواند توسط عملگر داخلی `sizeof` پیدا شود (§2.2.2). برای مثال:

```cpp
constexpr int szi = sizeof(int); // تعداد بایت‌های یک int
```

این توابع نوع بخشی از مکانیزم‌های C++ برای محاسبات در زمان کامپایل هستند که امکان بررسی دقیق‌تر نوع و عملکرد بهتر را فراهم می‌کنند، چیزی که در غیر این صورت امکان‌پذیر نبود. استفاده از چنین ویژگی‌هایی اغلب به نام برنامه‌نویسی متا (metaprogramming) یا (زمانی که الگوها (templates) دخیل هستند) برنامه‌نویسی متا الگو (template metaprogramming) شناخته می‌شود (فصل 28). در اینجا، من تنها دو ویژگی که توسط کتابخانه استاندارد فراهم شده‌اند را معرفی می‌کنم: `iterator_traits` (§5.4.2.1) و `type predicates` (§5.4.2.2).

## iterator_traits
تابع `sort()` در کتابخانه استاندارد یک جفت از تکرارگرها (iterators) را می‌گیرد که باید یک دنباله را تعریف کنند (§4.5). علاوه بر این، آن تکرارگرها باید دسترسی تصادفی به آن دنباله را فراهم کنند، یعنی باید تکرارگرهای **دسترسی تصادفی** (random-access iterators) باشند. برخی از کانتینرها مانند `forward_list` این امکان را فراهم نمی‌کنند. به‌ویژه، یک `forward_list` یک لیست پیوندی یک‌طرفه است که در آن استفاده از اندیس‌گذاری هزینه‌بر خواهد بود و هیچ روش معقولی برای ارجاع به یک عنصر قبلی وجود ندارد. با این حال، مانند بیشتر کانتینرها، `forward_list` تکرارگرهای **جلوبرنده** (forward iterators) را ارائه می‌دهد که می‌توان از آن‌ها برای پیمایش دنباله با استفاده از الگوریتم‌ها و دستورات `for` استفاده کرد (§33.1.1).

کتابخانه استاندارد یک مکانیزم به نام `iterator_traits` فراهم می‌کند که به ما این امکان را می‌دهد که بررسی کنیم چه نوع تکرارگری پشتیبانی می‌شود. با توجه به این، می‌توانیم تابع `sort()` برای دنباله‌ها را از §4.5.6 به‌طور بهتری توسعه دهیم تا هم `vector` و هم `forward_list` را بپذیرد. برای مثال:

```cpp
void test(vector<string>& v, forward_list<int>& lst)
{
    sort(v); // مرتب‌سازی وکتور
    sort(lst); // مرتب‌سازی لیست پیوندی یک‌طرفه
}
```

تکنیک‌هایی که برای انجام این کار نیاز است معمولاً مفید هستند. ابتدا، من دو تابع کمکی می‌نویسم که یک آرگومان اضافی می‌گیرند که نشان می‌دهد آیا قرار است برای تکرارگرهای دسترسی تصادفی یا تکرارگرهای جلوبرنده استفاده شوند. نسخه‌ای که تکرارگرهای دسترسی تصادفی را می‌گیرد، ساده است:

```cpp
template<typename Ran> // برای تکرارگرهای دسترسی تصادفی
void sort_helper(Ran beg, Ran end, random_access_iterator_tag) // می‌توانیم از [beg:end) اندیس‌گذاری کنیم
{
    sort(beg,end); // فقط آن را مرتب می‌کنیم
}
```

نسخه‌ای که برای تکرارگرهای جلوبرنده است تقریباً به همین سادگی است؛ فقط لیست را به یک وکتور کپی می‌کنیم، مرتب می‌کنیم و دوباره کپی می‌کنیم:

```cpp
template<typename For> // برای تکرارگرهای جلوبرنده
void sort_helper(For beg, For end, forward_iterator_tag) // می‌توانیم از [beg:end) عبور کنیم
{
    vector<decltype(*beg)> v {beg,end}; // یک وکتور از [beg:end) ایجاد می‌کنیم
    sort(v.begin(),v.end());
    copy(v.begin(),v.end(),beg); // عناصر را دوباره کپی می‌کنیم
}
```

`decltype()` یک تابع نوع داخلی است که نوع اعلام‌شده آرگومان خود را برمی‌گرداند (§6.3.6.3). بنابراین، `v` یک وکتور از نوع `X` است که `X` نوع عنصر دنباله ورودی است.

جادوی واقعی "نوع" در انتخاب توابع کمکی است:

```cpp
template<typename C>
void sort(C& c)
{
    using Iter = Iterator_type<C>;
    sort_helper(c.begin(),c.end(),Iterator_category<Iter>{});
}
```

در اینجا، من از دو تابع نوع استفاده می‌کنم: `Iterator_type<C>` نوع تکرارگر `C` را برمی‌گرداند (یعنی `C::iterator`) و سپس `Iterator_category<Iter>{}` یک مقدار "برچسب" می‌سازد که نوع تکرارگری که فراهم شده را نشان می‌دهد:
- `std::random_access_iterator_tag` اگر تکرارگر `C` دسترسی تصادفی را پشتیبانی کند.
- `std::forward_iterator_tag` اگر تکرارگر `C` تنها پیمایش جلو را پشتیبانی کند.

با توجه به این، می‌توانیم بین دو الگوریتم مرتب‌سازی در زمان کامپایل انتخاب کنیم. این تکنیک که به آن **ارسال برچسب** (tag dispatch) گفته می‌شود، یکی از تکنیک‌هایی است که در کتابخانه استاندارد و جاهای دیگر برای بهبود انعطاف‌پذیری و عملکرد استفاده می‌شود.

پشتیبانی کتابخانه استاندارد برای تکنیک‌های استفاده از تکرارگرها، مانند ارسال برچسب، در قالب یک الگوی کلاس ساده به نام `iterator_traits` از هدر `<iterator>` (§33.1.3) ارائه شده است. این امکان را فراهم می‌کند تا توابع نوع مورد استفاده در `sort()` به سادگی تعریف شوند:

```cpp
template<typename C>
using Iterator_type = typename C::iterator; // نوع تکرارگر C
template<typename Iter>
using Iterator_category = typename std::iterator_traits<Iter>::iterator_category; // دسته‌بندی Iter
```

اگر نمی‌خواهید بدانید چه نوع "جادوی نوع در زمان کامپایل" برای فراهم کردن ویژگی‌های کتابخانه استاندارد استفاده شده است، می‌توانید از امکاناتی مانند `iterator_traits` صرف‌نظر کنید. اما در این صورت، قادر نخواهید بود از تکنیک‌هایی که آن‌ها پشتیبانی می‌کنند برای بهبود کد خود استفاده کنید.

---

این متن به بررسی نحوه استفاده از **تابع sort()** در کتابخانه استاندارد C++ و نحوه انجام بهینه‌سازی‌های مختلف در استفاده از آن برای انواع مختلف تکرارگرها (iterators) می‌پردازد. در ادامه، توضیح دقیق و ساده‌تری از مفاهیم بیان‌شده در متن می‌دهم.

### هدف کلی:
کتابخانه استاندارد C++ تابع `sort()` را برای مرتب‌سازی دنباله‌ای از داده‌ها فراهم می‌کند. این تابع دو **تکرارگر** (iterators) می‌گیرد که محدوده‌ای از داده‌ها را مشخص می‌کنند. این تکرارگرها باید از نوع **دسترسی تصادفی** (random-access) باشند. به این معنی که می‌توان به راحتی به هر عنصر از دنباله با استفاده از اندیس‌گذاری دسترسی پیدا کرد.

اما برخی از کانتینرها، مانند `forward_list`، این امکان را ندارند. چرا؟ چون `forward_list` یک **لیست پیوندی یک‌طرفه** است که نمی‌توان به راحتی به عناصر قبلی دسترسی پیدا کرد و نمی‌توان از اندیس‌گذاری استفاده کرد. این به این معنی است که برای استفاده از `sort()` باید راه‌حل‌هایی پیدا کنیم.

### راه‌حل:
برای حل این مشکل، کتابخانه استاندارد C++ از **تکنیک‌های برنامه‌نویسی متا** (Metaprogramming) و **برچسب‌های نوع** (Type Tags) استفاده می‌کند. هدف این است که با توجه به نوع تکرارگر، به‌طور خودکار تصمیم بگیریم که از کدام روش مرتب‌سازی استفاده کنیم.

#### 1. **تفاوت تکرارگرها**:
- **تکرارگرهای دسترسی تصادفی** (مثل تکرارگرهای `vector`) امکان دسترسی به هر عنصر با استفاده از اندیس‌گذاری را می‌دهند.
- **تکرارگرهای جلوبرنده** (مثل تکرارگرهای `forward_list`) فقط می‌توانند دنباله را به جلو پیمایش کنند و از اندیس‌گذاری پشتیبانی نمی‌کنند.

#### 2. **تابع کمکی برای تکرارگرهای دسترسی تصادفی**:
برای دنباله‌هایی که از تکرارگرهای دسترسی تصادفی استفاده می‌کنند، می‌توانیم از مرتب‌سازی ساده استفاده کنیم:

```cpp
template<typename Ran>  // برای تکرارگرهای دسترسی تصادفی
void sort_helper(Ran beg, Ran end, random_access_iterator_tag) {
    sort(beg, end);  // مرتب‌سازی دنباله با sort استاندارد
}
```

این تابع بسیار ساده است. چون می‌توانیم به هر عنصر دنباله دسترسی تصادفی داشته باشیم، کافی است از `sort()` استفاده کنیم تا دنباله مرتب شود.

#### 3. **تابع کمکی برای تکرارگرهای جلوبرنده**:
برای دنباله‌هایی که از تکرارگرهای جلوبرنده استفاده می‌کنند (مثل `forward_list`)، چون نمی‌توان از اندیس‌گذاری استفاده کرد، باید یک راه‌حل دیگر پیدا کنیم: ابتدا دنباله را به یک **وکتور** تبدیل می‌کنیم، سپس آن را مرتب کرده و دوباره به دنباله اصلی کپی می‌کنیم:

```cpp
template<typename For>  // برای تکرارگرهای جلوبرنده
void sort_helper(For beg, For end, forward_iterator_tag) {
    vector<decltype(*beg)> v {beg, end};  // تبدیل به وکتور
    sort(v.begin(), v.end());  // مرتب‌سازی وکتور
    copy(v.begin(), v.end(), beg);  // کپی کردن به دنباله اصلی
}
```

در اینجا، از تابع `decltype()` برای تعیین نوع داده استفاده می‌کنیم و دنباله را به وکتور تبدیل می‌کنیم، سپس مرتب می‌کنیم و دوباره آن را به دنباله اصلی کپی می‌کنیم.

#### 4. **انتخاب مناسب‌ترین تابع بر اساس نوع تکرارگر**:
برای اینکه به‌طور خودکار تابع مناسب برای هر نوع تکرارگر انتخاب شود، از ویژگی‌های **نوع** در C++ استفاده می‌کنیم:

```cpp
template<typename C>
void sort(C& c) {
    using Iter = Iterator_type<C>;  // نوع تکرارگر C
    sort_helper(c.begin(), c.end(), Iterator_category<Iter>{});
}
```

در اینجا:
- **`Iterator_type<C>`** نوع تکرارگر کانتینر `C` را مشخص می‌کند (مثل `C::iterator`).
- **`Iterator_category<Iter>`** نوع تکرارگر را شناسایی می‌کند و به‌طور خودکار برچسب مربوط به آن را به تابع کمکی ارسال می‌کند.

#### 5. **برچسب‌های نوع (Tag Dispatch)**:
از آنجا که تکرارگرها ممکن است دسترسی تصادفی یا جلوبرنده داشته باشند، برای انتخاب تابع مناسب در زمان کامپایل از **برچسب‌های نوع** استفاده می‌کنیم. این برچسب‌ها عبارتند از:
- `random_access_iterator_tag` برای تکرارگرهای دسترسی تصادفی
- `forward_iterator_tag` برای تکرارگرهای جلوبرنده

این برچسب‌ها به‌طور خودکار انتخاب می‌شوند و به تابع کمکی ارسال می‌شوند تا مرتب‌سازی مناسب انجام شود.

#### 6. **استفاده از `iterator_traits`**:
کتابخانه استاندارد C++ این امکان را فراهم کرده است که بتوانیم نوع تکرارگر و دسته‌بندی آن را شناسایی کنیم. این کار توسط `iterator_traits` انجام می‌شود که یک قالب کلاس ساده از هدر `<iterator>` است:

```cpp
template<typename C>
using Iterator_type = typename C::iterator;  // نوع تکرارگر C
template<typename Iter>
using Iterator_category = typename std::iterator_traits<Iter>::iterator_category;  // دسته‌بندی تکرارگر
```

این کدها به‌طور خودکار نوع تکرارگر و دسته‌بندی آن را شناسایی می‌کنند و بر اساس آن مرتب‌سازی مناسب را انتخاب می‌کنند.

### نتیجه:
با استفاده از این تکنیک‌ها، کد ما قادر است به‌طور خودکار نوع تکرارگر را شناسایی کرده و از مرتب‌سازی بهینه برای آن استفاده کند. این تکنیک‌ها به برنامه‌نویسان این امکان را می‌دهند که کد خود را به‌گونه‌ای بنویسند که هم برای تکرارگرهای دسترسی تصادفی و هم برای تکرارگرهای جلوبرنده بهینه باشد.

این روش **برنامه‌نویسی متا** یا **Meta-programming** نامیده می‌شود، زیرا تصمیمات در زمان کامپایل گرفته می‌شوند، نه در زمان اجرا. این تکنیک به بهینه‌سازی عملکرد و افزایش انعطاف‌پذیری کد کمک می‌کند.

## Type Predicates
یک پیش‌شرط نوع کتابخانه استاندارد یک تابع نوع ساده است که به یک سوال بنیادی در مورد انواع پاسخ می‌دهد. به عنوان مثال:
```cpp
bool b1 = Is_arithmetic<int>(); // بله، int یک نوع حسابی است
bool b2 = Is_arithmetic<string>(); // نه، std::string یک نوع حسابی نیست
```
این پیش‌شرط‌ها در `<type_traits>` یافت می‌شوند و در §35.4.1 توصیف شده‌اند. سایر مثال‌ها شامل `is_class`، `is_pod`، `is_literal_type`، `has_virtual_destructor` و `is_base_of` هستند. این‌ها زمانی که ما تمپلت می‌نویسیم، بسیار مفید هستند. به عنوان مثال:
```cpp
template<typename Scalar>
class complex {
    Scalar re, im;
public:
    static_assert(Is_arithmetic<Scalar>(), "متاسفم، من فقط از پیچیده‌هایی از انواع حسابی پشتیبانی می‌کنم");
    // ...
};
```
برای بهبود خوانایی نسبت به استفاده مستقیم از کتابخانه استاندارد، من یک تابع نوع تعریف کرده‌ام:
```cpp
template<typename T>
constexpr bool Is_arithmetic()
{
    return std::is_arithmetic<T>::value;
}
```
برنامه‌های قدیمی از `::value` به طور مستقیم به جای `()` استفاده می‌کنند، اما من این کار را نسبتاً زشت می‌دانم و جزئیات پیاده‌سازی را افشا می‌کند.

## pair and tuple
گاهی اوقات نیاز داریم به داده‌هایی که صرفاً داده هستند؛ یعنی مجموعه‌ای از مقادیر، نه یک شیء از یک کلاس با معنای مشخص و قوانین خاصی که باید در مورد مقدار آن رعایت شود (بخش‌های 2.4.3.2 و 13.4). در چنین مواردی، می‌توانیم یک ساختار ساده با مجموعه‌ای از اعضای به‌طور مناسب نام‌گذاری شده تعریف کنیم. به‌عنوان مثال، الگوریتم استاندارد `equal_range` (§32.6.1) یک جفت از ایتراتورها را برمی‌گرداند که زیرترتیب (subsequence) مطابق با یک شرط را مشخص می‌کند:

```cpp
template<typename Forward_iterator, typename T, typename Compare>
pair<Forward_iterator, Forward_iterator>
equal_range(Forward_iterator first, Forward_iterator last, const T& val, Compare cmp);
```

با توجه به یک توالی مرتب [first:last)، `equal_range()` جفتی را برمی‌گرداند که زیرترتیب مطابق با شرط `cmp` را نشان می‌دهد. می‌توانیم از این برای جستجو در یک توالی مرتب از `Record`ها استفاده کنیم:

```cpp
auto rec_eq = [](const Record& r1, const Record& r2) { return r1.name < r2.name; };  // مقایسه نام‌ها

void f(const vector<Record>& v)  // فرض می‌شود که v بر اساس فیلد "name" مرتب شده است
{
    auto er = equal_range(v.begin(), v.end(), Record{"Reg"}, rec_eq);
    for (auto p = er.first; p != er.second; ++p)  // چاپ تمام رکوردهای برابر
        cout << *p;  // فرض می‌شود که << برای Record تعریف شده است
}
```

اولین عضو یک جفت به نام `first` و دومین عضو به نام `second` خوانده می‌شود. این نام‌گذاری‌ها ممکن است ابتدا کمی عجیب به نظر برسند، اما چنین نام‌گذاری‌های یکنواختی هنگام نوشتن کدهای عمومی (generic code) بسیار مفید است.

جفت استاندارد (pair) از کتابخانه استاندارد (<utility>) به‌طور مکرر در کتابخانه استاندارد و در جاهای دیگر استفاده می‌شود. یک جفت، عملگرهایی مانند `=`, `==`, و `<` را فراهم می‌کند، اگر عناصر آن نیز این عملگرها را داشته باشند. تابع `make_pair()` این امکان را فراهم می‌کند که بدون ذکر نوع آن، یک جفت بسازیم (§34.2.4.1). برای مثال:

```cpp
void f(vector<string>& v)
{
    auto pp = make_pair(v.begin(), 2);  // pp یک جفت از نوع pair<vector<string>::iterator, int> است
    // ...
}
```

اگر نیاز به بیش از دو عنصر (یا کمتر) داشته باشید، می‌توانید از `tuple` (از <utility>; §34.2.4.2) استفاده کنید. یک `tuple` یک دنباله ناهمگن از عناصر است؛ برای مثال:

```cpp
tuple<string, int, double> t2("Sild", 123, 3.14);  // نوع به‌طور صریح مشخص شده است
auto t = make_tuple(string("Herring"), 10, 1.23);  // نوع به‌طور خودکار استنباط می‌شود
// t یک tuple<string, int, double> است
string s = get<0>(t);  // گرفتن اولین عنصر tuple
int x = get<1>(t);
double d = get<2>(t);
```

عناصر یک `tuple` شماره‌گذاری می‌شوند (از صفر شروع می‌شود)، نه اینکه مانند عناصر جفت‌ها (pairs) نام‌گذاری شوند. برای انتخاب عناصر در زمان کامپایل، باید متأسفانه از دستور `get<1>(t)` استفاده کنم، نه `get(t,1)` یا `t[1]` (§28.5.2).

مانند جفت‌ها، `tuple`ها نیز می‌توانند نسبت به یکدیگر تخصیص داده شوند و مقایسه شوند، اگر عناصر آن‌ها نیز این ویژگی‌ها را داشته باشند.

یک جفت در رابط‌ها (interfaces) رایج است زیرا اغلب نیاز داریم بیش از یک مقدار را بازگردانیم، مانند یک نتیجه و شاخصی از کیفیت آن نتیجه. نیاز به سه یا بیشتر بخش در نتیجه کمتر رایج است، بنابراین `tuple`ها بیشتر در پیاده‌سازی الگوریتم‌های عمومی (generic algorithms) یافت می‌شوند.

---

در این متن، صحبت از استفاده از ساختارهای داده‌ای مانند `pair` و `tuple` در زبان برنامه‌نویسی C++ می‌شود که برای ذخیره‌سازی مقادیر مختلف و کار با آن‌ها استفاده می‌شوند. این ساختارها معمولاً در مواقعی کاربرد دارند که نیاز داریم بیش از یک مقدار را در کنار هم ذخیره کنیم و به‌راحتی به این مقادیر دسترسی داشته باشیم. به طور خاص، متن درباره‌ی عملکرد و نحوه‌ی استفاده از این ساختارها توضیح می‌دهد.

### 1. **نیاز به داده‌ها به‌عنوان داده ساده**
ابتدا اشاره می‌شود که گاهی اوقات نیاز به داده‌هایی داریم که صرفاً مقادیر هستند، نه اشیاء با ویژگی‌ها و رفتارهای پیچیده. برای این کار می‌توانیم از ساختارهای ساده‌ای مانند `struct` استفاده کنیم، اما در بسیاری از موارد، کتابخانه استاندارد C++ این امکان را فراهم می‌کند که به‌جای نوشتن تعریف‌های پیچیده، خود ساختارها را ایجاد کنیم.

### 2. **الگوریتم `equal_range`**
در اینجا، الگوریتم `equal_range` که یکی از الگوریتم‌های استاندارد C++ است، معرفی می‌شود. این الگوریتم یک جفت از ایتراتورها (ترکیب دو نشانگر در یک مجموعه) برمی‌گرداند که نشان‌دهنده‌ی زیرترتیب (subsequence) از یک توالی مرتب است که با یک مقدار خاص مطابقت دارد.

```cpp
template<typename Forward_iterator, typename T, typename Compare>
pair<Forward_iterator, Forward_iterator>
equal_range(Forward_iterator first, Forward_iterator last, const T& val, Compare cmp);
```

در این الگوریتم، فرض بر این است که یک توالی مرتب داریم (بین `first` و `last`) و می‌خواهیم جفت ایتراتورهایی را پیدا کنیم که محدوده‌ای از مقادیر را نشان دهند که مطابق با شرط `cmp` باشند.

در ادامه، یک مثال آورده می‌شود که نشان می‌دهد چگونه می‌توان از `equal_range` برای جستجوی رکوردهایی که نامشان با مقداری خاص شروع می‌شود استفاده کرد. در اینجا، مقایسه بر اساس نام رکوردها انجام می‌شود.

### 3. **نام‌گذاری در جفت‌ها (Pair)**
در `pair`های استاندارد، دو عضو به‌طور پیش‌فرض با نام‌های `first` و `second` نام‌گذاری می‌شوند. این نام‌گذاری شاید در ابتدا کمی عجیب به نظر برسد، اما این یکنواختی در نام‌گذاری بسیار مفید است و باعث می‌شود که کدهای عمومی (generic code) به راحتی نوشته شوند. این ویژگی به برنامه‌نویسان کمک می‌کند تا در شرایط مختلف به‌راحتی از جفت‌ها استفاده کنند.

### 4. **ساخت جفت‌ها با `make_pair()`**
برای ایجاد یک جفت بدون ذکر صریح نوع آن، می‌توان از تابع `make_pair()` استفاده کرد. این تابع به شما اجازه می‌دهد بدون اینکه نوع جفت را مشخص کنید، به‌طور خودکار جفتی با انواع مشخص بسازید.

```cpp
auto pp = make_pair(v.begin(), 2);
```

در اینجا، نوع جفت به‌طور خودکار از مقادیر داده‌شده (ایتراتور و عدد صحیح) استنباط می‌شود.

### 5. **استفاده از `tuple`**
اگر نیاز به ذخیره‌سازی بیش از دو مقدار داشته باشیم، می‌توانیم از `tuple` استفاده کنیم که یک دنباله ناهمگن از انواع مختلف داده است. برای مثال، یک `tuple` می‌تواند شامل یک رشته، یک عدد صحیح و یک عدد اعشاری باشد.

```cpp
tuple<string, int, double> t2("Sild", 123, 3.14);
```

همچنین، می‌توان از `make_tuple` استفاده کرد که نوع‌ها را به‌طور خودکار استنباط می‌کند:

```cpp
auto t = make_tuple("Herring", 10, 1.23);
```

برای دسترسی به هر عنصر از `tuple` باید از تابع `get` استفاده کرد و به‌طور مشخص شماره اندیس عنصر مورد نظر را ذکر کرد (برای مثال `get<0>(t)` برای دریافت اولین عنصر).

### 6. **مقایسه و تخصیص `pair` و `tuple`**
جفت‌ها و `tuple`ها می‌توانند به یکدیگر تخصیص داده شوند و مقایسه شوند، به شرطی که عناصر آنها این ویژگی‌ها را داشته باشند. این قابلیت برای کار با داده‌های ترکیبی بسیار مفید است.

### 7. **استفاده رایج از `pair` و `tuple`**
- **جفت‌ها (`pair`)** معمولاً در رابط‌ها (interfaces) استفاده می‌شوند، زیرا اغلب نیاز داریم که بیش از یک نتیجه را به تابع بازگردانیم، مانند نتیجه و شاخص کیفیت آن. برای مثال، ممکن است بخواهیم نتیجه یک جستجو را به‌همراه وضعیت موفقیت آن بازگردانیم.
- **توپل‌ها (`tuple`)** زمانی که نیاز به ذخیره‌سازی بیش از دو مقدار باشد، معمولاً در پیاده‌سازی‌های داخلی الگوریتم‌ها به‌کار می‌روند.

### نتیجه‌گیری:
در این متن به طور کلی توضیح داده شده که چگونه می‌توان از ساختارهای `pair` و `tuple` در C++ برای ذخیره‌سازی مجموعه‌های مختلف از داده‌ها استفاده کرد. این ساختارها ابزارهای مفیدی برای نوشتن کدهای عمومی و الگوریتم‌های پیچیده‌تر هستند و به برنامه‌نویسان این امکان را می‌دهند که چندین مقدار را به‌طور همزمان ذخیره و مدیریت کنند.

## Regular Expressions
عبارات منظم (Regular Expressions) ابزاری قدرتمند برای پردازش متن هستند. آن‌ها روشی ساده و مختصر برای توصیف الگوهای موجود در متن فراهم می‌کنند (برای مثال، یک کد پستی در ایالات متحده مانند TX 77845 یا یک تاریخ به سبک ISO مانند 2009−06−07) و امکان یافتن این الگوها را در متن به‌صورت کارآمد فراهم می‌سازند. در کتابخانه استاندارد ++C، پشتیبانی از عبارات منظم در قالب کلاس `std::regex` و توابع پشتیبان آن ارائه شده است. 

برای آشنایی با سبک کتابخانه `regex`، بیایید یک الگو را تعریف کرده و چاپ کنیم:

```cpp
regex pat (R"(\w{2}\s∗\d{5}(−\d{4})?)"); // الگوی کد پستی: XXddddd-dddd و انواع دیگر
cout << "pattern: " << pat << '\n';
```

افرادی که قبلاً از عبارات منظم در زبان‌های مختلف استفاده کرده‌اند، با الگوی `\w{2}\s∗\d{5}(−\d{4})?` آشنا خواهند بود. این الگو مشخص می‌کند که متن باید با دو حرف (`\w{2}`) شروع شود، که ممکن است به دنبال آن یک فاصله (`\s∗`) باشد، سپس پنج عدد (`\d{5}`) و در صورت وجود، یک خط تیره و چهار عدد دیگر (`−\d{4}`) داشته باشد. اگر با عبارات منظم آشنایی ندارید، اکنون فرصت خوبی برای یادگیری آن‌هاست ([Stroustrup, 2009]، [Maddock, 2009]، [Friedl, 1997]). خلاصه‌ای از عبارات منظم در بخش §37.1.1 آمده است.

برای بیان این الگو، از یک رشته‌ی خام (raw string literal) استفاده شده است که با `R"(` شروع و با `)"` خاتمه می‌یابد. این امکان را می‌دهد که بک‌اسلش‌ها و نقل‌قول‌ها مستقیماً در رشته استفاده شوند.

ساده‌ترین راه برای استفاده از یک الگو، جستجوی آن در یک جریان (stream) است:

```cpp
int lineno = 0;
for (string line; getline(cin, line);) { // خواندن خط به خط
    ++lineno;
    smatch matches; // ذخیره‌ی رشته‌های مطابق با الگو
    if (regex_search(line, matches, pat)) // جستجو برای pat در line
        cout << lineno << ": " << matches[0] << '\n';
}
```

تابع `regex_search(line, matches, pat)` در `line` به دنبال هر تطابقی با الگوی `pat` می‌گردد و در صورت یافتن تطابق، آن را در `matches` ذخیره می‌کند. اگر هیچ تطابقی پیدا نشود، این تابع مقدار `false` را برمی‌گرداند.

متغیر `matches` از نوع `smatch` است. حرف «s» در `smatch` مخفف «sub» (زیرمجموعه) است و `smatch` در واقع یک بردار از زیربخش‌های مطابقت یافته است. عنصر اول، یعنی `matches[0]`، کل تطابق را دربرمی‌گیرد.

برای توضیحات جامع‌تر، به فصل ۳۷ مراجعه کنید.

## Math
++C به طور اولیه برای محاسبات عددی طراحی نشده است. با این حال، این زبان به طور گسترده برای محاسبات عددی مورد استفاده قرار می‌گیرد و کتابخانه استاندارد آن نیز این موضوع را منعکس می‌کند.

## Mathematical Functions and Algorithms
در کتابخانه `<cmath>`، "توابع ریاضی معمولی" مانند `sqrt()`، `log()` و `sin()` را برای انواع `float`، `double` و `long double` می‌یابیم (§40.3). نسخه‌هایی از این توابع که برای اعداد مختلط طراحی شده‌اند، در کتابخانه `<complex>` قرار دارند (§40.4).

در کتابخانه `<numeric>`، مجموعه‌ای کوچک از الگوریتم‌های عددی عمومی مانند `accumulate()` را می‌توان یافت. برای مثال:

```cpp
void f()
{
    list<double> lst {1, 2, 3, 4, 5, 9999.99999};
    auto s = accumulate(lst.begin(), lst.end(), 0.0); // محاسبه مجموع عناصر
    cout << s << '\n'; // چاپ مقدار 10014.9999
}
```

این الگوریتم‌ها برای هر دنباله‌ی استاندارد کتابخانه قابل استفاده هستند و می‌توان عملیات موردنظر را به عنوان آرگومان به آن‌ها ارائه کرد (§40.6).

## Complex Numbers
کتابخانه استاندارد از یک مجموعه از انواع اعداد مختلط پشتیبانی می‌کند که مشابه کلاس `complex` توصیف‌شده در بخش §2.3 است. برای پشتیبانی از اعداد مختلط که مقدارهای عددی آن‌ها از نوع **float** (اعداد اعشاری با دقت تک‌گانه)، **double** (اعداد اعشاری با دقت دوگانه) و ... هستند، کلاس `complex` در کتابخانه استاندارد به‌صورت یک **الگوی (template)** تعریف شده است:

```cpp
template<typename Scalar>
class complex {
public:
    complex(const Scalar& re = {}, const Scalar& im = {});
    // ...
};
```

عملیات معمول ریاضی و رایج‌ترین توابع ریاضی برای اعداد مختلط پشتیبانی می‌شوند. برای مثال:

```cpp
void f(complex<float> fl, complex<double> db)
{
    complex<long double> ld {fl + sqrt(db)};
    db += fl * 3;
    fl = pow(1 / fl, 2);
    // ...
}
```

توابع `sqrt()` (ریشه دوم) و `pow()` (توان) از جمله توابع ریاضی متداولی هستند که در `<complex>` تعریف شده‌اند. برای اطلاعات بیشتر، به بخش **§40.4** مراجعه کنید.

## Random Numbers
اعداد تصادفی در زمینه‌های مختلفی مفید هستند، از جمله **تست نرم‌افزار، بازی‌ها، شبیه‌سازی و امنیت**. تنوع کاربردها در مجموعه گسترده‌ای از **مولدهای اعداد تصادفی** که در کتابخانه استاندارد `<random>` ارائه شده است، منعکس شده است.

یک **مولد عدد تصادفی** از دو بخش تشکیل شده است:
1. **یک موتور (Engine)** که دنباله‌ای از مقادیر تصادفی یا شبه‌تصادفی تولید می‌کند.
2. **یک توزیع (Distribution)** که این مقادیر را به یک **توزیع ریاضی** در یک دامنه خاص نگاشت می‌کند.

نمونه‌هایی از توزیع‌های متداول شامل موارد زیر هستند:
- `uniform_int_distribution` → همه اعداد صحیح در دامنه‌ی مشخص، احتمال یکسانی برای انتخاب شدن دارند.
- `normal_distribution` → توزیع نرمال (منحنی زنگی).
- `exponential_distribution` → توزیع نمایی (رشد نمایی).

### **مثال: تولید عدد تصادفی بین ۱ تا ۶**
```cpp
using my_engine = default_random_engine; // نوع موتور تصادفی
using my_distribution = uniform_int_distribution<>; // نوع توزیع

my_engine re {}; // موتور تصادفی پیش‌فرض
my_distribution one_to_six {1,6}; // توزیع اعداد صحیح بین 1 تا 6

auto die = bind(one_to_six, re); // ایجاد یک تابع برای تولید عدد تصادفی
int x = die(); // پرتاب تاس: مقدار x بین [1,6] قرار می‌گیرد
```

تابع `bind()` یک **شیء تابعی (Function Object)** ایجاد می‌کند که اجرای آن، مقدار تصادفی را بر اساس توزیع مشخص تولید می‌کند. در اینجا، `die()` در واقع همان `one_to_six(re)` را اجرا می‌کند.

### **روش ساده‌تر برای تعریف تابع تولید عدد تصادفی**
به جای استفاده از `using`، می‌توان مستقیماً این عبارت را نوشت:

```cpp
auto die = bind(uniform_int_distribution<>{1,6}, default_random_engine{});
```

انتخاب بین این دو روش، **بسته به زمینه و خواننده‌ی کد متفاوت خواهد بود**.

---

### **ساخت یک کلاس برای تولید اعداد تصادفی**
برای ساده‌تر کردن کار، می‌توانیم یک کلاس `Rand_int` ایجاد کنیم که تولید اعداد تصادفی را در محدوده مشخص مدیریت کند:

```cpp
class Rand_int {
public:
    Rand_int(int low, int high) : dist{low, high} { }
    int operator()() { return dist(re); } // تولید یک عدد تصادفی
private:
    default_random_engine re; // موتور تصادفی
    uniform_int_distribution<> dist; // توزیع اعداد تصادفی
};
```

### **استفاده از کلاس `Rand_int`**
```cpp
int main()
{
    Rand_int rnd {0,4}; // تولید‌کننده اعداد تصادفی بین 0 تا 4
    vector<int> histogram(5); // برداری برای نگهداری فراوانی اعداد

    for (int i = 0; i != 200; ++i)
        ++histogram[rnd()]; // پر کردن هیستوگرام با تعداد وقوع هر عدد

    // رسم نمودار ستونی ساده با استفاده از کاراکتر '*'
    for (int i = 0; i != histogram.size(); ++i) {
        cout << i << '\t';
        for (int j = 0; j != histogram[i]; ++j) cout << '*';
        cout << endl;
    }
}
```

### **خروجی نمونه‌ی برنامه:**
```
0  ****************************
1  ***************************
2  ***********************
3  ****************************
4  ****************************
```
در اینجا، **هیستوگرام فراوانی اعداد تولید شده** را نمایش می‌دهد و چون توزیع یکنواخت (`uniform`) است، همه‌ی اعداد تقریباً به یک میزان ظاهر می‌شوند.

---

### **نکته‌ی مهم**
++C یک **کتابخانه‌ی گرافیکی استاندارد** ندارد، به همین دلیل در این مثال از **"نمودار ASCII"** برای نمایش داده‌ها استفاده شده است. البته، کتابخانه‌های متن‌باز و تجاری بسیاری برای گرافیک و رابط کاربری در ++C وجود دارند، اما در این کتاب فقط از قابلیت‌های استاندارد زبان استفاده شده است.

**برای اطلاعات بیشتر درباره‌ی اعداد تصادفی، به بخش §40.7 مراجعه کنید.**

## Vector Arithmetic
کلاس **`vector`** که در بخش **§4.4.1** توضیح داده شد، به‌عنوان یک **مکانیزم عمومی برای نگهداری مقادیر** طراحی شده است. این کلاس **انعطاف‌پذیر** بوده و در معماری **ظروف (containers)، پیمایشگرها (iterators) و الگوریتم‌ها (algorithms)** به خوبی جای می‌گیرد. با این حال، **از عملیات ریاضی برداری پشتیبانی نمی‌کند**.

افزودن این عملیات به `vector` کار **آسانی** است، اما **عمومیت و انعطاف‌پذیری آن باعث می‌شود بهینه‌سازی‌های خاصی که برای محاسبات عددی جدی ضروری هستند، امکان‌پذیر نباشند**. به همین دلیل، **کتابخانه استاندارد ++C در `<valarray>` یک کلاس مشابه `vector` به نام `valarray` ارائه می‌دهد** که **کمتر عمومی اما برای بهینه‌سازی محاسبات عددی مناسب‌تر است**:

```cpp
template<typename T>
class valarray {
// ...
};
```

کلاس **`valarray`** از **عملیات ریاضی معمول** و **توابع ریاضی رایج** پشتیبانی می‌کند. برای مثال:

```cpp
void f(valarray<double>& a1, valarray<double>& a2)
{
    valarray<double> a = a1 * 3.14 + a2 / a1; // عملیات عددی: *, +, / و =
    a2 += a1 * 3.14;
    a = abs(a);
    double d = a2[7];
    // ...
}
```

برای اطلاعات بیشتر، به بخش **§40.5** مراجعه کنید. به‌طور خاص، **`valarray` از قابلیت stride access پشتیبانی می‌کند** که به **پیاده‌سازی محاسبات چندبعدی** کمک می‌کند.

---

### **کلاس `valarray` در ++C: بهینه‌سازی محاسبات عددی**
کلاس **`valarray`** که در **کتابخانه `<valarray>`** قرار دارد، برای انجام **محاسبات عددی سریع و بهینه** طراحی شده است. این کلاس شباهت زیادی به `vector` دارد، اما **بهینه‌سازی‌های بیشتری برای عملیات ریاضی و پردازش داده‌ها ارائه می‌دهد**.

---

## **۱. چرا از `valarray` استفاده کنیم؟**
در حالی که `vector<double>` برای ذخیره داده‌ها مناسب است، اما هنگام اجرای **محاسبات ریاضی سنگین**، `vector` نمی‌تواند برخی از **بهینه‌سازی‌های خاص** را انجام دهد. اینجاست که `valarray` مفید واقع می‌شود.

**ویژگی‌های کلیدی `valarray`:**
✅ **پشتیبانی داخلی از عملیات ریاضی:** می‌توان مستقیماً از **`+, -, *, /`** روی `valarray` استفاده کرد.  
✅ **اجرای سریع‌تر نسبت به `vector`:** برخی بهینه‌سازی‌های سطح پایین در `valarray` باعث افزایش کارایی در **محاسبات عددی** می‌شود.  
✅ **حمایت از عملیات برداری:** محاسباتی که در `vector` نیاز به حلقه (`for`) دارند، در `valarray` به‌طور مستقیم انجام می‌شوند.  
✅ **پشتیبانی از stride access:** این ویژگی به دسترسی مؤثر به داده‌ها در آرایه‌های چندبعدی کمک می‌کند.  

---

## **۲. نحوه‌ی تعریف و مقداردهی `valarray`**
می‌توانیم `valarray` را مانند `vector` تعریف و مقداردهی کنیم:

```cpp
#include <iostream>
#include <valarray>

using namespace std;

int main() {
    valarray<int> v1 = {1, 2, 3, 4, 5}; // مقداردهی اولیه
    valarray<double> v2(10, 5); // 5 عدد مقداردهی شده با مقدار 10.0

    // چاپ مقدار اولیه
    cout << "v1: ";
    for (int x : v1) cout << x << " ";
    cout << endl;

    cout << "v2: ";
    for (double x : v2) cout << x << " ";
    cout << endl;

    return 0;
}
```

✅ خروجی:
```
v1: 1 2 3 4 5 
v2: 10 10 10 10 10 
```

---

## **۳. انجام عملیات ریاضی روی `valarray`**
در `valarray` می‌توان **عملیات ریاضی** را مستقیماً روی کل آرایه انجام داد، بدون نیاز به حلقه `for`.

```cpp
#include <iostream>
#include <valarray>

using namespace std;

int main() {
    valarray<int> a1 = {1, 2, 3, 4, 5};
    valarray<int> a2 = {10, 20, 30, 40, 50};

    valarray<int> sum = a1 + a2; // جمع دو valarray
    valarray<int> product = a1 * 2; // ضرب در عدد ثابت
    valarray<int> division = a2 / a1; // تقسیم عناصر به‌صورت برداری

    cout << "sum: ";
    for (int x : sum) cout << x << " ";
    cout << endl;

    cout << "product: ";
    for (int x : product) cout << x << " ";
    cout << endl;

    cout << "division: ";
    for (int x : division) cout << x << " ";
    cout << endl;

    return 0;
}
```

✅ خروجی:
```
sum: 11 22 33 44 55 
product: 2 4 6 8 10 
division: 10 10 10 10 10 
```

---

## **۴. استفاده از توابع ریاضی در `valarray`**
کتابخانه `<valarray>` توابع ریاضی مختلفی مانند `sqrt()`, `abs()`, `log()`, `exp()` و ... را برای پردازش داده‌های عددی ارائه می‌دهد.

```cpp
#include <iostream>
#include <valarray>
#include <cmath>

using namespace std;

int main() {
    valarray<double> v = {4.0, 9.0, 16.0, 25.0};

    valarray<double> squareRoots = sqrt(v); // محاسبه جذر عناصر
    valarray<double> logs = log(v); // محاسبه لگاریتم طبیعی
    valarray<double> exponentials = exp(v); // تابع نمایی

    cout << "Square roots: ";
    for (double x : squareRoots) cout << x << " ";
    cout << endl;

    cout << "Logarithms: ";
    for (double x : logs) cout << x << " ";
    cout << endl;

    cout << "Exponentials: ";
    for (double x : exponentials) cout << x << " ";
    cout << endl;

    return 0;
}
```

✅ خروجی:
```
Square roots: 2 3 4 5 
Logarithms: 1.38629 2.19722 2.77259 3.21888 
Exponentials: 54.5982 8103.08 8.88611e+06 7.20049e+10 
```

---

## **۵. ویژگی `stride access` در `valarray`**
یکی از ویژگی‌های جالب `valarray` این است که می‌توان **داده‌ها را با فواصل مشخص خواند** که برای **محاسبات چندبعدی** مفید است.

```cpp
#include <iostream>
#include <valarray>

using namespace std;

int main() {
    valarray<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    valarray<int> strideValues = v[std::slice(0, 5, 2)]; // انتخاب هر مقدار دوم

    cout << "Stride access result: ";
    for (int x : strideValues) cout << x << " ";
    cout << endl;

    return 0;
}
```

✅ خروجی:
```
Stride access result: 1 3 5 7 9 
```
🔹 در این مثال، هر **عنصر دوم** از `valarray` انتخاب شده است.

---

## **۶. مقایسه `valarray` با `vector`**
ویژگی | `vector` | `valarray`
--- | --- | ---
عملیات ریاضی مستقیم | ❌ (نیاز به `for`) | ✅ (مستقیم با `+, -, *, /`)
بهینه‌سازی محاسباتی | ❌ | ✅
پشتیبانی از `stride access` | ❌ | ✅
انعطاف‌پذیری و قابلیت‌های عمومی | ✅ | ❌ (فقط برای محاسبات عددی)

**نتیجه:**  
✔ `valarray` در **محاسبات عددی سنگین و بهینه‌سازی پردازش داده‌ها** بهتر است.  
✔ `vector` برای **مدیریت داده‌های عمومی و انعطاف‌پذیری بیشتر** مناسب‌تر است.

---

## **۷. جمع‌بندی**
✅ `valarray` مشابه `vector` است اما **برای محاسبات عددی سنگین بهینه شده است**.  
✅ از **عملیات ریاضی برداری** (`+, -, *, /`) بدون نیاز به حلقه پشتیبانی می‌کند.  
✅ شامل **توابع ریاضی داخلی** (`sqrt()`, `log()`, `exp()` و ...) است.  
✅ دارای **دسترسی با فاصله (`stride access`)** برای پردازش آرایه‌های چندبعدی است.  
✅ در پردازش داده‌ها سریع‌تر از `vector` عمل می‌کند اما **انعطاف‌پذیری کمتری دارد**.  

**📌 چه زمانی از `valarray` استفاده کنیم؟**  
اگر برنامه‌ای دارید که شامل **محاسبات عددی زیاد، پردازش داده‌های بزرگ، یا محاسبات ماتریسی** است، **`valarray` گزینه بهتری نسبت به `vector` است**.

## Numeric Limits
در کتابخانه **`<limits>`**، کتابخانه استاندارد ++C کلاس‌هایی را فراهم می‌کند که ویژگی‌های انواع داده‌ی **داخلی (Built-in Types)** را توصیف می‌کنند. این ویژگی‌ها شامل **بزرگ‌ترین توان عددی یک `float`، تعداد بایت‌های یک `int` و سایر مشخصات عددی** هستند. برای اطلاعات بیشتر، به **§40.2** مراجعه کنید.

برای مثال، می‌توانیم بررسی کنیم که آیا یک `char` مقدار **امضا‌دار (signed)** دارد یا خیر:

```cpp
static_assert(numeric_limits<char>::is_signed, "unsigned characters!");
```

همچنین می‌توان بررسی کرد که آیا مقدار `100000` از بیشترین مقدار ممکن برای `int` کوچکتر است:

```cpp
static_assert(100000 < numeric_limits<int>::max(), "small ints!");
```

**نکته:**  
✅ **عبارت دوم فقط به این دلیل کار می‌کند که `numeric_limits<int>::max()` یک تابع `constexpr` است**.  
✅ توابع `constexpr` در زمان **کامپایل** مقدار خود را تعیین می‌کنند، بنابراین می‌توانند در `static_assert` استفاده شوند.
