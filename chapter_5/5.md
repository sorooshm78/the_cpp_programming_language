## Introduction
از دیدگاه یک کاربر نهایی، کتابخانه استاندارد ایده‌آل باید اجزایی را ارائه دهد که به‌طور مستقیم تقریباً هر نیازی را پشتیبانی کنند. برای یک حوزه کاربردی خاص، یک کتابخانه تجاری بزرگ می‌تواند به این ایده‌آل نزدیک شود. با این حال، این چیزی نیست که کتابخانه استاندارد C++ در تلاش برای انجام آن است. یک کتابخانه قابل مدیریت و در دسترس برای همگان نمی‌تواند همه چیز برای همه افراد باشد. در عوض، کتابخانه استاندارد C++ تلاش می‌کند اجزایی را ارائه دهد که برای اکثر افراد در اکثر حوزه‌های کاربردی مفید باشند. به عبارت دیگر، هدف این کتابخانه خدمت به تقاطع همه نیازها است، نه اتحاد آن‌ها. علاوه بر این، پشتیبانی از چند حوزه کاربردی بسیار مهم، مانند محاسبات ریاضی و پردازش متن، به مرور وارد این کتابخانه شده است.

## Resource Management
یکی از وظایف کلیدی هر برنامه غیرساده مدیریت منابع است. منبع چیزی است که باید دریافت شده و بعداً (به صورت صریح یا ضمنی) آزاد شود. مثال‌هایی از منابع شامل حافظه، قفل‌ها، سوکت‌ها، دستگیره‌های نخ (thread handles) و دستگیره‌های فایل هستند. در یک برنامه بلندمدت، آزاد نکردن یک منبع به‌موقع («نشت») می‌تواند باعث کاهش شدید کارایی و حتی منجر به یک خرابی ناگوار شود. حتی در برنامه‌های کوتاه‌مدت، نشت منابع می‌تواند مشکل‌ساز شود؛ مثلاً با ایجاد کمبود منابع، زمان اجرای برنامه به طرز چشمگیری افزایش یابد.

اجزای کتابخانه استاندارد به گونه‌ای طراحی شده‌اند که منابع را نشت ندهند. برای دستیابی به این هدف، آن‌ها به پشتیبانی پایه‌ای زبان برای مدیریت منابع با استفاده از جفت‌های سازنده/ویرانگر (constructor/destructor) تکیه می‌کنند تا اطمینان حاصل شود که یک منبع طول عمر بیشتری نسبت به شیء مسئول آن نداشته باشد. استفاده از جفت سازنده/ویرانگر در کلاس **Vector** برای مدیریت طول عمر عناصرش یک نمونه است (بخش §3.2.1.2) و تمامی کانتینرهای کتابخانه استاندارد به روش‌های مشابه پیاده‌سازی شده‌اند. مهم‌تر از همه، این روش به درستی با مدیریت خطا از طریق استثناها تعامل دارد. به‌عنوان مثال، این تکنیک در کلاس‌های قفل کتابخانه استاندارد استفاده می‌شود:

```cpp
mutex m; // برای محافظت از دسترسی به داده‌های مشترک
// ...
void f()
{
    unique_lock<mutex> lck {m}; // قفل mutex m را دریافت کن
    // ... دستکاری داده‌های مشترک ...
}
```

یک نخ (thread) تا زمانی که سازنده **lck** قفل **m** را دریافت نکند، پیش نخواهد رفت (بخش §5.3.4). ویرانگر متناظر این منبع را آزاد می‌کند. بنابراین، در این مثال، ویرانگر **unique_lock** قفل **mutex** را زمانی که کنترل از تابع **f()** خارج می‌شود (چه از طریق بازگشت، چه به‌صورت طبیعی با رسیدن به انتهای تابع، یا از طریق پرتاب استثنا) آزاد می‌کند.

این یک کاربرد از تکنیک «دریافت منبع به معنای مقداردهی اولیه است» (RAII؛ بخش‌های §3.2.1.2 و §13.3) است. این تکنیک پایه‌ای برای مدیریت ایدئال منابع در زبان C++ محسوب می‌شود. کانتینرها (مانند **vector** و **map**)، رشته (**string**)، و جریان‌های ورودی/خروجی (**iostream**) منابع خود (مانند دستگیره‌های فایل و بافرها) را به همین شیوه مدیریت می‌کنند.

## unique_ptr and shared_ptr
مثال‌هایی که تا کنون بررسی شدند، مدیریت اشیاء تعریف‌شده در یک دامنه (scope) و آزادسازی منابع آن‌ها هنگام خروج از دامنه را پوشش می‌دهند، اما در مورد اشیایی که در حافظه آزاد (free store) تخصیص داده می‌شوند چه باید کرد؟ در کتابخانه استاندارد و در هدر **<memory>**، دو «اشاره‌گر هوشمند» برای کمک به مدیریت اشیاء در حافظه آزاد ارائه شده است:  
1. **unique_ptr** برای نمایش مالکیت یکتا (§34.3.1)  
2. **shared_ptr** برای نمایش مالکیت اشتراکی (§34.3.2)  

استفاده اساسی از این «اشاره‌گرهای هوشمند» جلوگیری از نشت حافظه ناشی از برنامه‌نویسی بی‌دقت است. به عنوان مثال:

```cpp
void f(int i, int j) // X* در مقابل unique_ptr<X>
{
    X* p = new X; // تخصیص یک X جدید
    unique_ptr<X> sp {new X}; // تخصیص یک X جدید و واگذاری اشاره‌گر آن به unique_ptr
    // ...
    if (i<99) throw Z{}; // ممکن است یک استثنا پرتاب شود
    if (j<77) return; // ممکن است زودتر از تابع بازگردیم
    p->do_something(); // ممکن است یک استثنا پرتاب شود
    sp->do_something(); // ممکن است یک استثنا پرتاب شود
    // ...
    delete p; // نابود کردن *p
}
```

در اینجا، اگر **i < 99** یا **j < 77** باشد، فراموش کردیم که **p** را آزاد کنیم. از سوی دیگر، **unique_ptr** تضمین می‌کند که شیء مرتبط به درستی نابود می‌شود، صرف‌نظر از این که چگونه از تابع **f()** خارج می‌شویم (چه از طریق پرتاب استثنا، بازگشت یا رسیدن به انتهای تابع). جالب اینجاست که می‌توانستیم این مشکل را به سادگی با عدم استفاده از اشاره‌گر و **new** حل کنیم:

```cpp
void f(int i, int j) // استفاده از یک متغیر محلی
{
    X x;
    // ...
}
```

متأسفانه، استفاده بیش از حد از **new** (و همچنین اشاره‌گرها و مراجع) به نظر می‌رسد که یک مشکل رو به رشد است. با این حال، زمانی که واقعاً به معنای اشاره‌گرها نیاز دارید، **unique_ptr** مکانیزمی بسیار سبک با هیچ هزینه اضافی (از نظر فضا یا زمان) در مقایسه با استفاده صحیح از یک اشاره‌گر داخلی است. استفاده‌های بیشتر آن شامل انتقال اشیاء تخصیص‌داده‌شده در حافظه آزاد به داخل و خارج از توابع است:

```cpp
unique_ptr<X> make_X(int i) // ساخت یک X و انتقال فوری آن به unique_ptr
{
    // ... بررسی i و غیره ...
    return unique_ptr<X>{new X{i}};
}
```

یک **unique_ptr** مانند یک دسته برای یک شیء (یا آرایه) عمل می‌کند، همان‌طور که **vector** یک دسته برای دنباله‌ای از اشیاء است. هر دو طول عمر اشیاء دیگر را کنترل می‌کنند (با استفاده از RAII) و هر دو برای ساده و کارآمد کردن بازگشت، به مفاهیم حرکت (move semantics) متکی هستند.

**shared_ptr** مشابه **unique_ptr** است، با این تفاوت که **shared_ptr** به جای انتقال، کپی می‌شود. **shared_ptr**‌ها مالکیت یک شیء را به اشتراک می‌گذارند و آن شیء زمانی نابود می‌شود که آخرین **shared_ptr** مرتبط نابود شود. برای مثال:

```cpp
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);
void user(const string& name, ios_base::openmode mode)
{
    shared_ptr<fstream> fp {new fstream(name, mode)};
    if (!*fp) throw No_file{}; // اطمینان از باز شدن صحیح فایل
    f(fp);
    g(fp);
    // ...
}
```

در اینجا، فایلی که توسط سازنده **fp** باز شده است، توسط آخرین تابعی که نسخه‌ای از **fp** را (به صورت صریح یا ضمنی) نابود می‌کند، بسته خواهد شد. توجه کنید که **f()** یا **g()** ممکن است یک تسک ایجاد کنند که نسخه‌ای از **fp** را نگه دارد یا به نحوی دیگر کپی‌ای را ذخیره کند که طول عمر بیشتری نسبت به **user()** داشته باشد. بنابراین، **shared_ptr** نوعی از جمع‌آوری زباله (garbage collection) ارائه می‌دهد که به مدیریت منابع مبتنی بر ویرانگر احترام می‌گذارد. این روش نه رایگان است و نه بیش از حد گران، اما طول عمر شیء مشترک را پیش‌بینی‌ناپذیر می‌کند. از **shared_ptr** فقط زمانی استفاده کنید که واقعاً به مالکیت مشترک نیاز دارید.

با داشتن **unique_ptr** و **shared_ptr**، می‌توانیم یک سیاست کامل «عدم استفاده از **new** مستقیم» (§3.2.1.2) را برای بسیاری از برنامه‌ها اعمال کنیم. با این حال، این «اشاره‌گرهای هوشمند» هنوز هم به صورت مفهومی اشاره‌گر هستند و بنابراین تنها گزینه دوم من برای مدیریت منابع به شمار می‌روند – پس از کانتینرها و انواع دیگری که منابع را در یک سطح مفهومی بالاتر مدیریت می‌کنند. به طور خاص، **shared_ptr** به تنهایی هیچ قانونی برای تعیین اینکه کدام مالکین می‌توانند شیء مشترک را بخوانند و/یا بنویسند ارائه نمی‌دهد. رقابت داده‌ها (§41.2.4) و دیگر اشکال سردرگمی فقط با حذف مشکلات مدیریت منابع حل نمی‌شوند.

کجا باید از «اشاره‌گرهای هوشمند» (مانند **unique_ptr**) به جای دسته‌های منابع با عملیات طراحی‌شده مخصوص برای منبع (مانند **vector** یا **thread**) استفاده کنیم؟ جای تعجب نیست که پاسخ این است: «وقتی به معنای اشاره‌گر نیاز داریم.»  
- وقتی شیء را به اشتراک می‌گذاریم، برای اشاره به آن به اشاره‌گر (یا مرجع) نیاز داریم، بنابراین **shared_ptr** انتخاب واضحی است (مگر اینکه یک مالک واضح وجود داشته باشد).  
- وقتی به یک شیء چندشکلی (polymorphic) اشاره می‌کنیم، نیاز به یک اشاره‌گر (یا مرجع) داریم، زیرا نوع دقیق شیء مورد اشاره یا حتی اندازه آن را نمی‌دانیم. بنابراین **unique_ptr** انتخاب واضحی است.  
- یک شیء چندشکلی مشترک معمولاً به **shared_ptr** نیاز دارد.  

ما نیازی به استفاده از اشاره‌گر برای بازگرداندن یک مجموعه از اشیاء از یک تابع نداریم؛ یک کانتینر که دسته‌ای برای منابع است این کار را به سادگی و به طور کارآمد انجام می‌دهد (§3.3.2).

