## Introduction
از دیدگاه یک کاربر نهایی، کتابخانه استاندارد ایده‌آل باید اجزایی را ارائه دهد که به‌طور مستقیم تقریباً هر نیازی را پشتیبانی کنند. برای یک حوزه کاربردی خاص، یک کتابخانه تجاری بزرگ می‌تواند به این ایده‌آل نزدیک شود. با این حال، این چیزی نیست که کتابخانه استاندارد C++ در تلاش برای انجام آن است. یک کتابخانه قابل مدیریت و در دسترس برای همگان نمی‌تواند همه چیز برای همه افراد باشد. در عوض، کتابخانه استاندارد C++ تلاش می‌کند اجزایی را ارائه دهد که برای اکثر افراد در اکثر حوزه‌های کاربردی مفید باشند. به عبارت دیگر، هدف این کتابخانه خدمت به تقاطع همه نیازها است، نه اتحاد آن‌ها. علاوه بر این، پشتیبانی از چند حوزه کاربردی بسیار مهم، مانند محاسبات ریاضی و پردازش متن، به مرور وارد این کتابخانه شده است.

## Resource Management
یکی از وظایف کلیدی هر برنامه غیرساده مدیریت منابع است. منبع چیزی است که باید دریافت شده و بعداً (به صورت صریح یا ضمنی) آزاد شود. مثال‌هایی از منابع شامل حافظه، قفل‌ها، سوکت‌ها، دستگیره‌های نخ (thread handles) و دستگیره‌های فایل هستند. در یک برنامه بلندمدت، آزاد نکردن یک منبع به‌موقع («نشت») می‌تواند باعث کاهش شدید کارایی و حتی منجر به یک خرابی ناگوار شود. حتی در برنامه‌های کوتاه‌مدت، نشت منابع می‌تواند مشکل‌ساز شود؛ مثلاً با ایجاد کمبود منابع، زمان اجرای برنامه به طرز چشمگیری افزایش یابد.

اجزای کتابخانه استاندارد به گونه‌ای طراحی شده‌اند که منابع را نشت ندهند. برای دستیابی به این هدف، آن‌ها به پشتیبانی پایه‌ای زبان برای مدیریت منابع با استفاده از جفت‌های سازنده/ویرانگر (constructor/destructor) تکیه می‌کنند تا اطمینان حاصل شود که یک منبع طول عمر بیشتری نسبت به شیء مسئول آن نداشته باشد. استفاده از جفت سازنده/ویرانگر در کلاس **Vector** برای مدیریت طول عمر عناصرش یک نمونه است (بخش §3.2.1.2) و تمامی کانتینرهای کتابخانه استاندارد به روش‌های مشابه پیاده‌سازی شده‌اند. مهم‌تر از همه، این روش به درستی با مدیریت خطا از طریق استثناها تعامل دارد. به‌عنوان مثال، این تکنیک در کلاس‌های قفل کتابخانه استاندارد استفاده می‌شود:

```cpp
mutex m; // برای محافظت از دسترسی به داده‌های مشترک
// ...
void f()
{
    unique_lock<mutex> lck {m}; // قفل mutex m را دریافت کن
    // ... دستکاری داده‌های مشترک ...
}
```

یک نخ (thread) تا زمانی که سازنده **lck** قفل **m** را دریافت نکند، پیش نخواهد رفت (بخش §5.3.4). ویرانگر متناظر این منبع را آزاد می‌کند. بنابراین، در این مثال، ویرانگر **unique_lock** قفل **mutex** را زمانی که کنترل از تابع **f()** خارج می‌شود (چه از طریق بازگشت، چه به‌صورت طبیعی با رسیدن به انتهای تابع، یا از طریق پرتاب استثنا) آزاد می‌کند.

این یک کاربرد از تکنیک «دریافت منبع به معنای مقداردهی اولیه است» (RAII؛ بخش‌های §3.2.1.2 و §13.3) است. این تکنیک پایه‌ای برای مدیریت ایدئال منابع در زبان C++ محسوب می‌شود. کانتینرها (مانند **vector** و **map**)، رشته (**string**)، و جریان‌های ورودی/خروجی (**iostream**) منابع خود (مانند دستگیره‌های فایل و بافرها) را به همین شیوه مدیریت می‌کنند.

## unique_ptr and shared_ptr
مثال‌هایی که تا کنون بررسی شدند، مدیریت اشیاء تعریف‌شده در یک دامنه (scope) و آزادسازی منابع آن‌ها هنگام خروج از دامنه را پوشش می‌دهند، اما در مورد اشیایی که در حافظه آزاد (free store) تخصیص داده می‌شوند چه باید کرد؟ در کتابخانه استاندارد و در هدر **<memory>**، دو «اشاره‌گر هوشمند» برای کمک به مدیریت اشیاء در حافظه آزاد ارائه شده است:  
1. **unique_ptr** برای نمایش مالکیت یکتا (§34.3.1)  
2. **shared_ptr** برای نمایش مالکیت اشتراکی (§34.3.2)  

استفاده اساسی از این «اشاره‌گرهای هوشمند» جلوگیری از نشت حافظه ناشی از برنامه‌نویسی بی‌دقت است. به عنوان مثال:

```cpp
void f(int i, int j) // X* در مقابل unique_ptr<X>
{
    X* p = new X; // تخصیص یک X جدید
    unique_ptr<X> sp {new X}; // تخصیص یک X جدید و واگذاری اشاره‌گر آن به unique_ptr
    // ...
    if (i<99) throw Z{}; // ممکن است یک استثنا پرتاب شود
    if (j<77) return; // ممکن است زودتر از تابع بازگردیم
    p->do_something(); // ممکن است یک استثنا پرتاب شود
    sp->do_something(); // ممکن است یک استثنا پرتاب شود
    // ...
    delete p; // نابود کردن *p
}
```

در اینجا، اگر **i < 99** یا **j < 77** باشد، فراموش کردیم که **p** را آزاد کنیم. از سوی دیگر، **unique_ptr** تضمین می‌کند که شیء مرتبط به درستی نابود می‌شود، صرف‌نظر از این که چگونه از تابع **f()** خارج می‌شویم (چه از طریق پرتاب استثنا، بازگشت یا رسیدن به انتهای تابع). جالب اینجاست که می‌توانستیم این مشکل را به سادگی با عدم استفاده از اشاره‌گر و **new** حل کنیم:

```cpp
void f(int i, int j) // استفاده از یک متغیر محلی
{
    X x;
    // ...
}
```

متأسفانه، استفاده بیش از حد از **new** (و همچنین اشاره‌گرها و مراجع) به نظر می‌رسد که یک مشکل رو به رشد است. با این حال، زمانی که واقعاً به معنای اشاره‌گرها نیاز دارید، **unique_ptr** مکانیزمی بسیار سبک با هیچ هزینه اضافی (از نظر فضا یا زمان) در مقایسه با استفاده صحیح از یک اشاره‌گر داخلی است. استفاده‌های بیشتر آن شامل انتقال اشیاء تخصیص‌داده‌شده در حافظه آزاد به داخل و خارج از توابع است:

```cpp
unique_ptr<X> make_X(int i) // ساخت یک X و انتقال فوری آن به unique_ptr
{
    // ... بررسی i و غیره ...
    return unique_ptr<X>{new X{i}};
}
```

یک **unique_ptr** مانند یک دسته برای یک شیء (یا آرایه) عمل می‌کند، همان‌طور که **vector** یک دسته برای دنباله‌ای از اشیاء است. هر دو طول عمر اشیاء دیگر را کنترل می‌کنند (با استفاده از RAII) و هر دو برای ساده و کارآمد کردن بازگشت، به مفاهیم حرکت (move semantics) متکی هستند.

**shared_ptr** مشابه **unique_ptr** است، با این تفاوت که **shared_ptr** به جای انتقال، کپی می‌شود. **shared_ptr**‌ها مالکیت یک شیء را به اشتراک می‌گذارند و آن شیء زمانی نابود می‌شود که آخرین **shared_ptr** مرتبط نابود شود. برای مثال:

```cpp
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);
void user(const string& name, ios_base::openmode mode)
{
    shared_ptr<fstream> fp {new fstream(name, mode)};
    if (!*fp) throw No_file{}; // اطمینان از باز شدن صحیح فایل
    f(fp);
    g(fp);
    // ...
}
```

در اینجا، فایلی که توسط سازنده **fp** باز شده است، توسط آخرین تابعی که نسخه‌ای از **fp** را (به صورت صریح یا ضمنی) نابود می‌کند، بسته خواهد شد. توجه کنید که **f()** یا **g()** ممکن است یک تسک ایجاد کنند که نسخه‌ای از **fp** را نگه دارد یا به نحوی دیگر کپی‌ای را ذخیره کند که طول عمر بیشتری نسبت به **user()** داشته باشد. بنابراین، **shared_ptr** نوعی از جمع‌آوری زباله (garbage collection) ارائه می‌دهد که به مدیریت منابع مبتنی بر ویرانگر احترام می‌گذارد. این روش نه رایگان است و نه بیش از حد گران، اما طول عمر شیء مشترک را پیش‌بینی‌ناپذیر می‌کند. از **shared_ptr** فقط زمانی استفاده کنید که واقعاً به مالکیت مشترک نیاز دارید.

با داشتن **unique_ptr** و **shared_ptr**، می‌توانیم یک سیاست کامل «عدم استفاده از **new** مستقیم» (§3.2.1.2) را برای بسیاری از برنامه‌ها اعمال کنیم. با این حال، این «اشاره‌گرهای هوشمند» هنوز هم به صورت مفهومی اشاره‌گر هستند و بنابراین تنها گزینه دوم من برای مدیریت منابع به شمار می‌روند – پس از کانتینرها و انواع دیگری که منابع را در یک سطح مفهومی بالاتر مدیریت می‌کنند. به طور خاص، **shared_ptr** به تنهایی هیچ قانونی برای تعیین اینکه کدام مالکین می‌توانند شیء مشترک را بخوانند و/یا بنویسند ارائه نمی‌دهد. رقابت داده‌ها (§41.2.4) و دیگر اشکال سردرگمی فقط با حذف مشکلات مدیریت منابع حل نمی‌شوند.

کجا باید از «اشاره‌گرهای هوشمند» (مانند **unique_ptr**) به جای دسته‌های منابع با عملیات طراحی‌شده مخصوص برای منبع (مانند **vector** یا **thread**) استفاده کنیم؟ جای تعجب نیست که پاسخ این است: «وقتی به معنای اشاره‌گر نیاز داریم.»  
- وقتی شیء را به اشتراک می‌گذاریم، برای اشاره به آن به اشاره‌گر (یا مرجع) نیاز داریم، بنابراین **shared_ptr** انتخاب واضحی است (مگر اینکه یک مالک واضح وجود داشته باشد).  
- وقتی به یک شیء چندشکلی (polymorphic) اشاره می‌کنیم، نیاز به یک اشاره‌گر (یا مرجع) داریم، زیرا نوع دقیق شیء مورد اشاره یا حتی اندازه آن را نمی‌دانیم. بنابراین **unique_ptr** انتخاب واضحی است.  
- یک شیء چندشکلی مشترک معمولاً به **shared_ptr** نیاز دارد.  

ما نیازی به استفاده از اشاره‌گر برای بازگرداندن یک مجموعه از اشیاء از یک تابع نداریم؛ یک کانتینر که دسته‌ای برای منابع است این کار را به سادگی و به طور کارآمد انجام می‌دهد (§3.3.2).

## Concurrency
هم‌روندی (Concurrency) – اجرای همزمان چندین وظیفه – به طور گسترده برای **افزایش توان عملیاتی** (با استفاده از چندین پردازنده برای یک محاسبه) یا **بهبود پاسخ‌دهی** (با اجازه دادن به یک بخش از برنامه برای پیشرفت در حالی که بخش دیگر منتظر پاسخ است) استفاده می‌شود. تمام زبان‌های برنامه‌نویسی مدرن از این قابلیت پشتیبانی می‌کنند. پشتیبانی ارائه شده توسط کتابخانه استاندارد ++C، یک نسخه قابل حمل (portable) و نوع-ایمن (type-safe) از چیزی است که برای بیش از 20 سال در ++C استفاده شده و تقریباً توسط تمام سخت‌افزارهای مدرن پشتیبانی می‌شود. 

پشتیبانی کتابخانه استاندارد، عمدتاً با هدف پشتیبانی از هم‌روندی در سطح سیستم ارائه شده است، نه برای ارائه مستقیم مدل‌های پیشرفته‌تر هم‌روندی؛ چنین مدل‌های پیشرفته‌ای می‌توانند به صورت کتابخانه‌هایی ساخته شوند که از امکانات کتابخانه استاندارد استفاده می‌کنند.

کتابخانه استاندارد به طور مستقیم از اجرای هم‌زمان چندین نخ (threads) در یک فضای آدرس پشتیبانی می‌کند. برای این منظور، ++C یک **مدل حافظه مناسب** (§41.2) و مجموعه‌ای از **عملیات اتمی** (§41.3) فراهم می‌کند. با این حال، اکثر کاربران هم‌روندی را تنها از طریق کتابخانه استاندارد و کتابخانه‌هایی که بر پایه آن ساخته شده‌اند مشاهده می‌کنند. 

این بخش به طور خلاصه مثال‌هایی از امکانات اصلی پشتیبانی هم‌روندی در کتابخانه استاندارد ارائه می‌دهد: **نخ‌ها (threads)**، **قفل‌ها (mutexes)**، **عملیات lock()**، **وظایف بسته‌بندی‌شده (packaged_tasks)** و **آینده‌ها (futures)**. این ویژگی‌ها به طور مستقیم بر اساس امکانات ارائه‌شده توسط سیستم‌عامل‌ها ساخته شده‌اند و **هیچگونه کاهش کارایی** نسبت به امکانات سیستم‌عامل ندارند.

## Tasks and threads
ما به محاسباتی که می‌توانند به طور همزمان با سایر محاسبات اجرا شوند، **وظیفه (task)** می‌گوییم. یک **نخ (thread)** نمایشی در سطح سیستم از یک وظیفه در یک برنامه است. برای اجرای یک وظیفه به صورت همزمان با سایر وظایف، باید با ساختن یک `std::thread` (از کتابخانه `<thread>`) وظیفه موردنظر را به عنوان آرگومان به آن منتقل کنیم. یک وظیفه می‌تواند یک تابع یا یک شیء تابع (function object) باشد:

```cpp
void f(); // تابع
struct F { // شیء تابع
    void operator()(); // عملگر () برای F
};
```

### مثال:
در این مثال، دو نخ ایجاد می‌شوند که هر یک وظیفه‌ای را به صورت همزمان اجرا می‌کنند:

```cpp
void user() {
    thread t1 {f}; // اجرای f() در یک نخ جداگانه
    thread t2 {F()}; // اجرای F()() در یک نخ جداگانه
    t1.join(); // منتظر پایان t1
    t2.join(); // منتظر پایان t2
}
```

متد `join()` تضمین می‌کند که از تابع `user()` خارج نشویم تا زمانی که نخ‌ها کارشان را به پایان برسانند. مفهوم "join" یعنی "منتظر ماندن برای پایان نخ".

---

### تفاوت نخ‌ها با فرآیندها:
- نخ‌های یک برنامه **یک فضای آدرس مشترک** دارند. 
- برخلاف نخ‌ها، فرآیندها معمولاً داده‌ها را به طور مستقیم با یکدیگر به اشتراک نمی‌گذارند.
- به دلیل اشتراک فضای آدرس، نخ‌ها می‌توانند از طریق **اشیای مشترک** با یکدیگر ارتباط برقرار کنند. این ارتباط معمولاً توسط **قفل‌ها (locks)** یا سایر مکانیزم‌ها کنترل می‌شود تا از **data race** (دسترسی همزمان و کنترل‌نشده به یک متغیر) جلوگیری شود.

---

### مشکل در هم‌زمانی و مثال خطا:
نوشتن برنامه‌های هم‌زمان ممکن است بسیار دشوار باشد. به عنوان مثال، وظایف زیر تعریف شده‌اند:

```cpp
void f() { cout << "Hello "; }
struct F {
    void operator()() { cout << "Parallel World!\n"; }
};
```

اگر دو نخ به طور همزمان این وظایف را اجرا کنند:

```cpp
thread t1 {f};
thread t2 {F()};
t1.join();
t2.join();
```

این کد یک **خطای بد** است. هر دو وظیفه از شیء `cout` به طور همزمان استفاده می‌کنند، اما **بدون هیچ‌گونه هم‌زمان‌سازی (synchronization)**. 

خروجی حاصل می‌تواند غیرقابل پیش‌بینی باشد و در اجرای‌های مختلف برنامه متفاوت باشد. برای مثال، ممکن است خروجی زیر تولید شود:

```
PaHerallllel o World!
```

---

### راه‌حل و نکته مهم:
برای تعریف وظایف در یک برنامه هم‌زمان، هدف این است که:
1. **وظایف را کاملاً جدا از هم نگه داریم**، مگر در جاهایی که ارتباطات ساده و واضح بین آن‌ها وجود دارد.
2. **وظایف را به صورت ایزوله تعریف کنیم**: یعنی داده‌های مشترک نباید بدون کنترل استفاده شوند.

ساده‌ترین راه برای فکر کردن به یک وظیفه هم‌زمان، این است که به آن به چشم یک تابع نگاه کنیم که به طور همزمان با فراخواننده خود اجرا می‌شود. برای این کار باید:
- آرگومان‌ها را منتقل کنیم،
- نتیجه را دریافت کنیم،
- و اطمینان حاصل کنیم که داده‌های مشترک به صورت ناامن استفاده نمی‌شوند (یعنی **data race** وجود نداشته باشد).
