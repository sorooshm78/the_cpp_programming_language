## Introduction
کلید استفاده مؤثر از ++C تعریف و به‌کارگیری **نوع‌های تعریف‌شده توسط کاربر** است.
این فصل سه گونه‌ی ابتداییِ این مفهوم را معرفی می‌کند:

* **struct** (ساختار): دنباله‌ای از عناصر (که *عضو* نامیده می‌شوند) با نوع‌های دلخواه.
* **union**: ساختاری که در هر لحظه فقط مقدار یکی از اعضایش را نگه می‌دارد.
* **enum** (شمارش): نوعی که مجموعه‌ای از ثابت‌های نام‌گذاری‌شده (*enumerator*) را تعریف می‌کند.
* **enum class** (شمارش با محدوده یا Scoped Enumeration): نوعی شمارش که اعضای شمارش‌شده در محدوده‌ی خود آن شمارش قرار دارند و هیچ تبدیل ضمنی به نوع‌های دیگر انجام نمی‌شود.

گونه‌های مختلف این نوع‌های ساده از نخستین روزهای پیدایش ++C وجود داشته‌اند.
آن‌ها عمدتاً بر نمایش داده متمرکز هستند و ستون فقرات بیشتر برنامه‌نویسی به سبک C محسوب می‌شوند.

مفهوم **struct** که اینجا توضیح داده شده، شکلی ساده از یک **کلاس** است (بخش 3.2، فصل 16).

## Structures
آرایه مجموعه‌ای از عناصری با یک نوع یکسان است. در ساده‌ترین حالت، یک **struct** (ساختار) مجموعه‌ای از عناصری با نوع‌های دلخواه است. برای مثال:

```cpp
struct Address {
    const char* name;   // "Jim Dandy"
    int number;         // 61
    const char* street; // "South St"
    const char* town;   // "New Providence"
    char state[2];      // 'N' 'J'
    const char* zip;    // "07974"
};
```

این تعریف، نوعی به نام `Address` ایجاد می‌کند که شامل اطلاعاتی است که برای ارسال نامه به یک فرد در ایالات متحده آمریکا لازم است. به علامت **;** انتهای تعریف دقت کنید.

متغیرهای نوع `Address` درست مانند سایر متغیرها تعریف می‌شوند و اعضای آن‌ها را می‌توان با عملگر **`.`** (نقطه) دسترسی داد. برای مثال:

```cpp
void f()
{
    Address jd;
    jd.name = "Jim Dandy";
    jd.number = 61;
}
```

متغیرهای ساختاری را می‌توان با استفاده از یادداشت **`{}`** مقداردهی اولیه کرد (§6.3.5). برای مثال:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};
```

دقت کنید که `jd.state` را نمی‌توان با رشته `"NJ"` مقداردهی کرد. رشته‌ها با کاراکتر صفر `'\0'` خاتمه می‌یابند، بنابراین `"NJ"` شامل سه کاراکتر است — یک کاراکتر بیشتر از آنچه در `jd.state` جا می‌شود. در این مثال، عمداً از نوع‌های سطح پایین برای اعضا استفاده شده تا نشان داده شود که چگونه این کار انجام می‌شود و چه مشکلاتی می‌تواند ایجاد کند.

ساختارها اغلب از طریق اشاره‌گرها با عملگر **`->`** (دسترسی از طریق اشاره‌گر به struct) استفاده می‌شوند. برای مثال:

```cpp
void print_addr(Address* p)
{
    cout << p->name << '\n'
         << p->number << ' ' << p->street << '\n'
         << p->town << '\n'
         << p->state[0] << p->state[1] << ' ' << p->zip << '\n';
}
```

وقتی `p` یک اشاره‌گر است، عبارت `p->m` معادل `( *p ).m` است.

به‌طور جایگزین، یک **struct** می‌تواند به‌صورت **ارجاع (reference)** به تابع داده شود و با عملگر **`.`** (دسترسی به عضو ساختار) استفاده شود:

```cpp
void print_addr2(const Address& r)
{
    cout << r.name << '\n'
         << r.number << ' ' << r.street << '\n'
         << r.town << '\n'
         << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
```

بحث درباره‌ی ارسال آرگومان‌ها در بخش §12.2 آمده است.

اشیای نوع ساختار را می‌توان **اختصاص (assign)** داد، به‌عنوان **آرگومان به تابع ارسال** کرد و به‌عنوان **نتیجه از یک تابع بازگرداند**. برای مثال:

```cpp
Address current;

Address set_current(Address next)
{
    Address prev = current;
    current = next;
    return prev;
}
```

سایر عملیات ممکن، مانند مقایسه (`==` و `!=`)، به‌طور پیش‌فرض در دسترس نیستند.
با این حال، کاربر می‌تواند این عملگرها را تعریف کند (§3.2.1.1، فصل 18).

## struct Layout
یک شیء از نوع **struct** اعضای خود را به ترتیبی که اعلان شده‌اند در حافظه نگه می‌دارد.
برای مثال، می‌توانیم داده‌های ساده‌ی یک دستگاه اندازه‌گیری را در ساختاری مانند زیر ذخیره کنیم:

```cpp
struct Readout {
    char hour;  // [0:23]
    int value;
    char seq;   // علامت ترتیبی ['a':'z']
};
```

می‌توانید تصور کنید که اعضای یک شیء از نوع `Readout` در حافظه به این صورت چیده می‌شوند:

```
hour:   value:   seq:
```

اعضا دقیقاً به ترتیبی که اعلان شده‌اند در حافظه تخصیص داده می‌شوند، بنابراین آدرس `hour` باید کوچک‌تر از آدرس `value` باشد (نگاه کنید به §8.2.6).

---

با این حال، **اندازه‌ی یک شیء از نوع struct الزاماً برابر با مجموع اندازه‌ی اعضای آن نیست**.
دلیلش این است که بسیاری از ماشین‌ها (پردازنده‌ها) نیاز دارند که اشیای مربوط به بعضی انواع داده‌ها روی مرزهای خاصی (وابسته به معماری) قرار گیرند یا دست‌کم در این حالت دسترسی به آن‌ها کارآمدتر است.
برای مثال، معمولاً اعداد صحیح (`int`) روی مرزهای کلمه (word boundaries) قرار داده می‌شوند. روی چنین ماشین‌هایی، گفته می‌شود که اشیا باید «هم‌تراز (aligned)» باشند (§6.2.9). این موضوع باعث ایجاد «حفره‌ها» (فضاهای استفاده‌نشده) در ساختارها می‌شود.

یک چینش واقعی‌تر از `Readout` روی ماشینی که `int` آن ۴ بایتی است، چنین خواهد بود:

```
hour:
value:
seq:
```

در این حالت، همانند بسیاری از ماشین‌ها، `sizeof(Readout)` برابر **۱۲** است، نه **۶** (که کسی شاید ساده‌انگارانه از جمع اندازه‌ی اعضا انتظار داشته باشد).

---

می‌توانید با مرتب‌سازی اعضا بر اساس اندازه (از بزرگ‌ترین به کوچک‌ترین) فضای هدررفته را کاهش دهید.
برای مثال:

```cpp
struct Readout {
    int value;
    char hour;  // [0:23]
    char seq;   // علامت ترتیبی ['a':'z']
};
```

چینش در این حالت:

```
value:
(hour, seq):
```

با این حال، همچنان یک «حفره» ۲ بایتی باقی می‌ماند و `sizeof(Readout)` برابر **۸** خواهد شد.
علتش این است که هنگام قرار دادن دو شیء پشت سر هم (مثلاً در یک آرایه از `Readout`ها) باید هم‌ترازی حفظ شود.
پس اندازه‌ی یک آرایه‌ی ۱۰ عضوی از نوع `Readout` برابر است با:

```
10 * sizeof(Readout)
```

---

به طور کلی، بهتر است اعضا را بر اساس **خوانایی** کد مرتب کنید و فقط در صورتی به مرتب‌سازی بر اساس اندازه فکر کنید که واقعاً نیاز به بهینه‌سازی ثابت شده باشد.

استفاده از چند **specifier دسترسی** (یعنی `public`، `private` یا `protected`) هم می‌تواند روی چیدمان حافظه تأثیر بگذارد (§20.5).

## struct Names
نام یک نوع (type) بلافاصله پس از این‌که در کد دیده شد قابل استفاده می‌شود، نه این‌که فقط بعد از کامل دیده شدن اعلان آن.
برای مثال:

```cpp
struct Link {
    Link* previous;
    Link* successor;
};
```

با این حال، امکان اعلان اشیای جدید از یک struct تا زمانی که اعلان کامل آن struct دیده نشود وجود ندارد.
برای مثال:

```cpp
struct No_good {
    No_good member; // خطا: تعریف بازگشتی
};
```

این خطا است چون کامپایلر قادر به تعیین اندازه‌ی `No_good` نیست.
برای اینکه دو (یا بیشتر) struct بتوانند به یکدیگر اشاره کنند، می‌توانیم نامی را به عنوان نام یک struct معرفی کنیم.
برای مثال:

```cpp
struct List; // اعلان نام struct: List بعداً تعریف خواهد شد
struct Link {
    Link* pre;
    Link* suc;
    List* member_of;
    int data;
};
struct List {
    Link* head;
};
```

بدون اعلان اول برای `List`، استفاده از نوع اشاره‌گر `List*` در تعریف `Link` یک خطای نحوی بود.

---

نام یک struct می‌تواند قبل از این‌که نوع آن تعریف شود استفاده شود، به شرطی که آن استفاده نیازی به دانستن نام اعضا یا اندازه‌ی آن struct نداشته باشد.
با این حال، تا تکمیل شدن اعلان یک struct، آن struct یک **نوع ناقص (incomplete type)** محسوب می‌شود.
برای مثال:

```cpp
struct S;   // "S" نام یک نوع است
extern S a;
S f();
void g(S);
S* h(S*);
```

اما بسیاری از این اعلان‌ها را نمی‌توان استفاده کرد مگر اینکه نوع `S` تعریف شده باشد:

```cpp
void k(S* p)
{
    S a;       // خطا: S تعریف نشده؛ برای تخصیص اندازه لازم است
    f();       // خطا: S تعریف نشده؛ برای بازگرداندن مقدار اندازه لازم است
    g(a);      // خطا: S تعریف نشده؛ برای ارسال آرگومان اندازه لازم است
    p->m = 7;  // خطا: S تعریف نشده؛ نام عضو شناخته نیست
    S* q = h(p); // درست: اشاره‌گرها می‌توانند تخصیص داده و ارسال شوند
    q->m = 7;    // خطا: S تعریف نشده؛ نام عضو شناخته نیست
}
```

---

به دلایلی که به تاریخچه‌ی اولیه‌ی زبان C بازمی‌گردد، امکان دارد یک struct و یک غیر-struct با یک نام یکسان در همان دامنه تعریف شوند.
برای مثال:

```cpp
struct stat { /* ... */ };
int stat(char* name, struct stat* buf);
```

در این حالت، نام ساده‌ی `stat` مربوط به غیر-struct است، و برای اشاره به struct باید از پیشوند `struct` استفاده شود.
به همین ترتیب، کلمات کلیدی `class`، `union` و `enum` نیز می‌توانند به عنوان پیشوند برای رفع ابهام استفاده شوند.

با این حال، بهتر است نام‌ها را به‌گونه‌ای انتخاب کنیم که نیاز به چنین رفع ابهامی به وجود نیاید.

## Structures and Classes
یک **struct** در واقع همان **class** است با این تفاوت که اعضای آن به‌طور پیش‌فرض **public** هستند. بنابراین، یک struct می‌تواند **تابع عضو** هم داشته باشد (بخش §2.3.2 و فصل 16). به‌طور خاص، یک struct می‌تواند **سازنده (constructor)** داشته باشد.
برای مثال:

```cpp
struct Points {
    vector<Point> elem; // باید حداقل یک Point در خود داشته باشد
    Points(Point p0) { elem.push_back(p0); }
    Points(Point p0, Point p1) { elem.push_back(p0); elem.push_back(p1); }
    // ...
};
```

```cpp
Points x0; // خطا: سازنده‌ی پیش‌فرض وجود ندارد
Points x1{ {100,200} }; // یک Point
Points x1{ {100,200}, {300,400} }; // دو Point
```

---

نیازی نیست برای مقداردهی اعضا به ترتیب، حتماً یک سازنده تعریف کنید.
برای مثال:

```cpp
struct Point {
    int x, y;
};
```

```cpp
Point p0;       // خطرناک: اگر در محدوده‌ی محلی باشد بدون مقدار اولیه است (§6.3.5.1)
Point p1 {};    // سازنده‌ی پیش‌فرض: {{},{}} یعنی {0,0}
Point p2 {1};   // عضو دوم به‌طور پیش‌فرض مقداردهی می‌شود: {1,{}} یعنی {1,0}
Point p3 {1,2}; // {1,2}
```

---

**سازنده‌ها** زمانی لازم می‌شوند که بخواهید:

* ترتیب آرگومان‌ها را تغییر دهید،
* آرگومان‌ها را اعتبارسنجی کنید،
* آرگومان‌ها را اصلاح کنید،
* یا **invariant**ها (قیود پایدار) برقرار کنید (§2.4.3.2، §13.4).

برای مثال:

```cpp
struct Address {
    string name;    // "Jim Dandy"
    int number;     // 61
    string street;  // "South St"
    string town;    // "New Providence"
    char state[2];  // 'N' 'J'
    char zip[5];    // 07974
    Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
};
```

اینجا یک **سازنده** اضافه شده تا مطمئن شویم تمام اعضا مقداردهی شده‌اند و بتوانیم کد پستی را با یک رشته و یک عدد دریافت کنیم (نه اینکه مجبور شویم تک‌تک کاراکترها را دستکاری کنیم).

مثال استفاده:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    "NJ", 7974 // توجه: 07974 عدد هشت‌شانزدهی محسوب می‌شود (§6.2.4.1)
};
```

---

سازنده‌ی `Address` می‌تواند این‌طور پیاده‌سازی شود:

```cpp
Address::Address(const string& n, int nu, const string& s,
                 const string& t, const string& st, int z)
    // اعتبارسنجی کد پستی
    :name{n},
     number{nu},
     street{s},
     town{t}
{
    if (st.size()!=2)
        error("State abbreviation should be two characters");
    state = {st[0], st[1]}; // ذخیره‌ی کد ایالت به‌صورت کاراکتر

    ostringstream ost; // رشته‌جریان خروجی؛ نگاه کنید به §38.4.2
    ost << z;          // استخراج کاراکترها از int
    string zi {ost.str()};

    switch (zi.size()) {
    case 5:
        zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
        break;
    case 4: // با ‘0’ شروع می‌شود
        zip = {'0', zi[0], zi[1], zi[2], zi[3]};
        break;
    default:
        error("unexpected ZIP code format");
    }

    // ... بررسی کنید که کد معتبر باشد ...
}
```

## Structures and Arrays
به‌طور طبیعی می‌توانیم آرایه‌ای از **struct**‌ها و همچنین **struct**‌هایی شامل آرایه داشته باشیم. برای مثال:

```cpp
struct Point {
    int x, y;
};
Point points[3] {{1,2},{3,4},{5,6}};
int x2 = points[2].x;

struct Array {
    Point elem[3];
};
Array points2 {{1,2},{3,4},{5,6}};
int y2 = points2.elem[2].y;
```

قرار دادن یک آرایهٔ درون‌ساخته (built-in array) در یک **struct** به ما اجازه می‌دهد آن آرایه را مثل یک شیء در نظر بگیریم:
می‌توانیم **struct** حاوی آن را در **مقداردهی اولیه** (از جمله در ارسال آرگومان و بازگرداندن از تابع) و همچنین در **عملیات انتساب** کپی کنیم. برای مثال:

```cpp
Array shift(Array a, Point p)
{
    for (int i=0; i!=3; ++i) {
        a.elem[i].x += p.x;
        a.elem[i].y += p.y;
    }
    return a;
}
Array ax = shift(points2,{10,20});
```

یادداشت مربوط به `Array` کمی ابتدایی است: چرا `i!=3`؟ چرا باید مرتب `.elem[i]` را تکرار کنیم؟ چرا فقط المان‌هایی از نوع `Point`؟
کتابخانهٔ استاندارد، `std::array` را (بخش §34.2.1) به عنوان یک توسعهٔ کامل‌تر و زیباتر از ایدهٔ آرایهٔ با اندازه ثابت به صورت struct فراهم کرده است:

```cpp
template<typename T, size_t N >
struct array { // ساده‌شده (بخش §34.2.1 را ببینید)
    T elem[N];

    T* begin() noexcept { return elem; }
    const T* begin() const noexcept { return elem; }

    T* end() noexcept { return elem+N; }
    const T* end() const noexcept { return elem+N; }

    constexpr size_t size() noexcept;

    T& operator[](size_t n) { return elem[n]; }
    const T& operator[](size_type n) const { return elem[n]; }

    T* data() noexcept { return elem; }
    const T* data() const noexcept { return elem; }
    // ...
};
```

این `array` یک **قالب (template)** است تا هر تعداد دلخواهی از عناصر هر نوع دلخواهی را پشتیبانی کند. همچنین به طور مستقیم با امکان **استثناها** (§13.5.1.1) و اشیاء **const** (§16.2.9.1) سروکار دارد. با استفاده از `array` می‌توانیم چنین بنویسیم:

```cpp
struct Point {
    int x,y;
};
using Array = array<Point,3>; // آرایه‌ای از 3 Point

Array points {{1,2},{3,4},{5,6}};
int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
    for (int i=0; i!=a.size(); ++i) {
        a[i].x += p.x;
        a[i].y += p.y;
    }
    return a;
}
Array ax = shift(points,{10,20});
```

مزایای اصلی `std::array` نسبت به آرایهٔ درون‌ساخته این است که:

* یک نوع شیء واقعی است (دارای انتساب و ...).
* به طور ضمنی به یک اشاره‌گر به یک عنصر منفرد تبدیل نمی‌شود.

مثال:

```cpp
ostream& operator<<(ostream& os, Point p)
{
    cout << '{' << p.x << ',' << p.y << '}';
}

void print(Point a[],int s) // باید تعداد عناصر مشخص شود
{
    for (int i=0; i!=s; ++i)
        cout << a[i] << '\n';
}

template<typename T, int N>
void print(array<T,N>& a)
{
    for (int i=0; i!=a.size(); ++i)
        cout << a[i] << '\n';
}

Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر

void f()
{
    print(point1,4); // 4 یک خطای بد است
    print(point2);
}
```

عیب `std::array` در مقایسه با آرایهٔ درون‌ساخته این است که نمی‌توانیم تعداد عناصر را از طول **initializer** استنتاج کنیم:

```cpp
Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point> point3 = {{1,2},{3,4},{5,6}};   // خطا
```

## Type Equivalence
دو **struct** حتی زمانی که اعضای یکسانی دارند، نوع‌های متفاوتی محسوب می‌شوند.
برای مثال:

```cpp
struct S1 { int a; };
struct S2 { int a; };
```

`S1` و `S2` دو نوع متفاوت هستند، بنابراین:

```cpp
S1 x;
S2 y = x; // خطا: عدم تطابق نوع
```

یک **struct** همچنین با نوعی که به‌عنوان عضو در آن استفاده شده، متفاوت است.
برای مثال:

```cpp
S1 x;
int i = x; // خطا: عدم تطابق نوع
```

هر **struct** باید در یک برنامه تعریف یکتایی داشته باشد (§15.2.3).

## 8.2.6 Plain Old Data
گاهی اوقات می‌خواهیم با یک شیء مثل «داده‌ی خام قدیمی» (**Plain Old Data = POD**) رفتار کنیم (یعنی به‌عنوان یک دنباله‌ی پیوسته از بایت‌ها در حافظه) و نگران مفاهیم معنایی پیشرفته‌تر، مانند **چندریختی در زمان اجرا** (§3.2.3, §20.3.2)، **سمنتیک کپی تعریف‌شده توسط کاربر** (§3.3, §17.5) و غیره نباشیم.
دلیل انجام این کار اغلب این است که بتوانیم اشیاء را به مؤثرترین شکلی که سخت‌افزار اجازه می‌دهد جابه‌جا کنیم.

برای مثال، کپی کردن یک آرایه‌ی 100 عنصری با 100 بار فراخوانی سازنده‌ی کپی به‌طور معمول به‌اندازه‌ی یک فراخوانی به `std::memcpy()` سریع نیست، چون `memcpy` معمولاً تنها از یک دستور سخت‌افزاری **انتقال بلوکی حافظه** استفاده می‌کند. حتی اگر سازنده کپی inline شود، ممکن است بهینه‌ساز نتواند چنین بهینه‌سازی‌ای را کشف کند. این‌گونه «ترفندها» در پیاده‌سازی **کانتینرها** (مانند `vector`) و در **روال‌های سطح پایین I/O** متداول و مهم هستند، اما در کدهای سطح بالاتر غیرضروری بوده و بهتر است از آن‌ها پرهیز شود.

بنابراین، یک **POD** شیئی است که می‌توان با آن مانند «فقط داده» رفتار کرد، بدون نگرانی از پیچیدگی‌های مربوط به چیدمان کلاس یا معناهای تعریف‌شده توسط کاربر برای **سازنده، کپی و جابه‌جایی**.

برای مثال:

```cpp
struct S0 { };                        // یک POD
struct S1 { int a; };                 // یک POD
struct S2 { int a; S2(int aa) : a(aa) { } }; // POD نیست (سازنده پیش‌فرض ندارد)
struct S3 { int a; S3(int aa) : a(aa) { } S3() {} }; // یک POD (سازنده پیش‌فرض تعریف‌شده)
struct S4 { int a; S4(int aa) : a(aa) { } S4() = default; }; // یک POD
struct S5 { virtual void f(); };       // POD نیست (تابع مجازی دارد)
struct S6 : S1 { };                   // یک POD
struct S7 : S0 { int b; };            // یک POD
struct S8 : S1 { int b; };            // POD نیست (داده هم در S1 و هم در S8 است)
struct S9 : S0, S1 {};                // یک POD
```

برای اینکه بتوانیم با یک شیء مانند POD رفتار کنیم، آن شیء باید:

* چیدمان پیچیده نداشته باشد (مثلاً vptr نداشته باشد؛ §3.2.3, §20.3.2)،
* سمنتیک کپی غیر استاندارد (تعریف‌شده توسط کاربر) نداشته باشد، و
* سازنده‌ی پیش‌فرض ساده (trivial) داشته باشد.

واضح است که باید تعریف دقیق POD مشخص باشد تا تنها در جاهایی از این بهینه‌سازی‌ها استفاده کنیم که تضمین‌های زبان شکسته نشود.

به‌طور رسمی (§iso.3.9, §iso.9)، یک شیء POD باید:

* **از نوع با چیدمان استاندارد (standard layout type)** باشد،
* **از نوع قابل کپی ساده (trivially copyable)** باشد،
* **و یک سازنده‌ی پیش‌فرض ساده داشته باشد**.

مفهوم مرتبط دیگری هم هست به نام **نوع ساده (trivial type)** که ویژگی‌های زیر را دارد:

* سازنده‌ی پیش‌فرض ساده دارد.
* عملگرهای کپی و جابه‌جایی ساده دارد.

به‌طور غیررسمی، یک سازنده پیش‌فرض ساده است اگر هیچ کاری نیاز به انجام نداشته باشد (اگر نیاز داشتید یکی تعریف کنید، از `=default` استفاده کنید؛ §17.6.1).

یک نوع **چیدمان استاندارد (standard layout)** ندارد اگر:

* عضوی غیر‌استاتیک یا پایه‌ای داشته باشد که خود چیدمان استاندارد ندارد،
* تابع مجازی داشته باشد (§3.2.3, §20.3.2)،
* پایه‌ی مجازی داشته باشد (§21.3.5)،
* عضوی از نوع reference داشته باشد (§7.7)،
* برای داده‌های غیر‌استاتیک، چندین سطح دسترسی (`public/private/protected`) استفاده کند (§20.5)، یا
* مانع بهینه‌سازی‌های مهم چیدمان شود، مانند:

  * داشتن اعضای غیر‌استاتیک در بیش از یک کلاس پایه یا هم در کلاس مشتق و هم در یک پایه، یا
  * داشتن کلاسی پایه از همان نوع به‌عنوان اولین عضو غیر‌استاتیک.

به‌طور کلی، یک نوع **standard layout** نوعی است که چیدمان آن معادل واضحی در زبان C دارد و توسط ABIهای رایج C++ قابل پشتیبانی است.

یک نوع **trivially copyable** است مگر اینکه یک عملیات کپی، جابه‌جایی یا سازنده‌ی غیرساده داشته باشد (§3.2.1.2, §17.6).
به‌طور غیررسمی، یک عملیات کپی ساده است اگر بتوان آن را به‌صورت **کپی بیتی (bitwise copy)** پیاده‌سازی کرد.

چه چیزی باعث می‌شود یک کپی، جابه‌جایی یا مخرب (destructor) غیرساده باشد؟

* اگر توسط کاربر تعریف شده باشد.
* اگر کلاس تابع مجازی داشته باشد.
* اگر کلاس پایه‌ی مجازی داشته باشد.
* اگر کلاس پایه یا عضوی داشته باشد که خود ساده نیست.

یک شیء از نوع built-in به‌طور پیش‌فرض قابل کپی ساده است و چیدمان استاندارد دارد. همچنین، آرایه‌ای از اشیاء قابل کپی ساده، خودش قابل کپی ساده است، و آرایه‌ای از اشیاء با چیدمان استاندارد نیز همان ویژگی را دارد.

به مثال زیر توجه کنید:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count);
```

فرض کنید می‌خواهم حالت ساده را بهینه کنم وقتی که `T` یک POD است. می‌توانم این کار را با فراخوانی `mycopy()` فقط برای PODها انجام دهم، اما این پرخطاست: آیا می‌توانم مطمئن باشم که نگه‌دارنده‌ی کد هرگز `mycopy()` را برای نوعی غیر POD صدا نمی‌زند؟ واقع‌بینانه، خیر.
جایگزین بهتر این است که از `std::copy()` استفاده کنیم، که به احتمال زیاد با همان بهینه‌سازی موردنیاز پیاده‌سازی شده است.

به‌هرحال، این نسخه‌ی عمومی و بهینه‌شده‌ی کد است:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count)
{
    if (is_pod<T>::value)
        memcpy(to, from, count * sizeof(T));
    else
        for (int i = 0; i != count; ++i)
            to[i] = from[i];
}
```

`is_pod` یک ویژگی (type trait) در کتابخانه‌ی استاندارد است (§35.4.1) که در `<type_traits>` تعریف شده و به ما اجازه می‌دهد در کد بپرسیم: «آیا `T` یک POD است؟».
بهترین نکته درباره‌ی `is_pod<T>` این است که ما را از حفظ کردن قوانین دقیق POD بی‌نیاز می‌کند.

توجه داشته باشید که اضافه یا حذف کردن سازنده‌های غیرپیش‌فرض روی **چیدمان یا کارایی** تأثیری ندارد (این در C++98 درست نبود).

اگر احساس کردید می‌خواهید «وکیل زبان» شوید، مفاهیم چیدمان و سادگی (layout و triviality) را در استاندارد (§iso.3.9, §iso.9) مطالعه کنید و به پیامدهای آن‌ها برای برنامه‌نویسان و سازندگان کامپایلر فکر کنید. شاید این کار قبل از اینکه وقت زیادی از شما بگیرد، شما را از این علاقه منصرف کند!

--------------
--------------
--------------
--------------
--------------

## 🟢 چرا POD مهم است؟

* وقتی شیء خیلی ساده باشد (فقط داده)، می‌توانیم آن را مثل یک بلوک بایت جابه‌جا کنیم.
* این خیلی سریع‌تر است چون می‌شود با دستورهای سخت‌افزاری (مثل `memcpy`) کل حافظه را یکجا کپی کرد.
* ولی اگر شیء پیچیده باشد (مثلاً تابع مجازی یا سازنده خاص داشته باشد)، باید یکی‌یکی با دقت جابه‌جا شود.

---

## 🟢 POD دقیقاً یعنی چه؟

یک شیء POD باید این شرایط را داشته باشد:

1. **چیدمان ساده**: حافظه‌اش شبیه struct در C باشد.
2. **کپی‌پذیر به صورت بیتی**: یعنی کافی باشد بیت به بیت جابه‌جایش کنیم.
3. **سازنده پیش‌فرض بی‌کار (trivial)** داشته باشد: یعنی ساختنش هیچ کاری نکند جز رزرو حافظه.

---

## 🟢 چند مفهوم نزدیک

1. **Standard layout (چیدمان استاندارد):**
   یعنی شیء در حافظه، مثل C چیده شده باشد.

   * نباید تابع مجازی داشته باشد.
   * نباید وراثت مجازی داشته باشد.
   * نباید چند بخش public/private با داده غیرstatic داشته باشد.
   * نباید هم در base هم در خودش داده غیرstatic داشته باشد.

2. **Trivially copyable (قابل‌کپی ساده):**
   یعنی می‌شود با یک `memcpy` کل شیء را جابه‌جا کرد.

   * نباید کپی‌ساز، move یا destructor خاص داشته باشد.
   * نباید تابع مجازی یا base مجازی داشته باشد.

3. **Trivial type (نوع ساده):**
   یعنی سازنده پیش‌فرض و عملگر کپی/move همگی trivial باشند.

---

## 🟢 چه چیزی باعث می‌شود trivial نباشد؟

* اگر کپی‌ساز یا move یا destructor را خودت بنویسی → دیگر trivial نیست.
* اگر تابع مجازی داشته باشد → دیگر trivial نیست.
* اگر وراثت مجازی داشته باشد → دیگر trivial نیست.

---

## 🟢 مثال‌ها

```cpp
struct S0 { };              // ✅ POD
struct S1 { int a; };       // ✅ POD
struct S2 { int a; S2(int x):a(x){} }; // ❌ نه POD (سازنده خاص)
struct S3 { int a; S3(){} }; // ✅ POD (سازنده پیش‌فرض trivial)
struct S5 { virtual void f(); }; // ❌ نه POD (تابع مجازی)
struct S6 : S1 { };         // ✅ POD
struct S8 : S1 { int b; };  // ❌ نه POD (داده در base و خودش همزمان)
```

---

## 🟢 در عمل چه کنیم؟

* اگر نوع POD باشد → می‌توانیم سریع با `memcpy` جابه‌جا کنیم.
* اگر نوع غیر POD باشد → باید تک‌تک با `=` کپی کنیم.

کتابخانه استاندارد برای این کار ابزار دارد:

```cpp
#include <type_traits>

if (std::is_pod<T>::value) { /* سریع */ }
else { /* کپی معمولی */ }
```

---

## 🟢 خلاصه در چند کلمه

* **POD**: فقط داده ساده، مثل struct در C.
* **Standard layout**: چیدمانش مثل C باشد.
* **Trivially copyable**: بشود با memcpy کپی کرد.
* **Trivial type**: سازنده و کپی‌ساز خیلی ساده.

----------------------
----------------------
----------------------
----------------------
----------------------

یک شیء از نوع‌های درونی (built-in type) به طور پیش‌فرض **به‌سادگی قابل کپی‌کردن** است (trivially copyable) و **چیدمان استاندارد** دارد (standard layout). همچنین، یک آرایه از اشیای trivially copyable خودش trivially copyable است و یک آرایه از اشیای با چیدمان استاندارد هم چیدمان استاندارد دارد.

یک مثال در نظر بگیر:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count);
```

من می‌خواهم حالت ساده را، وقتی `T` یک **POD** است، بهینه کنم.
می‌توانم کاری کنم که فقط برای PODها `mycopy()` صدا زده شود، اما این کار پرخطاست:
آیا می‌توانم مطمئن باشم برنامه‌نویس دیگری که کد را نگهداری می‌کند همیشه یادش بماند `mycopy()` را روی نوع‌های غیر POD صدا نزند؟ واقع‌بینانه نگاه کنیم، خیر.

راه دیگر این است که از `std::copy()` استفاده کنم، که تقریباً همیشه با بهینه‌سازی لازم پیاده‌سازی شده است.

به هر حال، اینجا کد عمومی و بهینه‌شده را داریم:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count)
{
    if (is_pod<T>::value)
        memcpy(to, from, count * sizeof(T));
    else
        for (int i = 0; i != count; ++i)
            to[i] = from[i];
}
```

`is_pod` یک ویژگی نوع (type property predicate) در کتابخانه استاندارد است (تعریف‌شده در `<type_traits>`) که به ما اجازه می‌دهد در کد بپرسیم: «آیا T یک POD است؟».
بهترین نکته درباره‌ی `is_pod<T>` این است که ما را از حفظ‌کردن تمام قوانین دقیق اینکه چه چیزی POD است یا نه، بی‌نیاز می‌کند.

نکته: اضافه‌کردن یا حذف‌کردن سازنده‌های پیش‌فرض روی **چیدمان یا کارایی** تأثیری ندارد (این موضوع در C++98 درست نبود).

اگر حس می‌کنید می‌خواهید «وکیل زبان» شوید، کافی است مفاهیم layout و triviality را در استاندارد بخوانید (بخش‌های §iso.3.9 و §iso.9) و سعی کنید به پیامدهایشان برای برنامه‌نویس‌ها و سازندگان کامپایلر فکر کنید. این کار شاید قبل از اینکه خیلی وقتتان گرفته شود، شما را از ادامه‌ی این مسیر منصرف کند.

----------------------
----------------------
----------------------
----------------------
----------------------

## Fields
حتی اگر استفاده از یک بایت کامل (مثل یک `char` یا `bool`) برای نمایش یک متغیر دودویی – مثلاً یک کلید روشن/خاموش – پرهزینه به نظر برسد، اما در C++ کوچک‌ترین شیءای که می‌تواند به‌طور مستقل تخصیص داده شود و آدرس‌پذیر باشد همان `char` است (§7.2). با این حال، می‌توان چندین متغیر خیلی کوچک از این نوع را کنار هم در قالب *field*‌ها در یک `struct` قرار داد.

به چنین فیلدی معمولاً *bit-field* گفته می‌شود. یک عضو زمانی به‌صورت *field* تعریف می‌شود که تعداد بیت‌هایی که باید اشغال کند مشخص شود. فیلدهای بدون‌نام نیز مجاز هستند. این‌ها بر معنای فیلدهای نام‌دار اثری ندارند، اما می‌توان از آن‌ها برای بهبود چیدمان در سطح ماشین (وابسته به معماری) استفاده کرد:

```cpp
struct PPN { // R6000 Physical Page Number
    unsigned int PFN : 22;  // Page Frame Number
    int : 3;                // استفاده‌نشده
    unsigned int CCA : 3;   // Cache Coherency Algorithm
    bool nonreachable : 1;
    bool dirty : 1;
    bool valid : 1;
    bool global : 1;
};
```

این مثال همچنین کاربرد اصلی دیگر فیلدها را نشان می‌دهد: نام‌گذاری بخش‌هایی از یک *چیدمان تحمیلی بیرونی*.
یک فیلد باید از نوع عدد صحیح یا نوع شمارشی باشد (§6.2.1). گرفتن آدرس یک فیلد ممکن نیست. با این حال، غیر از این مورد، می‌توان از آن درست مثل سایر متغیرها استفاده کرد. توجه کنید که یک فیلد `bool` واقعاً می‌تواند فقط با یک بیت نمایش داده شود.

در یک هسته سیستم‌عامل یا در یک دیباگر، نوع `PPN` ممکن است به این شکل استفاده شود:

```cpp
void part_of_VM_system(PPN* p)
{
    // ...
    if (p->dirty) {   // محتوا تغییر کرده
        // کپی روی دیسک
        p->dirty = 0;
    }
}
```

شگفت‌آور است که استفاده از فیلدها برای فشرده‌سازی چند متغیر در یک بایت الزاماً باعث صرفه‌جویی در فضا نمی‌شود. این روش فضای داده را کاهش می‌دهد، اما اندازه کدی که برای دستکاری این متغیرها لازم است، روی بیشتر ماشین‌ها افزایش می‌یابد. حتی در برخی برنامه‌ها دیده شده که وقتی متغیرهای دودویی از *bit-field* به `char` تبدیل شدند، کل برنامه کوچک‌تر شده است!

علاوه بر این، معمولاً دسترسی به یک `char` یا `int` بسیار سریع‌تر از دسترسی به یک فیلد است. فیلدها در واقع فقط یک میان‌بُر راحت برای استفاده از عملگرهای منطقی بیتی (§11.1.1) هستند تا بتوان از یک بخش خاص از یک کلمه (word) اطلاعات استخراج یا در آن درج کرد.

## Unions
یک **union** نوعی **struct** است که در آن تمام اعضا در یک آدرس قرار می‌گیرند، بنابراین **union فقط به اندازهٔ بزرگ‌ترین عضو خود فضا اشغال می‌کند**. طبیعتاً، یک union در هر لحظه می‌تواند فقط مقدار یکی از اعضایش را نگه دارد.

به‌عنوان مثال، در نظر بگیرید یک **ورودی جدول نمادها (symbol table)** که شامل یک نام و یک مقدار است:

```cpp
enum Type { str, num };

struct Entry {
    char* name;
    Type t;
    char* s; // استفاده شود اگر t == str
    int i;   // استفاده شود اگر t == num
};

void f(Entry* p)
{
    if (p->t == str)
        cout << p->s;
    // ...
}
```

اعضای **s** و **i** هرگز نمی‌توانند هم‌زمان استفاده شوند، بنابراین فضا هدر می‌رود. این فضا به‌راحتی می‌تواند با مشخص کردن اینکه هر دو عضو یک **union** باشند، بازیابی شود:

```cpp
union Value {
    char* s;
    int i;
};
```

زبان ++C پیگیری نمی‌کند که union در حال حاضر چه نوع مقداری نگه می‌دارد، بنابراین این وظیفهٔ برنامه‌نویس است:

```cpp
struct Entry {
    char* name;
    Type t;
    Value v; // اگر t == str از v.s استفاده شود؛ اگر t == num از v.i استفاده شود
};

void f(Entry* p)
{
    if (p->t == str)
        cout << p->v.s;
    // ...
}
```

برای جلوگیری از خطا، می‌توان union را **کپسوله (encapsulate)** کرد تا ارتباط بین فیلد نوع (**type field**) و دسترسی به اعضای union تضمین شود (§8.3.2).

---

گاهی اوقات **union به‌اشتباه برای "تبدیل نوع" استفاده می‌شود**. این سوءاستفاده عمدتاً توسط برنامه‌نویسانی انجام می‌شود که در زبان‌هایی آموزش دیده‌اند که امکانات تبدیل نوع صریح ندارند، بنابراین به "تقلب" متوسل می‌شوند.

برای مثال، کد زیر یک **int** را به یک **int**\* "تبدیل" می‌کند، صرفاً با فرض اینکه از نظر بیت‌به‌بیت معادل هستند:

```cpp
union Fudge {
    int i;
    int* p;
};

int* cheat(int i)
{
    Fudge a;
    a.i = i;
    return a.p; // استفادهٔ بد
}
```

اما این در واقع هیچ **تبدیلی** انجام نمی‌دهد. در برخی ماشین‌ها، یک **int** و یک **int**\* اندازهٔ یکسانی ندارند، و در برخی دیگر هیچ عدد صحیحی نمی‌تواند آدرس فرد داشته باشد. چنین استفاده‌ای از union **خطرناک و غیرقابل‌انتقال (nonportable)** است.

اگر واقعاً به چنین تبدیل ذاتاً زشتی نیاز دارید، از **عملگر تبدیل نوع صریح** استفاده کنید تا خواننده متوجه شود چه اتفاقی در حال رخ دادن است:

```cpp
int* cheat2(int i)
{
    return reinterpret_cast<int*>(i); // به‌وضوح زشت و خطرناک
}
```

اینجا دست‌کم کامپایلر این شانس را دارد که در صورت متفاوت بودن اندازهٔ اشیاء به شما هشدار بدهد و این کد همانند یک **انگشت زخمی آشکار** جلوه می‌کند.

---

استفاده از **union** می‌تواند برای فشرده‌سازی داده‌ها و از این طریق برای بهبود کارایی **ضروری** باشد.
با این حال، بیشتر برنامه‌ها از union سود چندانی نمی‌برند و unionها به‌طور کلی **مستعد خطا** هستند.

به همین دلیل، من unionها را یک قابلیت **بیش‌ازحد‌استفاده‌شده** می‌دانم؛ هر وقت می‌توانید، از آن‌ها اجتناب کنید.

