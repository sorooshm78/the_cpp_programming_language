## Introduction
کلید استفاده مؤثر از ++C تعریف و به‌کارگیری **نوع‌های تعریف‌شده توسط کاربر** است.
این فصل سه گونه‌ی ابتداییِ این مفهوم را معرفی می‌کند:

* **struct** (ساختار): دنباله‌ای از عناصر (که *عضو* نامیده می‌شوند) با نوع‌های دلخواه.
* **union**: ساختاری که در هر لحظه فقط مقدار یکی از اعضایش را نگه می‌دارد.
* **enum** (شمارش): نوعی که مجموعه‌ای از ثابت‌های نام‌گذاری‌شده (*enumerator*) را تعریف می‌کند.
* **enum class** (شمارش با محدوده یا Scoped Enumeration): نوعی شمارش که اعضای شمارش‌شده در محدوده‌ی خود آن شمارش قرار دارند و هیچ تبدیل ضمنی به نوع‌های دیگر انجام نمی‌شود.

گونه‌های مختلف این نوع‌های ساده از نخستین روزهای پیدایش ++C وجود داشته‌اند.
آن‌ها عمدتاً بر نمایش داده متمرکز هستند و ستون فقرات بیشتر برنامه‌نویسی به سبک C محسوب می‌شوند.

مفهوم **struct** که اینجا توضیح داده شده، شکلی ساده از یک **کلاس** است (بخش 3.2، فصل 16).

## Structures
آرایه مجموعه‌ای از عناصری با یک نوع یکسان است. در ساده‌ترین حالت، یک **struct** (ساختار) مجموعه‌ای از عناصری با نوع‌های دلخواه است. برای مثال:

```cpp
struct Address {
    const char* name;   // "Jim Dandy"
    int number;         // 61
    const char* street; // "South St"
    const char* town;   // "New Providence"
    char state[2];      // 'N' 'J'
    const char* zip;    // "07974"
};
```

این تعریف، نوعی به نام `Address` ایجاد می‌کند که شامل اطلاعاتی است که برای ارسال نامه به یک فرد در ایالات متحده آمریکا لازم است. به علامت **;** انتهای تعریف دقت کنید.

متغیرهای نوع `Address` درست مانند سایر متغیرها تعریف می‌شوند و اعضای آن‌ها را می‌توان با عملگر **`.`** (نقطه) دسترسی داد. برای مثال:

```cpp
void f()
{
    Address jd;
    jd.name = "Jim Dandy";
    jd.number = 61;
}
```

متغیرهای ساختاری را می‌توان با استفاده از یادداشت **`{}`** مقداردهی اولیه کرد (§6.3.5). برای مثال:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};
```

دقت کنید که `jd.state` را نمی‌توان با رشته `"NJ"` مقداردهی کرد. رشته‌ها با کاراکتر صفر `'\0'` خاتمه می‌یابند، بنابراین `"NJ"` شامل سه کاراکتر است — یک کاراکتر بیشتر از آنچه در `jd.state` جا می‌شود. در این مثال، عمداً از نوع‌های سطح پایین برای اعضا استفاده شده تا نشان داده شود که چگونه این کار انجام می‌شود و چه مشکلاتی می‌تواند ایجاد کند.

ساختارها اغلب از طریق اشاره‌گرها با عملگر **`->`** (دسترسی از طریق اشاره‌گر به struct) استفاده می‌شوند. برای مثال:

```cpp
void print_addr(Address* p)
{
    cout << p->name << '\n'
         << p->number << ' ' << p->street << '\n'
         << p->town << '\n'
         << p->state[0] << p->state[1] << ' ' << p->zip << '\n';
}
```

وقتی `p` یک اشاره‌گر است، عبارت `p->m` معادل `( *p ).m` است.

به‌طور جایگزین، یک **struct** می‌تواند به‌صورت **ارجاع (reference)** به تابع داده شود و با عملگر **`.`** (دسترسی به عضو ساختار) استفاده شود:

```cpp
void print_addr2(const Address& r)
{
    cout << r.name << '\n'
         << r.number << ' ' << r.street << '\n'
         << r.town << '\n'
         << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
```

بحث درباره‌ی ارسال آرگومان‌ها در بخش §12.2 آمده است.

اشیای نوع ساختار را می‌توان **اختصاص (assign)** داد، به‌عنوان **آرگومان به تابع ارسال** کرد و به‌عنوان **نتیجه از یک تابع بازگرداند**. برای مثال:

```cpp
Address current;

Address set_current(Address next)
{
    Address prev = current;
    current = next;
    return prev;
}
```

سایر عملیات ممکن، مانند مقایسه (`==` و `!=`)، به‌طور پیش‌فرض در دسترس نیستند.
با این حال، کاربر می‌تواند این عملگرها را تعریف کند (§3.2.1.1، فصل 18).

## struct Layout
یک شیء از نوع **struct** اعضای خود را به ترتیبی که اعلان شده‌اند در حافظه نگه می‌دارد.
برای مثال، می‌توانیم داده‌های ساده‌ی یک دستگاه اندازه‌گیری را در ساختاری مانند زیر ذخیره کنیم:

```cpp
struct Readout {
    char hour;  // [0:23]
    int value;
    char seq;   // علامت ترتیبی ['a':'z']
};
```

می‌توانید تصور کنید که اعضای یک شیء از نوع `Readout` در حافظه به این صورت چیده می‌شوند:

```
hour:   value:   seq:
```

اعضا دقیقاً به ترتیبی که اعلان شده‌اند در حافظه تخصیص داده می‌شوند، بنابراین آدرس `hour` باید کوچک‌تر از آدرس `value` باشد (نگاه کنید به §8.2.6).

---

با این حال، **اندازه‌ی یک شیء از نوع struct الزاماً برابر با مجموع اندازه‌ی اعضای آن نیست**.
دلیلش این است که بسیاری از ماشین‌ها (پردازنده‌ها) نیاز دارند که اشیای مربوط به بعضی انواع داده‌ها روی مرزهای خاصی (وابسته به معماری) قرار گیرند یا دست‌کم در این حالت دسترسی به آن‌ها کارآمدتر است.
برای مثال، معمولاً اعداد صحیح (`int`) روی مرزهای کلمه (word boundaries) قرار داده می‌شوند. روی چنین ماشین‌هایی، گفته می‌شود که اشیا باید «هم‌تراز (aligned)» باشند (§6.2.9). این موضوع باعث ایجاد «حفره‌ها» (فضاهای استفاده‌نشده) در ساختارها می‌شود.

یک چینش واقعی‌تر از `Readout` روی ماشینی که `int` آن ۴ بایتی است، چنین خواهد بود:

```
hour:
value:
seq:
```

در این حالت، همانند بسیاری از ماشین‌ها، `sizeof(Readout)` برابر **۱۲** است، نه **۶** (که کسی شاید ساده‌انگارانه از جمع اندازه‌ی اعضا انتظار داشته باشد).

---

می‌توانید با مرتب‌سازی اعضا بر اساس اندازه (از بزرگ‌ترین به کوچک‌ترین) فضای هدررفته را کاهش دهید.
برای مثال:

```cpp
struct Readout {
    int value;
    char hour;  // [0:23]
    char seq;   // علامت ترتیبی ['a':'z']
};
```

چینش در این حالت:

```
value:
(hour, seq):
```

با این حال، همچنان یک «حفره» ۲ بایتی باقی می‌ماند و `sizeof(Readout)` برابر **۸** خواهد شد.
علتش این است که هنگام قرار دادن دو شیء پشت سر هم (مثلاً در یک آرایه از `Readout`ها) باید هم‌ترازی حفظ شود.
پس اندازه‌ی یک آرایه‌ی ۱۰ عضوی از نوع `Readout` برابر است با:

```
10 * sizeof(Readout)
```

---

به طور کلی، بهتر است اعضا را بر اساس **خوانایی** کد مرتب کنید و فقط در صورتی به مرتب‌سازی بر اساس اندازه فکر کنید که واقعاً نیاز به بهینه‌سازی ثابت شده باشد.

استفاده از چند **specifier دسترسی** (یعنی `public`، `private` یا `protected`) هم می‌تواند روی چیدمان حافظه تأثیر بگذارد (§20.5).

## struct Names
نام یک نوع (type) بلافاصله پس از این‌که در کد دیده شد قابل استفاده می‌شود، نه این‌که فقط بعد از کامل دیده شدن اعلان آن.
برای مثال:

```cpp
struct Link {
    Link* previous;
    Link* successor;
};
```

با این حال، امکان اعلان اشیای جدید از یک struct تا زمانی که اعلان کامل آن struct دیده نشود وجود ندارد.
برای مثال:

```cpp
struct No_good {
    No_good member; // خطا: تعریف بازگشتی
};
```

این خطا است چون کامپایلر قادر به تعیین اندازه‌ی `No_good` نیست.
برای اینکه دو (یا بیشتر) struct بتوانند به یکدیگر اشاره کنند، می‌توانیم نامی را به عنوان نام یک struct معرفی کنیم.
برای مثال:

```cpp
struct List; // اعلان نام struct: List بعداً تعریف خواهد شد
struct Link {
    Link* pre;
    Link* suc;
    List* member_of;
    int data;
};
struct List {
    Link* head;
};
```

بدون اعلان اول برای `List`، استفاده از نوع اشاره‌گر `List*` در تعریف `Link` یک خطای نحوی بود.

---

نام یک struct می‌تواند قبل از این‌که نوع آن تعریف شود استفاده شود، به شرطی که آن استفاده نیازی به دانستن نام اعضا یا اندازه‌ی آن struct نداشته باشد.
با این حال، تا تکمیل شدن اعلان یک struct، آن struct یک **نوع ناقص (incomplete type)** محسوب می‌شود.
برای مثال:

```cpp
struct S;   // "S" نام یک نوع است
extern S a;
S f();
void g(S);
S* h(S*);
```

اما بسیاری از این اعلان‌ها را نمی‌توان استفاده کرد مگر اینکه نوع `S` تعریف شده باشد:

```cpp
void k(S* p)
{
    S a;       // خطا: S تعریف نشده؛ برای تخصیص اندازه لازم است
    f();       // خطا: S تعریف نشده؛ برای بازگرداندن مقدار اندازه لازم است
    g(a);      // خطا: S تعریف نشده؛ برای ارسال آرگومان اندازه لازم است
    p->m = 7;  // خطا: S تعریف نشده؛ نام عضو شناخته نیست
    S* q = h(p); // درست: اشاره‌گرها می‌توانند تخصیص داده و ارسال شوند
    q->m = 7;    // خطا: S تعریف نشده؛ نام عضو شناخته نیست
}
```

---

به دلایلی که به تاریخچه‌ی اولیه‌ی زبان C بازمی‌گردد، امکان دارد یک struct و یک غیر-struct با یک نام یکسان در همان دامنه تعریف شوند.
برای مثال:

```cpp
struct stat { /* ... */ };
int stat(char* name, struct stat* buf);
```

در این حالت، نام ساده‌ی `stat` مربوط به غیر-struct است، و برای اشاره به struct باید از پیشوند `struct` استفاده شود.
به همین ترتیب، کلمات کلیدی `class`، `union` و `enum` نیز می‌توانند به عنوان پیشوند برای رفع ابهام استفاده شوند.

با این حال، بهتر است نام‌ها را به‌گونه‌ای انتخاب کنیم که نیاز به چنین رفع ابهامی به وجود نیاید.

## Structures and Classes
یک **struct** در واقع همان **class** است با این تفاوت که اعضای آن به‌طور پیش‌فرض **public** هستند. بنابراین، یک struct می‌تواند **تابع عضو** هم داشته باشد (بخش §2.3.2 و فصل 16). به‌طور خاص، یک struct می‌تواند **سازنده (constructor)** داشته باشد.
برای مثال:

```cpp
struct Points {
    vector<Point> elem; // باید حداقل یک Point در خود داشته باشد
    Points(Point p0) { elem.push_back(p0); }
    Points(Point p0, Point p1) { elem.push_back(p0); elem.push_back(p1); }
    // ...
};
```

```cpp
Points x0; // خطا: سازنده‌ی پیش‌فرض وجود ندارد
Points x1{ {100,200} }; // یک Point
Points x1{ {100,200}, {300,400} }; // دو Point
```

---

نیازی نیست برای مقداردهی اعضا به ترتیب، حتماً یک سازنده تعریف کنید.
برای مثال:

```cpp
struct Point {
    int x, y;
};
```

```cpp
Point p0;       // خطرناک: اگر در محدوده‌ی محلی باشد بدون مقدار اولیه است (§6.3.5.1)
Point p1 {};    // سازنده‌ی پیش‌فرض: {{},{}} یعنی {0,0}
Point p2 {1};   // عضو دوم به‌طور پیش‌فرض مقداردهی می‌شود: {1,{}} یعنی {1,0}
Point p3 {1,2}; // {1,2}
```

---

**سازنده‌ها** زمانی لازم می‌شوند که بخواهید:

* ترتیب آرگومان‌ها را تغییر دهید،
* آرگومان‌ها را اعتبارسنجی کنید،
* آرگومان‌ها را اصلاح کنید،
* یا **invariant**ها (قیود پایدار) برقرار کنید (§2.4.3.2، §13.4).

برای مثال:

```cpp
struct Address {
    string name;    // "Jim Dandy"
    int number;     // 61
    string street;  // "South St"
    string town;    // "New Providence"
    char state[2];  // 'N' 'J'
    char zip[5];    // 07974
    Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
};
```

اینجا یک **سازنده** اضافه شده تا مطمئن شویم تمام اعضا مقداردهی شده‌اند و بتوانیم کد پستی را با یک رشته و یک عدد دریافت کنیم (نه اینکه مجبور شویم تک‌تک کاراکترها را دستکاری کنیم).

مثال استفاده:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    "NJ", 7974 // توجه: 07974 عدد هشت‌شانزدهی محسوب می‌شود (§6.2.4.1)
};
```

---

سازنده‌ی `Address` می‌تواند این‌طور پیاده‌سازی شود:

```cpp
Address::Address(const string& n, int nu, const string& s,
                 const string& t, const string& st, int z)
    // اعتبارسنجی کد پستی
    :name{n},
     number{nu},
     street{s},
     town{t}
{
    if (st.size()!=2)
        error("State abbreviation should be two characters");
    state = {st[0], st[1]}; // ذخیره‌ی کد ایالت به‌صورت کاراکتر

    ostringstream ost; // رشته‌جریان خروجی؛ نگاه کنید به §38.4.2
    ost << z;          // استخراج کاراکترها از int
    string zi {ost.str()};

    switch (zi.size()) {
    case 5:
        zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
        break;
    case 4: // با ‘0’ شروع می‌شود
        zip = {'0', zi[0], zi[1], zi[2], zi[3]};
        break;
    default:
        error("unexpected ZIP code format");
    }

    // ... بررسی کنید که کد معتبر باشد ...
}
```

## Structures and Arrays
به‌طور طبیعی می‌توانیم آرایه‌ای از **struct**‌ها و همچنین **struct**‌هایی شامل آرایه داشته باشیم. برای مثال:

```cpp
struct Point {
    int x, y;
};
Point points[3] {{1,2},{3,4},{5,6}};
int x2 = points[2].x;

struct Array {
    Point elem[3];
};
Array points2 {{1,2},{3,4},{5,6}};
int y2 = points2.elem[2].y;
```

قرار دادن یک آرایهٔ درون‌ساخته (built-in array) در یک **struct** به ما اجازه می‌دهد آن آرایه را مثل یک شیء در نظر بگیریم:
می‌توانیم **struct** حاوی آن را در **مقداردهی اولیه** (از جمله در ارسال آرگومان و بازگرداندن از تابع) و همچنین در **عملیات انتساب** کپی کنیم. برای مثال:

```cpp
Array shift(Array a, Point p)
{
    for (int i=0; i!=3; ++i) {
        a.elem[i].x += p.x;
        a.elem[i].y += p.y;
    }
    return a;
}
Array ax = shift(points2,{10,20});
```

یادداشت مربوط به `Array` کمی ابتدایی است: چرا `i!=3`؟ چرا باید مرتب `.elem[i]` را تکرار کنیم؟ چرا فقط المان‌هایی از نوع `Point`؟
کتابخانهٔ استاندارد، `std::array` را (بخش §34.2.1) به عنوان یک توسعهٔ کامل‌تر و زیباتر از ایدهٔ آرایهٔ با اندازه ثابت به صورت struct فراهم کرده است:

```cpp
template<typename T, size_t N >
struct array { // ساده‌شده (بخش §34.2.1 را ببینید)
    T elem[N];

    T* begin() noexcept { return elem; }
    const T* begin() const noexcept { return elem; }

    T* end() noexcept { return elem+N; }
    const T* end() const noexcept { return elem+N; }

    constexpr size_t size() noexcept;

    T& operator[](size_t n) { return elem[n]; }
    const T& operator[](size_type n) const { return elem[n]; }

    T* data() noexcept { return elem; }
    const T* data() const noexcept { return elem; }
    // ...
};
```

این `array` یک **قالب (template)** است تا هر تعداد دلخواهی از عناصر هر نوع دلخواهی را پشتیبانی کند. همچنین به طور مستقیم با امکان **استثناها** (§13.5.1.1) و اشیاء **const** (§16.2.9.1) سروکار دارد. با استفاده از `array` می‌توانیم چنین بنویسیم:

```cpp
struct Point {
    int x,y;
};
using Array = array<Point,3>; // آرایه‌ای از 3 Point

Array points {{1,2},{3,4},{5,6}};
int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
    for (int i=0; i!=a.size(); ++i) {
        a[i].x += p.x;
        a[i].y += p.y;
    }
    return a;
}
Array ax = shift(points,{10,20});
```

مزایای اصلی `std::array` نسبت به آرایهٔ درون‌ساخته این است که:

* یک نوع شیء واقعی است (دارای انتساب و ...).
* به طور ضمنی به یک اشاره‌گر به یک عنصر منفرد تبدیل نمی‌شود.

مثال:

```cpp
ostream& operator<<(ostream& os, Point p)
{
    cout << '{' << p.x << ',' << p.y << '}';
}

void print(Point a[],int s) // باید تعداد عناصر مشخص شود
{
    for (int i=0; i!=s; ++i)
        cout << a[i] << '\n';
}

template<typename T, int N>
void print(array<T,N>& a)
{
    for (int i=0; i!=a.size(); ++i)
        cout << a[i] << '\n';
}

Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر

void f()
{
    print(point1,4); // 4 یک خطای بد است
    print(point2);
}
```

عیب `std::array` در مقایسه با آرایهٔ درون‌ساخته این است که نمی‌توانیم تعداد عناصر را از طول **initializer** استنتاج کنیم:

```cpp
Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point> point3 = {{1,2},{3,4},{5,6}};   // خطا
```

## Type Equivalence
دو **struct** حتی زمانی که اعضای یکسانی دارند، نوع‌های متفاوتی محسوب می‌شوند.
برای مثال:

```cpp
struct S1 { int a; };
struct S2 { int a; };
```

`S1` و `S2` دو نوع متفاوت هستند، بنابراین:

```cpp
S1 x;
S2 y = x; // خطا: عدم تطابق نوع
```

یک **struct** همچنین با نوعی که به‌عنوان عضو در آن استفاده شده، متفاوت است.
برای مثال:

```cpp
S1 x;
int i = x; // خطا: عدم تطابق نوع
```

هر **struct** باید در یک برنامه تعریف یکتایی داشته باشد (§15.2.3).

## 8.2.6 Plain Old Data
گاهی اوقات می‌خواهیم با یک شیء مثل «داده‌ی خام قدیمی» (**Plain Old Data = POD**) رفتار کنیم (یعنی به‌عنوان یک دنباله‌ی پیوسته از بایت‌ها در حافظه) و نگران مفاهیم معنایی پیشرفته‌تر، مانند **چندریختی در زمان اجرا** (§3.2.3, §20.3.2)، **سمنتیک کپی تعریف‌شده توسط کاربر** (§3.3, §17.5) و غیره نباشیم.
دلیل انجام این کار اغلب این است که بتوانیم اشیاء را به مؤثرترین شکلی که سخت‌افزار اجازه می‌دهد جابه‌جا کنیم.

برای مثال، کپی کردن یک آرایه‌ی 100 عنصری با 100 بار فراخوانی سازنده‌ی کپی به‌طور معمول به‌اندازه‌ی یک فراخوانی به `std::memcpy()` سریع نیست، چون `memcpy` معمولاً تنها از یک دستور سخت‌افزاری **انتقال بلوکی حافظه** استفاده می‌کند. حتی اگر سازنده کپی inline شود، ممکن است بهینه‌ساز نتواند چنین بهینه‌سازی‌ای را کشف کند. این‌گونه «ترفندها» در پیاده‌سازی **کانتینرها** (مانند `vector`) و در **روال‌های سطح پایین I/O** متداول و مهم هستند، اما در کدهای سطح بالاتر غیرضروری بوده و بهتر است از آن‌ها پرهیز شود.

بنابراین، یک **POD** شیئی است که می‌توان با آن مانند «فقط داده» رفتار کرد، بدون نگرانی از پیچیدگی‌های مربوط به چیدمان کلاس یا معناهای تعریف‌شده توسط کاربر برای **سازنده، کپی و جابه‌جایی**.

برای مثال:

```cpp
struct S0 { };                        // یک POD
struct S1 { int a; };                 // یک POD
struct S2 { int a; S2(int aa) : a(aa) { } }; // POD نیست (سازنده پیش‌فرض ندارد)
struct S3 { int a; S3(int aa) : a(aa) { } S3() {} }; // یک POD (سازنده پیش‌فرض تعریف‌شده)
struct S4 { int a; S4(int aa) : a(aa) { } S4() = default; }; // یک POD
struct S5 { virtual void f(); };       // POD نیست (تابع مجازی دارد)
struct S6 : S1 { };                   // یک POD
struct S7 : S0 { int b; };            // یک POD
struct S8 : S1 { int b; };            // POD نیست (داده هم در S1 و هم در S8 است)
struct S9 : S0, S1 {};                // یک POD
```

برای اینکه بتوانیم با یک شیء مانند POD رفتار کنیم، آن شیء باید:

* چیدمان پیچیده نداشته باشد (مثلاً vptr نداشته باشد؛ §3.2.3, §20.3.2)،
* سمنتیک کپی غیر استاندارد (تعریف‌شده توسط کاربر) نداشته باشد، و
* سازنده‌ی پیش‌فرض ساده (trivial) داشته باشد.

واضح است که باید تعریف دقیق POD مشخص باشد تا تنها در جاهایی از این بهینه‌سازی‌ها استفاده کنیم که تضمین‌های زبان شکسته نشود.

به‌طور رسمی (§iso.3.9, §iso.9)، یک شیء POD باید:

* **از نوع با چیدمان استاندارد (standard layout type)** باشد،
* **از نوع قابل کپی ساده (trivially copyable)** باشد،
* **و یک سازنده‌ی پیش‌فرض ساده داشته باشد**.

مفهوم مرتبط دیگری هم هست به نام **نوع ساده (trivial type)** که ویژگی‌های زیر را دارد:

* سازنده‌ی پیش‌فرض ساده دارد.
* عملگرهای کپی و جابه‌جایی ساده دارد.

به‌طور غیررسمی، یک سازنده پیش‌فرض ساده است اگر هیچ کاری نیاز به انجام نداشته باشد (اگر نیاز داشتید یکی تعریف کنید، از `=default` استفاده کنید؛ §17.6.1).

یک نوع **چیدمان استاندارد (standard layout)** ندارد اگر:

* عضوی غیر‌استاتیک یا پایه‌ای داشته باشد که خود چیدمان استاندارد ندارد،
* تابع مجازی داشته باشد (§3.2.3, §20.3.2)،
* پایه‌ی مجازی داشته باشد (§21.3.5)،
* عضوی از نوع reference داشته باشد (§7.7)،
* برای داده‌های غیر‌استاتیک، چندین سطح دسترسی (`public/private/protected`) استفاده کند (§20.5)، یا
* مانع بهینه‌سازی‌های مهم چیدمان شود، مانند:

  * داشتن اعضای غیر‌استاتیک در بیش از یک کلاس پایه یا هم در کلاس مشتق و هم در یک پایه، یا
  * داشتن کلاسی پایه از همان نوع به‌عنوان اولین عضو غیر‌استاتیک.

به‌طور کلی، یک نوع **standard layout** نوعی است که چیدمان آن معادل واضحی در زبان C دارد و توسط ABIهای رایج C++ قابل پشتیبانی است.

یک نوع **trivially copyable** است مگر اینکه یک عملیات کپی، جابه‌جایی یا سازنده‌ی غیرساده داشته باشد (§3.2.1.2, §17.6).
به‌طور غیررسمی، یک عملیات کپی ساده است اگر بتوان آن را به‌صورت **کپی بیتی (bitwise copy)** پیاده‌سازی کرد.

چه چیزی باعث می‌شود یک کپی، جابه‌جایی یا مخرب (destructor) غیرساده باشد؟

* اگر توسط کاربر تعریف شده باشد.
* اگر کلاس تابع مجازی داشته باشد.
* اگر کلاس پایه‌ی مجازی داشته باشد.
* اگر کلاس پایه یا عضوی داشته باشد که خود ساده نیست.

یک شیء از نوع built-in به‌طور پیش‌فرض قابل کپی ساده است و چیدمان استاندارد دارد. همچنین، آرایه‌ای از اشیاء قابل کپی ساده، خودش قابل کپی ساده است، و آرایه‌ای از اشیاء با چیدمان استاندارد نیز همان ویژگی را دارد.

به مثال زیر توجه کنید:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count);
```

فرض کنید می‌خواهم حالت ساده را بهینه کنم وقتی که `T` یک POD است. می‌توانم این کار را با فراخوانی `mycopy()` فقط برای PODها انجام دهم، اما این پرخطاست: آیا می‌توانم مطمئن باشم که نگه‌دارنده‌ی کد هرگز `mycopy()` را برای نوعی غیر POD صدا نمی‌زند؟ واقع‌بینانه، خیر.
جایگزین بهتر این است که از `std::copy()` استفاده کنیم، که به احتمال زیاد با همان بهینه‌سازی موردنیاز پیاده‌سازی شده است.

به‌هرحال، این نسخه‌ی عمومی و بهینه‌شده‌ی کد است:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count)
{
    if (is_pod<T>::value)
        memcpy(to, from, count * sizeof(T));
    else
        for (int i = 0; i != count; ++i)
            to[i] = from[i];
}
```

`is_pod` یک ویژگی (type trait) در کتابخانه‌ی استاندارد است (§35.4.1) که در `<type_traits>` تعریف شده و به ما اجازه می‌دهد در کد بپرسیم: «آیا `T` یک POD است؟».
بهترین نکته درباره‌ی `is_pod<T>` این است که ما را از حفظ کردن قوانین دقیق POD بی‌نیاز می‌کند.

توجه داشته باشید که اضافه یا حذف کردن سازنده‌های غیرپیش‌فرض روی **چیدمان یا کارایی** تأثیری ندارد (این در C++98 درست نبود).

اگر احساس کردید می‌خواهید «وکیل زبان» شوید، مفاهیم چیدمان و سادگی (layout و triviality) را در استاندارد (§iso.3.9, §iso.9) مطالعه کنید و به پیامدهای آن‌ها برای برنامه‌نویسان و سازندگان کامپایلر فکر کنید. شاید این کار قبل از اینکه وقت زیادی از شما بگیرد، شما را از این علاقه منصرف کند!

--------------
--------------
--------------
--------------
--------------

## 🟢 چرا POD مهم است؟

* وقتی شیء خیلی ساده باشد (فقط داده)، می‌توانیم آن را مثل یک بلوک بایت جابه‌جا کنیم.
* این خیلی سریع‌تر است چون می‌شود با دستورهای سخت‌افزاری (مثل `memcpy`) کل حافظه را یکجا کپی کرد.
* ولی اگر شیء پیچیده باشد (مثلاً تابع مجازی یا سازنده خاص داشته باشد)، باید یکی‌یکی با دقت جابه‌جا شود.

---

## 🟢 POD دقیقاً یعنی چه؟

یک شیء POD باید این شرایط را داشته باشد:

1. **چیدمان ساده**: حافظه‌اش شبیه struct در C باشد.
2. **کپی‌پذیر به صورت بیتی**: یعنی کافی باشد بیت به بیت جابه‌جایش کنیم.
3. **سازنده پیش‌فرض بی‌کار (trivial)** داشته باشد: یعنی ساختنش هیچ کاری نکند جز رزرو حافظه.

---

## 🟢 چند مفهوم نزدیک

1. **Standard layout (چیدمان استاندارد):**
   یعنی شیء در حافظه، مثل C چیده شده باشد.

   * نباید تابع مجازی داشته باشد.
   * نباید وراثت مجازی داشته باشد.
   * نباید چند بخش public/private با داده غیرstatic داشته باشد.
   * نباید هم در base هم در خودش داده غیرstatic داشته باشد.

2. **Trivially copyable (قابل‌کپی ساده):**
   یعنی می‌شود با یک `memcpy` کل شیء را جابه‌جا کرد.

   * نباید کپی‌ساز، move یا destructor خاص داشته باشد.
   * نباید تابع مجازی یا base مجازی داشته باشد.

3. **Trivial type (نوع ساده):**
   یعنی سازنده پیش‌فرض و عملگر کپی/move همگی trivial باشند.

---

## 🟢 چه چیزی باعث می‌شود trivial نباشد؟

* اگر کپی‌ساز یا move یا destructor را خودت بنویسی → دیگر trivial نیست.
* اگر تابع مجازی داشته باشد → دیگر trivial نیست.
* اگر وراثت مجازی داشته باشد → دیگر trivial نیست.

---

## 🟢 مثال‌ها

```cpp
struct S0 { };              // ✅ POD
struct S1 { int a; };       // ✅ POD
struct S2 { int a; S2(int x):a(x){} }; // ❌ نه POD (سازنده خاص)
struct S3 { int a; S3(){} }; // ✅ POD (سازنده پیش‌فرض trivial)
struct S5 { virtual void f(); }; // ❌ نه POD (تابع مجازی)
struct S6 : S1 { };         // ✅ POD
struct S8 : S1 { int b; };  // ❌ نه POD (داده در base و خودش همزمان)
```

---

## 🟢 در عمل چه کنیم؟

* اگر نوع POD باشد → می‌توانیم سریع با `memcpy` جابه‌جا کنیم.
* اگر نوع غیر POD باشد → باید تک‌تک با `=` کپی کنیم.

کتابخانه استاندارد برای این کار ابزار دارد:

```cpp
#include <type_traits>

if (std::is_pod<T>::value) { /* سریع */ }
else { /* کپی معمولی */ }
```

---

## 🟢 خلاصه در چند کلمه

* **POD**: فقط داده ساده، مثل struct در C.
* **Standard layout**: چیدمانش مثل C باشد.
* **Trivially copyable**: بشود با memcpy کپی کرد.
* **Trivial type**: سازنده و کپی‌ساز خیلی ساده.

----------------------
----------------------
----------------------
----------------------
----------------------

یک شیء از نوع‌های درونی (built-in type) به طور پیش‌فرض **به‌سادگی قابل کپی‌کردن** است (trivially copyable) و **چیدمان استاندارد** دارد (standard layout). همچنین، یک آرایه از اشیای trivially copyable خودش trivially copyable است و یک آرایه از اشیای با چیدمان استاندارد هم چیدمان استاندارد دارد.

یک مثال در نظر بگیر:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count);
```

من می‌خواهم حالت ساده را، وقتی `T` یک **POD** است، بهینه کنم.
می‌توانم کاری کنم که فقط برای PODها `mycopy()` صدا زده شود، اما این کار پرخطاست:
آیا می‌توانم مطمئن باشم برنامه‌نویس دیگری که کد را نگهداری می‌کند همیشه یادش بماند `mycopy()` را روی نوع‌های غیر POD صدا نزند؟ واقع‌بینانه نگاه کنیم، خیر.

راه دیگر این است که از `std::copy()` استفاده کنم، که تقریباً همیشه با بهینه‌سازی لازم پیاده‌سازی شده است.

به هر حال، اینجا کد عمومی و بهینه‌شده را داریم:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count)
{
    if (is_pod<T>::value)
        memcpy(to, from, count * sizeof(T));
    else
        for (int i = 0; i != count; ++i)
            to[i] = from[i];
}
```

`is_pod` یک ویژگی نوع (type property predicate) در کتابخانه استاندارد است (تعریف‌شده در `<type_traits>`) که به ما اجازه می‌دهد در کد بپرسیم: «آیا T یک POD است؟».
بهترین نکته درباره‌ی `is_pod<T>` این است که ما را از حفظ‌کردن تمام قوانین دقیق اینکه چه چیزی POD است یا نه، بی‌نیاز می‌کند.

نکته: اضافه‌کردن یا حذف‌کردن سازنده‌های پیش‌فرض روی **چیدمان یا کارایی** تأثیری ندارد (این موضوع در C++98 درست نبود).

اگر حس می‌کنید می‌خواهید «وکیل زبان» شوید، کافی است مفاهیم layout و triviality را در استاندارد بخوانید (بخش‌های §iso.3.9 و §iso.9) و سعی کنید به پیامدهایشان برای برنامه‌نویس‌ها و سازندگان کامپایلر فکر کنید. این کار شاید قبل از اینکه خیلی وقتتان گرفته شود، شما را از ادامه‌ی این مسیر منصرف کند.

----------------------
----------------------
----------------------
----------------------
----------------------

## Fields
حتی اگر استفاده از یک بایت کامل (مثل یک `char` یا `bool`) برای نمایش یک متغیر دودویی – مثلاً یک کلید روشن/خاموش – پرهزینه به نظر برسد، اما در C++ کوچک‌ترین شیءای که می‌تواند به‌طور مستقل تخصیص داده شود و آدرس‌پذیر باشد همان `char` است (§7.2). با این حال، می‌توان چندین متغیر خیلی کوچک از این نوع را کنار هم در قالب *field*‌ها در یک `struct` قرار داد.

به چنین فیلدی معمولاً *bit-field* گفته می‌شود. یک عضو زمانی به‌صورت *field* تعریف می‌شود که تعداد بیت‌هایی که باید اشغال کند مشخص شود. فیلدهای بدون‌نام نیز مجاز هستند. این‌ها بر معنای فیلدهای نام‌دار اثری ندارند، اما می‌توان از آن‌ها برای بهبود چیدمان در سطح ماشین (وابسته به معماری) استفاده کرد:

```cpp
struct PPN { // R6000 Physical Page Number
    unsigned int PFN : 22;  // Page Frame Number
    int : 3;                // استفاده‌نشده
    unsigned int CCA : 3;   // Cache Coherency Algorithm
    bool nonreachable : 1;
    bool dirty : 1;
    bool valid : 1;
    bool global : 1;
};
```

این مثال همچنین کاربرد اصلی دیگر فیلدها را نشان می‌دهد: نام‌گذاری بخش‌هایی از یک *چیدمان تحمیلی بیرونی*.
یک فیلد باید از نوع عدد صحیح یا نوع شمارشی باشد (§6.2.1). گرفتن آدرس یک فیلد ممکن نیست. با این حال، غیر از این مورد، می‌توان از آن درست مثل سایر متغیرها استفاده کرد. توجه کنید که یک فیلد `bool` واقعاً می‌تواند فقط با یک بیت نمایش داده شود.

در یک هسته سیستم‌عامل یا در یک دیباگر، نوع `PPN` ممکن است به این شکل استفاده شود:

```cpp
void part_of_VM_system(PPN* p)
{
    // ...
    if (p->dirty) {   // محتوا تغییر کرده
        // کپی روی دیسک
        p->dirty = 0;
    }
}
```

شگفت‌آور است که استفاده از فیلدها برای فشرده‌سازی چند متغیر در یک بایت الزاماً باعث صرفه‌جویی در فضا نمی‌شود. این روش فضای داده را کاهش می‌دهد، اما اندازه کدی که برای دستکاری این متغیرها لازم است، روی بیشتر ماشین‌ها افزایش می‌یابد. حتی در برخی برنامه‌ها دیده شده که وقتی متغیرهای دودویی از *bit-field* به `char` تبدیل شدند، کل برنامه کوچک‌تر شده است!

علاوه بر این، معمولاً دسترسی به یک `char` یا `int` بسیار سریع‌تر از دسترسی به یک فیلد است. فیلدها در واقع فقط یک میان‌بُر راحت برای استفاده از عملگرهای منطقی بیتی (§11.1.1) هستند تا بتوان از یک بخش خاص از یک کلمه (word) اطلاعات استخراج یا در آن درج کرد.

## Unions
یک **union** نوعی **struct** است که در آن تمام اعضا در یک آدرس قرار می‌گیرند، بنابراین **union فقط به اندازهٔ بزرگ‌ترین عضو خود فضا اشغال می‌کند**. طبیعتاً، یک union در هر لحظه می‌تواند فقط مقدار یکی از اعضایش را نگه دارد.

به‌عنوان مثال، در نظر بگیرید یک **ورودی جدول نمادها (symbol table)** که شامل یک نام و یک مقدار است:

```cpp
enum Type { str, num };

struct Entry {
    char* name;
    Type t;
    char* s; // استفاده شود اگر t == str
    int i;   // استفاده شود اگر t == num
};

void f(Entry* p)
{
    if (p->t == str)
        cout << p->s;
    // ...
}
```

اعضای **s** و **i** هرگز نمی‌توانند هم‌زمان استفاده شوند، بنابراین فضا هدر می‌رود. این فضا به‌راحتی می‌تواند با مشخص کردن اینکه هر دو عضو یک **union** باشند، بازیابی شود:

```cpp
union Value {
    char* s;
    int i;
};
```

زبان ++C پیگیری نمی‌کند که union در حال حاضر چه نوع مقداری نگه می‌دارد، بنابراین این وظیفهٔ برنامه‌نویس است:

```cpp
struct Entry {
    char* name;
    Type t;
    Value v; // اگر t == str از v.s استفاده شود؛ اگر t == num از v.i استفاده شود
};

void f(Entry* p)
{
    if (p->t == str)
        cout << p->v.s;
    // ...
}
```

برای جلوگیری از خطا، می‌توان union را **کپسوله (encapsulate)** کرد تا ارتباط بین فیلد نوع (**type field**) و دسترسی به اعضای union تضمین شود (§8.3.2).

---

گاهی اوقات **union به‌اشتباه برای "تبدیل نوع" استفاده می‌شود**. این سوءاستفاده عمدتاً توسط برنامه‌نویسانی انجام می‌شود که در زبان‌هایی آموزش دیده‌اند که امکانات تبدیل نوع صریح ندارند، بنابراین به "تقلب" متوسل می‌شوند.

برای مثال، کد زیر یک **int** را به یک **int**\* "تبدیل" می‌کند، صرفاً با فرض اینکه از نظر بیت‌به‌بیت معادل هستند:

```cpp
union Fudge {
    int i;
    int* p;
};

int* cheat(int i)
{
    Fudge a;
    a.i = i;
    return a.p; // استفادهٔ بد
}
```

اما این در واقع هیچ **تبدیلی** انجام نمی‌دهد. در برخی ماشین‌ها، یک **int** و یک **int**\* اندازهٔ یکسانی ندارند، و در برخی دیگر هیچ عدد صحیحی نمی‌تواند آدرس فرد داشته باشد. چنین استفاده‌ای از union **خطرناک و غیرقابل‌انتقال (nonportable)** است.

اگر واقعاً به چنین تبدیل ذاتاً زشتی نیاز دارید، از **عملگر تبدیل نوع صریح** استفاده کنید تا خواننده متوجه شود چه اتفاقی در حال رخ دادن است:

```cpp
int* cheat2(int i)
{
    return reinterpret_cast<int*>(i); // به‌وضوح زشت و خطرناک
}
```

اینجا دست‌کم کامپایلر این شانس را دارد که در صورت متفاوت بودن اندازهٔ اشیاء به شما هشدار بدهد و این کد همانند یک **انگشت زخمی آشکار** جلوه می‌کند.

---

استفاده از **union** می‌تواند برای فشرده‌سازی داده‌ها و از این طریق برای بهبود کارایی **ضروری** باشد.
با این حال، بیشتر برنامه‌ها از union سود چندانی نمی‌برند و unionها به‌طور کلی **مستعد خطا** هستند.

به همین دلیل، من unionها را یک قابلیت **بیش‌ازحد‌استفاده‌شده** می‌دانم؛ هر وقت می‌توانید، از آن‌ها اجتناب کنید.

## Unions and Classes
بسیاری از unionهای غیرساده، عضوی دارند که خیلی بزرگ‌تر از اعضای پرتکرارشان است. چون اندازهٔ یک union حداقل به بزرگیِ بزرگ‌ترین عضو آن است، فضا هدر می‌رود. این هدررفت را اغلب می‌توان با استفاده از مجموعه‌ای از کلاس‌های مشتق‌شده (§3.2.2، فصل 20) به‌جای union برطرف کرد.
از نظر فنی، یک union گونه‌ای از struct (§8.2) و struct هم گونه‌ای از class (فصل 16) است. بااین‌حال، بسیاری از امکاناتی که برای کلاس‌ها فراهم شده برای unionها موضوعیت ندارد، بنابراین محدودیت‌هایی بر unionها اعمال می‌شود:

\[1] یک union نمی‌تواند تابع مجازی داشته باشد.
\[2] یک union نمی‌تواند عضوی از نوع reference داشته باشد.
\[3] یک union نمی‌تواند کلاس پایه داشته باشد.
\[4] اگر union عضوی داشته باشد که سازندهٔ کاربر-تعریف‌شده، عملِ کپی، عملِ جابه‌جایی، یا مخرب دارد، آن تابع ویژه برای این union حذف (deleted) می‌شود (§3.3.4، §17.6.4)؛ یعنی برای شیء از نوع آن union قابل استفاده نخواهد بود.
\[5] حداکثر یک عضو از یک union می‌تواند مقداردهیِ درون‌کلاسی (in-class initializer) داشته باشد (§17.4.4).
\[6] یک union نمی‌تواند به‌عنوان کلاس پایه استفاده شود.

این محدودیت‌ها از بروز بسیاری از خطاهای ظریف جلوگیری می‌کنند و پیاده‌سازیِ unionها را ساده‌تر می‌سازند. دومی مهم است چون استفاده از unionها اغلب با هدف بهینه‌سازی است و نمی‌خواهیم «هزینه‌های پنهان» تحمیل شود و آن را مخدوش کند.

قاعده‌ای که سازنده‌ها (و غیره) را در unionی که عضوی با سازنده (و غیره) دارد حذف می‌کند، unionهای ساده را ساده نگه می‌دارد و برنامه‌نویس را وادار می‌کند در صورت نیاز عملیات پیچیده را خودش فراهم کند. برای مثال، چون Entry هیچ عضوی با سازنده، مخرب یا عملگرهای انتساب ندارد، می‌توانیم Entryها را آزادانه بسازیم و کپی کنیم. مثلاً:

```cpp
void f(Entry a)
{
    Entry b = a;
};
```

انجام این کار با یک union پیچیده‌تر به دشواری‌های پیاده‌سازی یا خطا منجر می‌شود:

```cpp
union U {
    int m1;
    complex<double> m2;   // complex سازنده دارد
    string m3;            // string سازنده دارد (یک ناوردای مهم را نگه می‌دارد)
};
```

برای کپی کردن یک U باید تصمیم بگیریم کدام عملیاتِ کپی را به‌کار ببریم. مثلاً:

```cpp
void f2(U x)
{
    U u;         // خطا: کدام سازندهٔ پیش‌فرض؟
    U u2 = x;    // خطا: کدام سازندهٔ کپی؟
    u.m1 = 1;    // انتساب به عضو int
    string s = u.m3;  // فاجعه: خواندن از عضو string
    return;      // خطا: برای x، u و u2 کدام مخرب‌ها فراخوانی می‌شوند؟
}
```

نوشتن در یک عضو و سپس خواندن از عضوی دیگر غیرقانونی است، اما افراد با این حال (معمولاً از سر اشتباه) این کار را می‌کنند. در این مورد، سازندهٔ کپیِ string با آرگومان نامعتبر فراخوانی می‌شود. خوشبختانه U اصلاً کامپایل نمی‌شود. وقتی لازم باشد، کاربر می‌تواند کلاسی حاوی یک union تعریف کند که اعضای union دارای سازنده، مخرب و انتساب را به‌درستی مدیریت کند (§8.3.2). در صورت تمایل، چنین کلاسی همچنین می‌تواند جلوی خطای نوشتن در یک عضو و خواندن از عضو دیگر را بگیرد.

امکان مشخص کردن یک مقداردهیِ درون‌کلاسی برای حداکثر یک عضو وجود دارد. اگر چنین شود، این مقداردهی برای مقداردهیِ پیش‌فرض به‌کار می‌رود. مثلاً:

```cpp
union U2 {
    int a;
    const char* p {""};
};
```

```cpp
U2 x1;      // به‌طور پیش‌فرض مقداردهی می‌شود؛ یعنی x1.p == ""
U2 x2 {7};  // x2.a == 7
```

## Anonymous unions
برای این‌که ببینیم چگونه می‌توان کلاسی نوشت که مشکلات ناشی از سوءاستفاده از یک union را برطرف کند، یک گونهٔ دیگر از Entry (§8.3) را در نظر بگیرید:

```cpp
class Entry2 { // دو نمایش جایگزین که به‌صورت union نمایش داده شده‌اند
private:
    enum class Tag { number, text };
    Tag type; // برچسب (discriminant)
    union { // نمایش (representation)
        int i;
        string s; // string سازندهٔ پیش‌فرض، عملگرهای کپی و مخرب دارد
    };
public:
    struct Bad_entry { }; // برای پرتاب استثناها استفاده می‌شود
    string name;
    ~Entry2();
    Entry2& operator=(const Entry2&); // لازم است چون یکی از حالت‌ها string است
    Entry2(const Entry2&);
    // ...
    int number() const;
    string text() const;
    void set_number(int n);
    void set_text(const string&);
    // ...
};
```

من طرفدار توابع get/set نیستم، اما در این مورد واقعاً لازم است هنگام هر دسترسی عملیِ غیرساده و مشخصِ کاربر انجام دهیم. من انتخاب کرده‌ام تابع «خواندن» را به نام همان مقدار بنامم و برای تابع «نوشتن» از پیشوند set\_ استفاده کنم. بین شیوه‌های نام‌گذاریِ متعدد، این یکی ترجیح من است.

توابع دسترسیِ خواندن را می‌توان به این شکل تعریف کرد:

```cpp
int Entry2::number() const
{
    if (type != Tag::number) throw Bad_entry{};
    return i;
}

string Entry2::text() const
{
    if (type != Tag::text) throw Bad_entry{};
    return s;
}
```

این توابع دسترسی، نوعِ برچسب را بررسی می‌کنند و اگر همان نوعی باشد که با دسترسی موردِ نظر ما تطابق دارد، مقدار را برمی‌گردانند؛ در غیر این صورت یک استثنا پرتاب می‌کنند. چنین unionی را اغلب «tagged union» یا «discriminated union» می‌نامند.

توابع دسترسیِ نوشتن اساساً همان بررسیِ برچسب نوع را انجام می‌دهند، اما توجه کنید که تنظیم یک مقدار جدید باید مقدار قبلی را هم در نظر بگیرد:

```cpp
void Entry2::set_number(int n)
{
    if (type == Tag::text) {
        s.~string();      // نابودسازیِ صریحِ string (§11.2.4)
        type = Tag::number;
    }
    i = n;
}

void Entry2::set_text(const string& ss)
{
    if (type == Tag::text)
        s = ss;
    else {
        new(&s) string{ss}; // placement new: سازشِ صریحِ string (§11.2.4)
        type = Tag::text;
    }
}
```

استفاده از یک union ما را وادار می‌کند برای مدیریت دورهٔ عمرِ عناصرِ union از قابلیت‌های سطح پایین و نسبتاً نامأنوس زبان (سازش/نابودسازیِ صریح) بهره بگیریم. این خود دلیل دیگری است برای احتیاط در استفاده از unionها.

توجه کنید union در اعلانِ Entry2 نام‌گذاری نشده است. این باعث می‌شود یک union ناشناس (anonymous) باشد. یک union ناشناس «شیء» است، نه «نوع»، و اعضای آن بدون ذکر نامِ شیء قابل دسترسی‌اند. یعنی می‌توانیم اعضای یک union ناشناس را دقیقاً مانند سایر اعضای یک کلاس به کار ببریم—به شرطی که به خاطر داشته باشیم اعضای یک union واقعاً فقط یکی‌یکی و در یک زمان قابل استفاده‌اند.

Entry2 عضوی از نوعی دارد که عملگر انتسابِ کاربر-تعریف‌شده دارد (string)، بنابراین عملگر انتسابِ Entry2 حذف می‌شود (§3.3.4، §17.6.4). اگر بخواهیم Entry2ها را به هم انتساب دهیم، باید

Entry2::operator=() را تعریف کنیم. انتساب ترکیبی از پیچیدگی‌های خواندن و نوشتن است، اما از نظر منطقی مشابه توابع دسترسی است:

```cpp
Entry2& Entry2::operator=(const Entry2& e) // لازم است چون یکی از حالت‌ها string است
{
    if (type == Tag::text && e.type == Tag::text) {
        s = e.s;           // انتساب معمولیِ string
        return *this;
    }
    if (type == Tag::text) s.~string(); // نابودسازیِ صریح (§11.2.4)

    switch (e.type) {
    case Tag::number:
        i = e.i;
        break;
    case Tag::text:
        new(&s) string(e.s); // placement new: سازشِ صریح (§11.2.4)
        type = e.type;
    }
    return *this;
}
```

سازنده‌ها و یک انتسابِ انتقالی (move assignment) را نیز می‌توان به‌طور مشابه و در صورت نیاز تعریف کرد. حداقل به یک یا دو سازنده نیاز داریم تا تطابق بین برچسب نوع و مقدار را برقرار کنیم. مخرب باید حالتِ string را رسیدگی کند:

```cpp
Entry2::~Entry2()
{
    if (type == Tag::text) s.~string(); // نابودسازیِ صریح (§11.2.4)
}
```
## Enumerations
یک شمارش (Enumeration) نوعی داده است که می‌تواند مجموعه‌ای از مقادیر عدد صحیح را که توسط کاربر مشخص شده‌اند، نگه دارد (§iso.7.2).
برخی از مقادیر ممکنِ یک شمارش، نام‌گذاری شده‌اند و **enumerator** نامیده می‌شوند.
برای مثال:

```cpp
enum class Color { red, green, blue };
```

این کد یک شمارش به نام `Color` تعریف می‌کند که شامل enumeratorهای `red`، `green` و `blue` است.
اصطلاح «یک enumeration» به طور محاوره‌ای کوتاه شده و به شکل «یک enum» استفاده می‌شود.

دو نوع شمارش وجود دارد:

1. **enum class**‌ها: که در آن نام‌های enumeratorها (مانند `red`) محدود به همان enum هستند و مقادیرشان به طور ضمنی به انواع دیگر تبدیل نمی‌شوند.
2. **enum معمولی (Plain enum):** که در آن نام‌های enumeratorها در همان محدوده‌ی تعریف‌شده‌ی enum قرار دارند و مقادیرشان به طور ضمنی به عدد صحیح تبدیل می‌شوند.

به طور کلی، **استفاده از enum class توصیه می‌شود** چون باعث می‌شود خطاها و اتفاقات غیرمنتظره کمتری رخ بدهد.

آیا می‌خواهی تفاوت‌های فنی بین این دو نوع enum را هم با مثال توضیح بدهم؟ (مثلاً تبدیل نوع و محدودهٔ نام‌ها)

## enum classes
یک **enum class** یک شمارش (enumeration) با **محدوده مشخص (scoped)** و **نوع قوی (strongly typed)** است.
برای مثال:

```cpp
enum class Traffic_light { red, yellow, green };
enum class Warning { green, yellow, orange, red }; // سطح هشدار آتش‌سوزی
```

* `Warning a1 = 7;` → خطا: تبدیل خودکار از `int` به `Warning` مجاز نیست.
* `int a2 = green;` → خطا: `green` در این محدوده نامرئی است.
* `int a3 = Warning::green;` → خطا: تبدیل خودکار از `Warning` به `int` وجود ندارد.
* `Warning a4 = Warning::green;` → درست است.

تابع زیر را در نظر بگیرید:

```cpp
void f(Traffic_light x)
{
    if (x == 9) { /* ... */ } // خطا: 9 یک مقدار Traffic_light نیست
    if (x == red) { /* ... */ } // خطا: red در این محدوده وجود ندارد
    if (x == Warning::red) { /* ... */ } // خطا: x از نوع Warning نیست
    if (x == Traffic_light::red) { /* ... */ } // درست
}
```

دقت کنید که اگر یک enumerator (مثل `red`) در دو enum مختلف وجود داشته باشد، مشکلی ایجاد نمی‌شود چون هر کدام در محدوده‌ی enum خودش قرار دارد.

---

### نوع زیرین (Underlying Type)

یک enumeration در واقع توسط یک نوع عدد صحیح نمایش داده می‌شود و هر enumerator نیز یک مقدار عددی دارد.
به نوعی که برای نمایش enumeration استفاده می‌شود، **نوع زیرین** آن می‌گوییم.
این نوع باید یکی از انواع صحیح علامت‌دار یا بدون علامت باشد؛ نوع پیش‌فرض `int` است.

می‌توانیم آن را به صورت صریح تعیین کنیم:

```cpp
enum class Warning : int { green, yellow, orange, red }; // sizeof(Warning) == sizeof(int)
```

اگر بخواهیم فضای کمتری اشغال شود:

```cpp
enum class Warning : char { green, yellow, orange, red }; // sizeof(Warning) == 1
```

---

### مقادیر پیش‌فرض Enumeratorها

به صورت پیش‌فرض، مقدار enumeratorها از ۰ شروع شده و به ترتیب افزوده می‌شوند:

```cpp
static_cast<int>(Warning::green)  == 0
static_cast<int>(Warning::yellow) == 1
static_cast<int>(Warning::orange) == 2
static_cast<int>(Warning::red)    == 3
```

استفاده از نوع `Warning` به جای `int`، هم به برنامه‌نویس و هم به کامپایلر کمک می‌کند که هدف متغیر مشخص‌تر باشد.

مثلاً:

```cpp
void f(Warning key)
{
    switch (key) {
        case Warning::green:
            // ...
            break;
        case Warning::orange:
            // ...
            break;
        case Warning::red:
            // ...
            break;
    }
}
```

اینجا یک انسان متوجه می‌شود که حالت `yellow` نادیده گرفته شده و حتی برخی کامپایلرها هشدار می‌دهند که همه حالت‌ها پوشش داده نشده‌اند.

---

### مقداردهی صریح Enumeratorها

Enumerator می‌تواند با یک عبارت ثابت از نوع صحیح مقداردهی شود:

```cpp
enum class Printer_flags {
    acknowledge = 1,
    paper_empty = 2,
    busy = 4,
    out_of_black = 8,
    out_of_color = 16,
    // ...
};
```

مقادیر به گونه‌ای انتخاب شده‌اند که بتوان با عملگرهای بیتی (`|` و `&`) آن‌ها را ترکیب کرد.

---

### تعریف عملگرها برای Enum

از آنجایی که enum یک نوع کاربر-تعریف‌شده است، می‌توان عملگرها را برای آن بازتعریف کرد:

```cpp
constexpr Printer_flags operator|(Printer_flags a, Printer_flags b)
{
    return static_cast<Printer_flags>(static_cast<int>(a) | static_cast<int>(b));
}

constexpr Printer_flags operator&(Printer_flags a, Printer_flags b)
{
    return static_cast<Printer_flags>(static_cast<int>(a) & static_cast<int>(b));
}
```

تبدیل‌های صریح لازم هستند چون enum class تبدیل ضمنی به int ندارد.
با این تعریف می‌توان نوشت:

```cpp
void try_to_print(Printer_flags x)
{
    if (x & Printer_flags::acknowledge) {
        // ...
    }
    else if (x & Printer_flags::busy) {
        // ...
    }
    else if (x & (Printer_flags::out_of_black | Printer_flags::out_of_color)) {
        // یکی از رنگ‌ها تمام شده است
        // ...
    }
}
```

چون این عملگرها `constexpr` تعریف شده‌اند، می‌توانند در عبارات ثابت استفاده شوند:

```cpp
void g(Printer_flags x)
{
    switch (x) {
        case Printer_flags::acknowledge:
            // ...
            break;
        case Printer_flags::busy:
            // ...
            break;
        case Printer_flags::out_of_black:
            // ...
            break;
        case Printer_flags::out_of_color:
            // ...
            break;
        case Printer_flags::out_of_black & Printer_flags::out_of_color:
            // هر دو رنگ تمام شده است
            // ...
            break;
    }
}
```

---

### اعلام و تعریف جداگانه Enum Class

می‌توان یک enum class را ابتدا اعلام کرد و بعداً تعریف کرد:

```cpp
enum class Color_code : char; // اعلام
void foobar(Color_code* p);   // استفاده

enum class Color_code : char { // تعریف
    red, yellow, green, blue
};
```

---

### تبدیل صریح از نوع صحیح

می‌توان یک مقدار عددی را به صورت صریح به یک enum class تبدیل کرد:

```cpp
enum class Flag : char { x=1, y=2, z=4, e=8 };

Flag f0 {};                   // مقدار پیش‌فرض 0
Flag f1 = 5;                  // خطا: 5 از نوع Flag نیست
Flag f2 = Flag{5};            // خطا: تبدیل باریک‌کننده مجاز نیست
Flag f3 = static_cast<Flag>(5);   // تبدیل صریح (مجاز)
Flag f4 = static_cast<Flag>(999); // خطا: 999 در محدوده char نیست
```

به همین دلیل، تبدیل ضمنی از عدد به enum class مجاز نیست، چون اکثر اعداد معتبر نیستند.

---

### استخراج مقدار عددی Enumerator

برای گرفتن مقدار عددی می‌توان از `static_cast` استفاده کرد:

```cpp
int i = static_cast<int>(Flag::y);   // i برابر 2 می‌شود
char c = static_cast<char>(Flag::e); // c برابر 8 می‌شود
```

اندازه (`sizeof`) یک enum class برابر اندازه نوع زیرین آن است؛ اگر نوع زیرین مشخص نشده باشد، برابر `sizeof(int)` است.


یک **plain enum** تقریباً همان چیزی است که C++ قبل از معرفی **enum class** ارائه می‌داد، بنابراین آن را در بسیاری از کدهای C و سبک C++98 خواهید دید.
Enumeratorهای یک plain enum مستقیماً به فضای نام (scope) همان enum وارد می‌شوند و به‌طور ضمنی به نوع صحیح (integer type) تبدیل می‌شوند.

مثال‌های زیر را در نظر بگیرید که فقط کلمه‌ی «class» حذف شده است:

```cpp
enum Traffic_light { red, yellow, green };
enum Warning { green, yellow, orange, red }; // سطح هشدار آتش‌سوزی
// خطا: تعریف تکراری yellow (با مقدار یکسان)
// خطا: تعریف تکراری red (با مقادیر متفاوت)

Warning a1 = 7;         // خطا: تبدیل int به Warning مجاز نیست
int a2 = green;         // درست: green در محدوده نام است و به int تبدیل می‌شود
int a3 = Warning::green;// درست: تبدیل Warning به int مجاز است
Warning a4 = Warning::green; // درست
```

تابع:

```cpp
void f(Traffic_light x)
{
    if (x == 9) { /* ... */ } // درست (ولی 9 یک مقدار معتبر برای Traffic_light نیست)
    if (x == red) { /* ... */ } // خطا: دو مقدار red در محدوده وجود دارند
    if (x == Warning::red) { /* ... */ } // درست (ولی عجیب!)
    if (x == Traffic_light::red) { /* ... */ } // درست
}
```

در این مثال، خوش‌شانس بودیم که تعریف دوباره‌ی `red` در دو plain enum باعث شد کامپایلر خطا دهد و از بروز باگ پنهان جلوگیری شود.

حالا تصور کنید می‌خواهیم نام‌ها را برای جلوگیری از تداخل تغییر دهیم:

```cpp
enum Traffic_light { tl_red, tl_yellow, tl_green };
enum Warning { green, yellow, orange, red };

void f(Traffic_light x)
{
    if (x == red) { /* ... */ }             // درست (ولی احتمالاً باگ است!)
    if (x == Warning::red) { /* ... */ }    // درست (ولی احتمالاً باگ است!)
    if (x == Traffic_light::red) { /* ... */ } // خطا: red دیگر جزو Traffic_light نیست
}
```

در اینجا کامپایلر `x == red` را می‌پذیرد، درحالی‌که تقریباً قطعاً اشتباه است.
تزریق نام‌ها به محدوده‌ی بالاتر (scope) همان‌طور که plain enum انجام می‌دهد، نوعی **آلودگی فضای نام** است و در پروژه‌های بزرگ می‌تواند مشکل‌ساز شود. (بررسی این در فصل ۱۴ ادامه دارد)

---

### تعیین نوع زیرین در plain enum

همانند enum class، می‌توان نوع زیرین یک plain enum را نیز تعیین کرد و حتی آن را بدون تعریف کامل اعلام نمود:

```cpp
enum Traffic_light : char { tl_red, tl_yellow, tl_green }; // نوع زیرین char است
enum Color_code : char; // فقط اعلام
void foobar(Color_code* p); // استفاده
// ...
enum Color_code : char { red, yellow, green, blue }; // تعریف
```

اما اگر نوع زیرین را مشخص نکنید، نمی‌توانید enum را بدون تعریف کامل اعلام کنید.
در این صورت نوع زیرین با الگوریتمی نسبتاً پیچیده تعیین می‌شود:

* اگر همه‌ی enumeratorها غیرمنفی باشند، بازه‌ی مقادیر `[0 : 2^k-1]` است که کوچک‌ترین توان دو (`2^k`) است که تمام مقادیر را پوشش دهد.
* اگر مقداری منفی وجود داشته باشد، بازه‌ی مقادیر `[-2^k : 2^k-1]` است.

به این ترتیب کوچک‌ترین فیلد بیتی ممکن انتخاب می‌شود که بتواند همه‌ی مقادیر را با نمایش دو مکمل (two’s complement) در خود جای دهد.

مثال:

```cpp
enum E1 { dark, light };          // بازه 0:1
enum E2 { a = 3, b = 9 };         // بازه 0:15
enum E3 { min = -10, max = 1000000 }; // بازه -1048576:1048575
```

---

### تبدیل صریح از عدد به plain enum

قاعده‌ی تبدیل صریح از عدد به plain enum همانند enum class است، با این تفاوت که اگر نوع زیرین مشخص نشده باشد، نتیجه‌ی تبدیل فقط وقتی تعریف‌شده است که مقدار در بازه‌ی معتبر enum باشد:

```cpp
enum Flag { x=1, y=2, z=4, e=8 }; // بازه 0:15
Flag f0 {};                      // مقدار پیش‌فرض 0
Flag f1 = 5;                     // خطا: 5 از نوع Flag نیست
Flag f2 = Flag{5};               // خطا: تبدیل مستقیم مجاز نیست
Flag f3 = static_cast<Flag>(5);  // درست: 5 در بازه‌ی معتبر است
Flag f4 = static_cast<Flag>(z|e);// درست: 12 در بازه‌ی معتبر است
Flag f5 = static_cast<Flag>(99); // تعریف‌نشده: 99 خارج از بازه‌ی معتبر است
```

به دلیل تبدیل ضمنی از plain enum به نوع زیرین، لازم نیست عملگر `|` را تعریف کنیم؛
`z` و `e` خودبه‌خود به int تبدیل می‌شوند و `z|e` محاسبه می‌شود.

---

### اندازه‌ی plain enum

`sizeof` یک enumeration برابر اندازه‌ی نوع زیرین آن است.
اگر نوع زیرین مشخص نشده باشد، کامپایلر کوچک‌ترین نوع صحیحی را انتخاب می‌کند که تمام مقادیر را نگه دارد و بزرگ‌تر از `sizeof(int)` نباشد، مگر اینکه مقدارها در `int` یا `unsigned int` جا نشوند.
مثلاً روی ماشینی که `sizeof(int)==4` است، اندازه‌ی E1 می‌تواند ۱ یا ۴ باشد، ولی ۸ نمی‌تواند باشد.

## Unnamed enums
یک **plain enum** می‌تواند **بی‌نام** باشد.
برای مثال:

```cpp
enum { arrow_up = 1, arrow_down, arrow_sideways };
```

از این حالت زمانی استفاده می‌کنیم که تنها به یک مجموعه **ثابت عددی** نیاز داریم،
نه یک نوع داده‌ای که بخواهیم برای متغیرها به کار ببریم.
