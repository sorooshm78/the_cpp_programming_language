## Introduction
کلید استفاده مؤثر از ++C تعریف و به‌کارگیری **نوع‌های تعریف‌شده توسط کاربر** است.
این فصل سه گونه‌ی ابتداییِ این مفهوم را معرفی می‌کند:

* **struct** (ساختار): دنباله‌ای از عناصر (که *عضو* نامیده می‌شوند) با نوع‌های دلخواه.
* **union**: ساختاری که در هر لحظه فقط مقدار یکی از اعضایش را نگه می‌دارد.
* **enum** (شمارش): نوعی که مجموعه‌ای از ثابت‌های نام‌گذاری‌شده (*enumerator*) را تعریف می‌کند.
* **enum class** (شمارش با محدوده یا Scoped Enumeration): نوعی شمارش که اعضای شمارش‌شده در محدوده‌ی خود آن شمارش قرار دارند و هیچ تبدیل ضمنی به نوع‌های دیگر انجام نمی‌شود.

گونه‌های مختلف این نوع‌های ساده از نخستین روزهای پیدایش ++C وجود داشته‌اند.
آن‌ها عمدتاً بر نمایش داده متمرکز هستند و ستون فقرات بیشتر برنامه‌نویسی به سبک C محسوب می‌شوند.

مفهوم **struct** که اینجا توضیح داده شده، شکلی ساده از یک **کلاس** است (بخش 3.2، فصل 16).

## Structures
آرایه مجموعه‌ای از عناصری با یک نوع یکسان است. در ساده‌ترین حالت، یک **struct** (ساختار) مجموعه‌ای از عناصری با نوع‌های دلخواه است. برای مثال:

```cpp
struct Address {
    const char* name;   // "Jim Dandy"
    int number;         // 61
    const char* street; // "South St"
    const char* town;   // "New Providence"
    char state[2];      // 'N' 'J'
    const char* zip;    // "07974"
};
```

این تعریف، نوعی به نام `Address` ایجاد می‌کند که شامل اطلاعاتی است که برای ارسال نامه به یک فرد در ایالات متحده آمریکا لازم است. به علامت **;** انتهای تعریف دقت کنید.

متغیرهای نوع `Address` درست مانند سایر متغیرها تعریف می‌شوند و اعضای آن‌ها را می‌توان با عملگر **`.`** (نقطه) دسترسی داد. برای مثال:

```cpp
void f()
{
    Address jd;
    jd.name = "Jim Dandy";
    jd.number = 61;
}
```

متغیرهای ساختاری را می‌توان با استفاده از یادداشت **`{}`** مقداردهی اولیه کرد (§6.3.5). برای مثال:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};
```

دقت کنید که `jd.state` را نمی‌توان با رشته `"NJ"` مقداردهی کرد. رشته‌ها با کاراکتر صفر `'\0'` خاتمه می‌یابند، بنابراین `"NJ"` شامل سه کاراکتر است — یک کاراکتر بیشتر از آنچه در `jd.state` جا می‌شود. در این مثال، عمداً از نوع‌های سطح پایین برای اعضا استفاده شده تا نشان داده شود که چگونه این کار انجام می‌شود و چه مشکلاتی می‌تواند ایجاد کند.

ساختارها اغلب از طریق اشاره‌گرها با عملگر **`->`** (دسترسی از طریق اشاره‌گر به struct) استفاده می‌شوند. برای مثال:

```cpp
void print_addr(Address* p)
{
    cout << p->name << '\n'
         << p->number << ' ' << p->street << '\n'
         << p->town << '\n'
         << p->state[0] << p->state[1] << ' ' << p->zip << '\n';
}
```

وقتی `p` یک اشاره‌گر است، عبارت `p->m` معادل `( *p ).m` است.

به‌طور جایگزین، یک **struct** می‌تواند به‌صورت **ارجاع (reference)** به تابع داده شود و با عملگر **`.`** (دسترسی به عضو ساختار) استفاده شود:

```cpp
void print_addr2(const Address& r)
{
    cout << r.name << '\n'
         << r.number << ' ' << r.street << '\n'
         << r.town << '\n'
         << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
```

بحث درباره‌ی ارسال آرگومان‌ها در بخش §12.2 آمده است.

اشیای نوع ساختار را می‌توان **اختصاص (assign)** داد، به‌عنوان **آرگومان به تابع ارسال** کرد و به‌عنوان **نتیجه از یک تابع بازگرداند**. برای مثال:

```cpp
Address current;

Address set_current(Address next)
{
    Address prev = current;
    current = next;
    return prev;
}
```

سایر عملیات ممکن، مانند مقایسه (`==` و `!=`)، به‌طور پیش‌فرض در دسترس نیستند.
با این حال، کاربر می‌تواند این عملگرها را تعریف کند (§3.2.1.1، فصل 18).

## struct Layout
یک شیء از نوع **struct** اعضای خود را به ترتیبی که اعلان شده‌اند در حافظه نگه می‌دارد.
برای مثال، می‌توانیم داده‌های ساده‌ی یک دستگاه اندازه‌گیری را در ساختاری مانند زیر ذخیره کنیم:

```cpp
struct Readout {
    char hour;  // [0:23]
    int value;
    char seq;   // علامت ترتیبی ['a':'z']
};
```

می‌توانید تصور کنید که اعضای یک شیء از نوع `Readout` در حافظه به این صورت چیده می‌شوند:

```
hour:   value:   seq:
```

اعضا دقیقاً به ترتیبی که اعلان شده‌اند در حافظه تخصیص داده می‌شوند، بنابراین آدرس `hour` باید کوچک‌تر از آدرس `value` باشد (نگاه کنید به §8.2.6).

---

با این حال، **اندازه‌ی یک شیء از نوع struct الزاماً برابر با مجموع اندازه‌ی اعضای آن نیست**.
دلیلش این است که بسیاری از ماشین‌ها (پردازنده‌ها) نیاز دارند که اشیای مربوط به بعضی انواع داده‌ها روی مرزهای خاصی (وابسته به معماری) قرار گیرند یا دست‌کم در این حالت دسترسی به آن‌ها کارآمدتر است.
برای مثال، معمولاً اعداد صحیح (`int`) روی مرزهای کلمه (word boundaries) قرار داده می‌شوند. روی چنین ماشین‌هایی، گفته می‌شود که اشیا باید «هم‌تراز (aligned)» باشند (§6.2.9). این موضوع باعث ایجاد «حفره‌ها» (فضاهای استفاده‌نشده) در ساختارها می‌شود.

یک چینش واقعی‌تر از `Readout` روی ماشینی که `int` آن ۴ بایتی است، چنین خواهد بود:

```
hour:
value:
seq:
```

در این حالت، همانند بسیاری از ماشین‌ها، `sizeof(Readout)` برابر **۱۲** است، نه **۶** (که کسی شاید ساده‌انگارانه از جمع اندازه‌ی اعضا انتظار داشته باشد).

---

می‌توانید با مرتب‌سازی اعضا بر اساس اندازه (از بزرگ‌ترین به کوچک‌ترین) فضای هدررفته را کاهش دهید.
برای مثال:

```cpp
struct Readout {
    int value;
    char hour;  // [0:23]
    char seq;   // علامت ترتیبی ['a':'z']
};
```

چینش در این حالت:

```
value:
(hour, seq):
```

با این حال، همچنان یک «حفره» ۲ بایتی باقی می‌ماند و `sizeof(Readout)` برابر **۸** خواهد شد.
علتش این است که هنگام قرار دادن دو شیء پشت سر هم (مثلاً در یک آرایه از `Readout`ها) باید هم‌ترازی حفظ شود.
پس اندازه‌ی یک آرایه‌ی ۱۰ عضوی از نوع `Readout` برابر است با:

```
10 * sizeof(Readout)
```

---

به طور کلی، بهتر است اعضا را بر اساس **خوانایی** کد مرتب کنید و فقط در صورتی به مرتب‌سازی بر اساس اندازه فکر کنید که واقعاً نیاز به بهینه‌سازی ثابت شده باشد.

استفاده از چند **specifier دسترسی** (یعنی `public`، `private` یا `protected`) هم می‌تواند روی چیدمان حافظه تأثیر بگذارد (§20.5).
