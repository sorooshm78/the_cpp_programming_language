## Introduction
کلید استفاده مؤثر از ++C تعریف و به‌کارگیری **نوع‌های تعریف‌شده توسط کاربر** است.
این فصل سه گونه‌ی ابتداییِ این مفهوم را معرفی می‌کند:

* **struct** (ساختار): دنباله‌ای از عناصر (که *عضو* نامیده می‌شوند) با نوع‌های دلخواه.
* **union**: ساختاری که در هر لحظه فقط مقدار یکی از اعضایش را نگه می‌دارد.
* **enum** (شمارش): نوعی که مجموعه‌ای از ثابت‌های نام‌گذاری‌شده (*enumerator*) را تعریف می‌کند.
* **enum class** (شمارش با محدوده یا Scoped Enumeration): نوعی شمارش که اعضای شمارش‌شده در محدوده‌ی خود آن شمارش قرار دارند و هیچ تبدیل ضمنی به نوع‌های دیگر انجام نمی‌شود.

گونه‌های مختلف این نوع‌های ساده از نخستین روزهای پیدایش ++C وجود داشته‌اند.
آن‌ها عمدتاً بر نمایش داده متمرکز هستند و ستون فقرات بیشتر برنامه‌نویسی به سبک C محسوب می‌شوند.

مفهوم **struct** که اینجا توضیح داده شده، شکلی ساده از یک **کلاس** است (بخش 3.2، فصل 16).

## Structures
آرایه مجموعه‌ای از عناصری با یک نوع یکسان است. در ساده‌ترین حالت، یک **struct** (ساختار) مجموعه‌ای از عناصری با نوع‌های دلخواه است. برای مثال:

```cpp
struct Address {
    const char* name;   // "Jim Dandy"
    int number;         // 61
    const char* street; // "South St"
    const char* town;   // "New Providence"
    char state[2];      // 'N' 'J'
    const char* zip;    // "07974"
};
```

این تعریف، نوعی به نام `Address` ایجاد می‌کند که شامل اطلاعاتی است که برای ارسال نامه به یک فرد در ایالات متحده آمریکا لازم است. به علامت **;** انتهای تعریف دقت کنید.

متغیرهای نوع `Address` درست مانند سایر متغیرها تعریف می‌شوند و اعضای آن‌ها را می‌توان با عملگر **`.`** (نقطه) دسترسی داد. برای مثال:

```cpp
void f()
{
    Address jd;
    jd.name = "Jim Dandy";
    jd.number = 61;
}
```

متغیرهای ساختاری را می‌توان با استفاده از یادداشت **`{}`** مقداردهی اولیه کرد (§6.3.5). برای مثال:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};
```

دقت کنید که `jd.state` را نمی‌توان با رشته `"NJ"` مقداردهی کرد. رشته‌ها با کاراکتر صفر `'\0'` خاتمه می‌یابند، بنابراین `"NJ"` شامل سه کاراکتر است — یک کاراکتر بیشتر از آنچه در `jd.state` جا می‌شود. در این مثال، عمداً از نوع‌های سطح پایین برای اعضا استفاده شده تا نشان داده شود که چگونه این کار انجام می‌شود و چه مشکلاتی می‌تواند ایجاد کند.

ساختارها اغلب از طریق اشاره‌گرها با عملگر **`->`** (دسترسی از طریق اشاره‌گر به struct) استفاده می‌شوند. برای مثال:

```cpp
void print_addr(Address* p)
{
    cout << p->name << '\n'
         << p->number << ' ' << p->street << '\n'
         << p->town << '\n'
         << p->state[0] << p->state[1] << ' ' << p->zip << '\n';
}
```

وقتی `p` یک اشاره‌گر است، عبارت `p->m` معادل `( *p ).m` است.

به‌طور جایگزین، یک **struct** می‌تواند به‌صورت **ارجاع (reference)** به تابع داده شود و با عملگر **`.`** (دسترسی به عضو ساختار) استفاده شود:

```cpp
void print_addr2(const Address& r)
{
    cout << r.name << '\n'
         << r.number << ' ' << r.street << '\n'
         << r.town << '\n'
         << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
```

بحث درباره‌ی ارسال آرگومان‌ها در بخش §12.2 آمده است.

اشیای نوع ساختار را می‌توان **اختصاص (assign)** داد، به‌عنوان **آرگومان به تابع ارسال** کرد و به‌عنوان **نتیجه از یک تابع بازگرداند**. برای مثال:

```cpp
Address current;

Address set_current(Address next)
{
    Address prev = current;
    current = next;
    return prev;
}
```

سایر عملیات ممکن، مانند مقایسه (`==` و `!=`)، به‌طور پیش‌فرض در دسترس نیستند.
با این حال، کاربر می‌تواند این عملگرها را تعریف کند (§3.2.1.1، فصل 18).

## struct Layout
یک شیء از نوع **struct** اعضای خود را به ترتیبی که اعلان شده‌اند در حافظه نگه می‌دارد.
برای مثال، می‌توانیم داده‌های ساده‌ی یک دستگاه اندازه‌گیری را در ساختاری مانند زیر ذخیره کنیم:

```cpp
struct Readout {
    char hour;  // [0:23]
    int value;
    char seq;   // علامت ترتیبی ['a':'z']
};
```

می‌توانید تصور کنید که اعضای یک شیء از نوع `Readout` در حافظه به این صورت چیده می‌شوند:

```
hour:   value:   seq:
```

اعضا دقیقاً به ترتیبی که اعلان شده‌اند در حافظه تخصیص داده می‌شوند، بنابراین آدرس `hour` باید کوچک‌تر از آدرس `value` باشد (نگاه کنید به §8.2.6).

---

با این حال، **اندازه‌ی یک شیء از نوع struct الزاماً برابر با مجموع اندازه‌ی اعضای آن نیست**.
دلیلش این است که بسیاری از ماشین‌ها (پردازنده‌ها) نیاز دارند که اشیای مربوط به بعضی انواع داده‌ها روی مرزهای خاصی (وابسته به معماری) قرار گیرند یا دست‌کم در این حالت دسترسی به آن‌ها کارآمدتر است.
برای مثال، معمولاً اعداد صحیح (`int`) روی مرزهای کلمه (word boundaries) قرار داده می‌شوند. روی چنین ماشین‌هایی، گفته می‌شود که اشیا باید «هم‌تراز (aligned)» باشند (§6.2.9). این موضوع باعث ایجاد «حفره‌ها» (فضاهای استفاده‌نشده) در ساختارها می‌شود.

یک چینش واقعی‌تر از `Readout` روی ماشینی که `int` آن ۴ بایتی است، چنین خواهد بود:

```
hour:
value:
seq:
```

در این حالت، همانند بسیاری از ماشین‌ها، `sizeof(Readout)` برابر **۱۲** است، نه **۶** (که کسی شاید ساده‌انگارانه از جمع اندازه‌ی اعضا انتظار داشته باشد).

---

می‌توانید با مرتب‌سازی اعضا بر اساس اندازه (از بزرگ‌ترین به کوچک‌ترین) فضای هدررفته را کاهش دهید.
برای مثال:

```cpp
struct Readout {
    int value;
    char hour;  // [0:23]
    char seq;   // علامت ترتیبی ['a':'z']
};
```

چینش در این حالت:

```
value:
(hour, seq):
```

با این حال، همچنان یک «حفره» ۲ بایتی باقی می‌ماند و `sizeof(Readout)` برابر **۸** خواهد شد.
علتش این است که هنگام قرار دادن دو شیء پشت سر هم (مثلاً در یک آرایه از `Readout`ها) باید هم‌ترازی حفظ شود.
پس اندازه‌ی یک آرایه‌ی ۱۰ عضوی از نوع `Readout` برابر است با:

```
10 * sizeof(Readout)
```

---

به طور کلی، بهتر است اعضا را بر اساس **خوانایی** کد مرتب کنید و فقط در صورتی به مرتب‌سازی بر اساس اندازه فکر کنید که واقعاً نیاز به بهینه‌سازی ثابت شده باشد.

استفاده از چند **specifier دسترسی** (یعنی `public`، `private` یا `protected`) هم می‌تواند روی چیدمان حافظه تأثیر بگذارد (§20.5).

## struct Names
نام یک نوع (type) بلافاصله پس از این‌که در کد دیده شد قابل استفاده می‌شود، نه این‌که فقط بعد از کامل دیده شدن اعلان آن.
برای مثال:

```cpp
struct Link {
    Link* previous;
    Link* successor;
};
```

با این حال، امکان اعلان اشیای جدید از یک struct تا زمانی که اعلان کامل آن struct دیده نشود وجود ندارد.
برای مثال:

```cpp
struct No_good {
    No_good member; // خطا: تعریف بازگشتی
};
```

این خطا است چون کامپایلر قادر به تعیین اندازه‌ی `No_good` نیست.
برای اینکه دو (یا بیشتر) struct بتوانند به یکدیگر اشاره کنند، می‌توانیم نامی را به عنوان نام یک struct معرفی کنیم.
برای مثال:

```cpp
struct List; // اعلان نام struct: List بعداً تعریف خواهد شد
struct Link {
    Link* pre;
    Link* suc;
    List* member_of;
    int data;
};
struct List {
    Link* head;
};
```

بدون اعلان اول برای `List`، استفاده از نوع اشاره‌گر `List*` در تعریف `Link` یک خطای نحوی بود.

---

نام یک struct می‌تواند قبل از این‌که نوع آن تعریف شود استفاده شود، به شرطی که آن استفاده نیازی به دانستن نام اعضا یا اندازه‌ی آن struct نداشته باشد.
با این حال، تا تکمیل شدن اعلان یک struct، آن struct یک **نوع ناقص (incomplete type)** محسوب می‌شود.
برای مثال:

```cpp
struct S;   // "S" نام یک نوع است
extern S a;
S f();
void g(S);
S* h(S*);
```

اما بسیاری از این اعلان‌ها را نمی‌توان استفاده کرد مگر اینکه نوع `S` تعریف شده باشد:

```cpp
void k(S* p)
{
    S a;       // خطا: S تعریف نشده؛ برای تخصیص اندازه لازم است
    f();       // خطا: S تعریف نشده؛ برای بازگرداندن مقدار اندازه لازم است
    g(a);      // خطا: S تعریف نشده؛ برای ارسال آرگومان اندازه لازم است
    p->m = 7;  // خطا: S تعریف نشده؛ نام عضو شناخته نیست
    S* q = h(p); // درست: اشاره‌گرها می‌توانند تخصیص داده و ارسال شوند
    q->m = 7;    // خطا: S تعریف نشده؛ نام عضو شناخته نیست
}
```

---

به دلایلی که به تاریخچه‌ی اولیه‌ی زبان C بازمی‌گردد، امکان دارد یک struct و یک غیر-struct با یک نام یکسان در همان دامنه تعریف شوند.
برای مثال:

```cpp
struct stat { /* ... */ };
int stat(char* name, struct stat* buf);
```

در این حالت، نام ساده‌ی `stat` مربوط به غیر-struct است، و برای اشاره به struct باید از پیشوند `struct` استفاده شود.
به همین ترتیب، کلمات کلیدی `class`، `union` و `enum` نیز می‌توانند به عنوان پیشوند برای رفع ابهام استفاده شوند.

با این حال، بهتر است نام‌ها را به‌گونه‌ای انتخاب کنیم که نیاز به چنین رفع ابهامی به وجود نیاید.

## Structures and Classes
یک **struct** در واقع همان **class** است با این تفاوت که اعضای آن به‌طور پیش‌فرض **public** هستند. بنابراین، یک struct می‌تواند **تابع عضو** هم داشته باشد (بخش §2.3.2 و فصل 16). به‌طور خاص، یک struct می‌تواند **سازنده (constructor)** داشته باشد.
برای مثال:

```cpp
struct Points {
    vector<Point> elem; // باید حداقل یک Point در خود داشته باشد
    Points(Point p0) { elem.push_back(p0); }
    Points(Point p0, Point p1) { elem.push_back(p0); elem.push_back(p1); }
    // ...
};
```

```cpp
Points x0; // خطا: سازنده‌ی پیش‌فرض وجود ندارد
Points x1{ {100,200} }; // یک Point
Points x1{ {100,200}, {300,400} }; // دو Point
```

---

نیازی نیست برای مقداردهی اعضا به ترتیب، حتماً یک سازنده تعریف کنید.
برای مثال:

```cpp
struct Point {
    int x, y;
};
```

```cpp
Point p0;       // خطرناک: اگر در محدوده‌ی محلی باشد بدون مقدار اولیه است (§6.3.5.1)
Point p1 {};    // سازنده‌ی پیش‌فرض: {{},{}} یعنی {0,0}
Point p2 {1};   // عضو دوم به‌طور پیش‌فرض مقداردهی می‌شود: {1,{}} یعنی {1,0}
Point p3 {1,2}; // {1,2}
```

---

**سازنده‌ها** زمانی لازم می‌شوند که بخواهید:

* ترتیب آرگومان‌ها را تغییر دهید،
* آرگومان‌ها را اعتبارسنجی کنید،
* آرگومان‌ها را اصلاح کنید،
* یا **invariant**ها (قیود پایدار) برقرار کنید (§2.4.3.2، §13.4).

برای مثال:

```cpp
struct Address {
    string name;    // "Jim Dandy"
    int number;     // 61
    string street;  // "South St"
    string town;    // "New Providence"
    char state[2];  // 'N' 'J'
    char zip[5];    // 07974
    Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
};
```

اینجا یک **سازنده** اضافه شده تا مطمئن شویم تمام اعضا مقداردهی شده‌اند و بتوانیم کد پستی را با یک رشته و یک عدد دریافت کنیم (نه اینکه مجبور شویم تک‌تک کاراکترها را دستکاری کنیم).

مثال استفاده:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    "NJ", 7974 // توجه: 07974 عدد هشت‌شانزدهی محسوب می‌شود (§6.2.4.1)
};
```

---

سازنده‌ی `Address` می‌تواند این‌طور پیاده‌سازی شود:

```cpp
Address::Address(const string& n, int nu, const string& s,
                 const string& t, const string& st, int z)
    // اعتبارسنجی کد پستی
    :name{n},
     number{nu},
     street{s},
     town{t}
{
    if (st.size()!=2)
        error("State abbreviation should be two characters");
    state = {st[0], st[1]}; // ذخیره‌ی کد ایالت به‌صورت کاراکتر

    ostringstream ost; // رشته‌جریان خروجی؛ نگاه کنید به §38.4.2
    ost << z;          // استخراج کاراکترها از int
    string zi {ost.str()};

    switch (zi.size()) {
    case 5:
        zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
        break;
    case 4: // با ‘0’ شروع می‌شود
        zip = {'0', zi[0], zi[1], zi[2], zi[3]};
        break;
    default:
        error("unexpected ZIP code format");
    }

    // ... بررسی کنید که کد معتبر باشد ...
}
```

## Structures and Arrays
به‌طور طبیعی می‌توانیم آرایه‌ای از **struct**‌ها و همچنین **struct**‌هایی شامل آرایه داشته باشیم. برای مثال:

```cpp
struct Point {
    int x, y;
};
Point points[3] {{1,2},{3,4},{5,6}};
int x2 = points[2].x;

struct Array {
    Point elem[3];
};
Array points2 {{1,2},{3,4},{5,6}};
int y2 = points2.elem[2].y;
```

قرار دادن یک آرایهٔ درون‌ساخته (built-in array) در یک **struct** به ما اجازه می‌دهد آن آرایه را مثل یک شیء در نظر بگیریم:
می‌توانیم **struct** حاوی آن را در **مقداردهی اولیه** (از جمله در ارسال آرگومان و بازگرداندن از تابع) و همچنین در **عملیات انتساب** کپی کنیم. برای مثال:

```cpp
Array shift(Array a, Point p)
{
    for (int i=0; i!=3; ++i) {
        a.elem[i].x += p.x;
        a.elem[i].y += p.y;
    }
    return a;
}
Array ax = shift(points2,{10,20});
```

یادداشت مربوط به `Array` کمی ابتدایی است: چرا `i!=3`؟ چرا باید مرتب `.elem[i]` را تکرار کنیم؟ چرا فقط المان‌هایی از نوع `Point`؟
کتابخانهٔ استاندارد، `std::array` را (بخش §34.2.1) به عنوان یک توسعهٔ کامل‌تر و زیباتر از ایدهٔ آرایهٔ با اندازه ثابت به صورت struct فراهم کرده است:

```cpp
template<typename T, size_t N >
struct array { // ساده‌شده (بخش §34.2.1 را ببینید)
    T elem[N];

    T* begin() noexcept { return elem; }
    const T* begin() const noexcept { return elem; }

    T* end() noexcept { return elem+N; }
    const T* end() const noexcept { return elem+N; }

    constexpr size_t size() noexcept;

    T& operator[](size_t n) { return elem[n]; }
    const T& operator[](size_type n) const { return elem[n]; }

    T* data() noexcept { return elem; }
    const T* data() const noexcept { return elem; }
    // ...
};
```

این `array` یک **قالب (template)** است تا هر تعداد دلخواهی از عناصر هر نوع دلخواهی را پشتیبانی کند. همچنین به طور مستقیم با امکان **استثناها** (§13.5.1.1) و اشیاء **const** (§16.2.9.1) سروکار دارد. با استفاده از `array` می‌توانیم چنین بنویسیم:

```cpp
struct Point {
    int x,y;
};
using Array = array<Point,3>; // آرایه‌ای از 3 Point

Array points {{1,2},{3,4},{5,6}};
int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
    for (int i=0; i!=a.size(); ++i) {
        a[i].x += p.x;
        a[i].y += p.y;
    }
    return a;
}
Array ax = shift(points,{10,20});
```

مزایای اصلی `std::array` نسبت به آرایهٔ درون‌ساخته این است که:

* یک نوع شیء واقعی است (دارای انتساب و ...).
* به طور ضمنی به یک اشاره‌گر به یک عنصر منفرد تبدیل نمی‌شود.

مثال:

```cpp
ostream& operator<<(ostream& os, Point p)
{
    cout << '{' << p.x << ',' << p.y << '}';
}

void print(Point a[],int s) // باید تعداد عناصر مشخص شود
{
    for (int i=0; i!=s; ++i)
        cout << a[i] << '\n';
}

template<typename T, int N>
void print(array<T,N>& a)
{
    for (int i=0; i!=a.size(); ++i)
        cout << a[i] << '\n';
}

Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر

void f()
{
    print(point1,4); // 4 یک خطای بد است
    print(point2);
}
```

عیب `std::array` در مقایسه با آرایهٔ درون‌ساخته این است که نمی‌توانیم تعداد عناصر را از طول **initializer** استنتاج کنیم:

```cpp
Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point> point3 = {{1,2},{3,4},{5,6}};   // خطا
```
