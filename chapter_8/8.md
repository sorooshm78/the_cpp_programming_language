## Introduction
کلید استفاده مؤثر از ++C تعریف و به‌کارگیری **نوع‌های تعریف‌شده توسط کاربر** است.
این فصل سه گونه‌ی ابتداییِ این مفهوم را معرفی می‌کند:

* **struct** (ساختار): دنباله‌ای از عناصر (که *عضو* نامیده می‌شوند) با نوع‌های دلخواه.
* **union**: ساختاری که در هر لحظه فقط مقدار یکی از اعضایش را نگه می‌دارد.
* **enum** (شمارش): نوعی که مجموعه‌ای از ثابت‌های نام‌گذاری‌شده (*enumerator*) را تعریف می‌کند.
* **enum class** (شمارش با محدوده یا Scoped Enumeration): نوعی شمارش که اعضای شمارش‌شده در محدوده‌ی خود آن شمارش قرار دارند و هیچ تبدیل ضمنی به نوع‌های دیگر انجام نمی‌شود.

گونه‌های مختلف این نوع‌های ساده از نخستین روزهای پیدایش ++C وجود داشته‌اند.
آن‌ها عمدتاً بر نمایش داده متمرکز هستند و ستون فقرات بیشتر برنامه‌نویسی به سبک C محسوب می‌شوند.

مفهوم **struct** که اینجا توضیح داده شده، شکلی ساده از یک **کلاس** است (بخش 3.2، فصل 16).

## Structures
آرایه مجموعه‌ای از عناصری با یک نوع یکسان است. در ساده‌ترین حالت، یک **struct** (ساختار) مجموعه‌ای از عناصری با نوع‌های دلخواه است. برای مثال:

```cpp
struct Address {
    const char* name;   // "Jim Dandy"
    int number;         // 61
    const char* street; // "South St"
    const char* town;   // "New Providence"
    char state[2];      // 'N' 'J'
    const char* zip;    // "07974"
};
```

این تعریف، نوعی به نام `Address` ایجاد می‌کند که شامل اطلاعاتی است که برای ارسال نامه به یک فرد در ایالات متحده آمریکا لازم است. به علامت **;** انتهای تعریف دقت کنید.

متغیرهای نوع `Address` درست مانند سایر متغیرها تعریف می‌شوند و اعضای آن‌ها را می‌توان با عملگر **`.`** (نقطه) دسترسی داد. برای مثال:

```cpp
void f()
{
    Address jd;
    jd.name = "Jim Dandy";
    jd.number = 61;
}
```

متغیرهای ساختاری را می‌توان با استفاده از یادداشت **`{}`** مقداردهی اولیه کرد (§6.3.5). برای مثال:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};
```

دقت کنید که `jd.state` را نمی‌توان با رشته `"NJ"` مقداردهی کرد. رشته‌ها با کاراکتر صفر `'\0'` خاتمه می‌یابند، بنابراین `"NJ"` شامل سه کاراکتر است — یک کاراکتر بیشتر از آنچه در `jd.state` جا می‌شود. در این مثال، عمداً از نوع‌های سطح پایین برای اعضا استفاده شده تا نشان داده شود که چگونه این کار انجام می‌شود و چه مشکلاتی می‌تواند ایجاد کند.

ساختارها اغلب از طریق اشاره‌گرها با عملگر **`->`** (دسترسی از طریق اشاره‌گر به struct) استفاده می‌شوند. برای مثال:

```cpp
void print_addr(Address* p)
{
    cout << p->name << '\n'
         << p->number << ' ' << p->street << '\n'
         << p->town << '\n'
         << p->state[0] << p->state[1] << ' ' << p->zip << '\n';
}
```

وقتی `p` یک اشاره‌گر است، عبارت `p->m` معادل `( *p ).m` است.

به‌طور جایگزین، یک **struct** می‌تواند به‌صورت **ارجاع (reference)** به تابع داده شود و با عملگر **`.`** (دسترسی به عضو ساختار) استفاده شود:

```cpp
void print_addr2(const Address& r)
{
    cout << r.name << '\n'
         << r.number << ' ' << r.street << '\n'
         << r.town << '\n'
         << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
```

بحث درباره‌ی ارسال آرگومان‌ها در بخش §12.2 آمده است.

اشیای نوع ساختار را می‌توان **اختصاص (assign)** داد، به‌عنوان **آرگومان به تابع ارسال** کرد و به‌عنوان **نتیجه از یک تابع بازگرداند**. برای مثال:

```cpp
Address current;

Address set_current(Address next)
{
    Address prev = current;
    current = next;
    return prev;
}
```

سایر عملیات ممکن، مانند مقایسه (`==` و `!=`)، به‌طور پیش‌فرض در دسترس نیستند.
با این حال، کاربر می‌تواند این عملگرها را تعریف کند (§3.2.1.1، فصل 18).

## struct Layout
یک شیء از نوع **struct** اعضای خود را به ترتیبی که اعلان شده‌اند در حافظه نگه می‌دارد.
برای مثال، می‌توانیم داده‌های ساده‌ی یک دستگاه اندازه‌گیری را در ساختاری مانند زیر ذخیره کنیم:

```cpp
struct Readout {
    char hour;  // [0:23]
    int value;
    char seq;   // علامت ترتیبی ['a':'z']
};
```

می‌توانید تصور کنید که اعضای یک شیء از نوع `Readout` در حافظه به این صورت چیده می‌شوند:

```
hour:   value:   seq:
```

اعضا دقیقاً به ترتیبی که اعلان شده‌اند در حافظه تخصیص داده می‌شوند، بنابراین آدرس `hour` باید کوچک‌تر از آدرس `value` باشد (نگاه کنید به §8.2.6).

---

با این حال، **اندازه‌ی یک شیء از نوع struct الزاماً برابر با مجموع اندازه‌ی اعضای آن نیست**.
دلیلش این است که بسیاری از ماشین‌ها (پردازنده‌ها) نیاز دارند که اشیای مربوط به بعضی انواع داده‌ها روی مرزهای خاصی (وابسته به معماری) قرار گیرند یا دست‌کم در این حالت دسترسی به آن‌ها کارآمدتر است.
برای مثال، معمولاً اعداد صحیح (`int`) روی مرزهای کلمه (word boundaries) قرار داده می‌شوند. روی چنین ماشین‌هایی، گفته می‌شود که اشیا باید «هم‌تراز (aligned)» باشند (§6.2.9). این موضوع باعث ایجاد «حفره‌ها» (فضاهای استفاده‌نشده) در ساختارها می‌شود.

یک چینش واقعی‌تر از `Readout` روی ماشینی که `int` آن ۴ بایتی است، چنین خواهد بود:

```
hour:
value:
seq:
```

در این حالت، همانند بسیاری از ماشین‌ها، `sizeof(Readout)` برابر **۱۲** است، نه **۶** (که کسی شاید ساده‌انگارانه از جمع اندازه‌ی اعضا انتظار داشته باشد).

---

می‌توانید با مرتب‌سازی اعضا بر اساس اندازه (از بزرگ‌ترین به کوچک‌ترین) فضای هدررفته را کاهش دهید.
برای مثال:

```cpp
struct Readout {
    int value;
    char hour;  // [0:23]
    char seq;   // علامت ترتیبی ['a':'z']
};
```

چینش در این حالت:

```
value:
(hour, seq):
```

با این حال، همچنان یک «حفره» ۲ بایتی باقی می‌ماند و `sizeof(Readout)` برابر **۸** خواهد شد.
علتش این است که هنگام قرار دادن دو شیء پشت سر هم (مثلاً در یک آرایه از `Readout`ها) باید هم‌ترازی حفظ شود.
پس اندازه‌ی یک آرایه‌ی ۱۰ عضوی از نوع `Readout` برابر است با:

```
10 * sizeof(Readout)
```

---

به طور کلی، بهتر است اعضا را بر اساس **خوانایی** کد مرتب کنید و فقط در صورتی به مرتب‌سازی بر اساس اندازه فکر کنید که واقعاً نیاز به بهینه‌سازی ثابت شده باشد.

استفاده از چند **specifier دسترسی** (یعنی `public`، `private` یا `protected`) هم می‌تواند روی چیدمان حافظه تأثیر بگذارد (§20.5).

## struct Names
نام یک نوع (type) بلافاصله پس از این‌که در کد دیده شد قابل استفاده می‌شود، نه این‌که فقط بعد از کامل دیده شدن اعلان آن.
برای مثال:

```cpp
struct Link {
    Link* previous;
    Link* successor;
};
```

با این حال، امکان اعلان اشیای جدید از یک struct تا زمانی که اعلان کامل آن struct دیده نشود وجود ندارد.
برای مثال:

```cpp
struct No_good {
    No_good member; // خطا: تعریف بازگشتی
};
```

این خطا است چون کامپایلر قادر به تعیین اندازه‌ی `No_good` نیست.
برای اینکه دو (یا بیشتر) struct بتوانند به یکدیگر اشاره کنند، می‌توانیم نامی را به عنوان نام یک struct معرفی کنیم.
برای مثال:

```cpp
struct List; // اعلان نام struct: List بعداً تعریف خواهد شد
struct Link {
    Link* pre;
    Link* suc;
    List* member_of;
    int data;
};
struct List {
    Link* head;
};
```

بدون اعلان اول برای `List`، استفاده از نوع اشاره‌گر `List*` در تعریف `Link` یک خطای نحوی بود.

---

نام یک struct می‌تواند قبل از این‌که نوع آن تعریف شود استفاده شود، به شرطی که آن استفاده نیازی به دانستن نام اعضا یا اندازه‌ی آن struct نداشته باشد.
با این حال، تا تکمیل شدن اعلان یک struct، آن struct یک **نوع ناقص (incomplete type)** محسوب می‌شود.
برای مثال:

```cpp
struct S;   // "S" نام یک نوع است
extern S a;
S f();
void g(S);
S* h(S*);
```

اما بسیاری از این اعلان‌ها را نمی‌توان استفاده کرد مگر اینکه نوع `S` تعریف شده باشد:

```cpp
void k(S* p)
{
    S a;       // خطا: S تعریف نشده؛ برای تخصیص اندازه لازم است
    f();       // خطا: S تعریف نشده؛ برای بازگرداندن مقدار اندازه لازم است
    g(a);      // خطا: S تعریف نشده؛ برای ارسال آرگومان اندازه لازم است
    p->m = 7;  // خطا: S تعریف نشده؛ نام عضو شناخته نیست
    S* q = h(p); // درست: اشاره‌گرها می‌توانند تخصیص داده و ارسال شوند
    q->m = 7;    // خطا: S تعریف نشده؛ نام عضو شناخته نیست
}
```

---

به دلایلی که به تاریخچه‌ی اولیه‌ی زبان C بازمی‌گردد، امکان دارد یک struct و یک غیر-struct با یک نام یکسان در همان دامنه تعریف شوند.
برای مثال:

```cpp
struct stat { /* ... */ };
int stat(char* name, struct stat* buf);
```

در این حالت، نام ساده‌ی `stat` مربوط به غیر-struct است، و برای اشاره به struct باید از پیشوند `struct` استفاده شود.
به همین ترتیب، کلمات کلیدی `class`، `union` و `enum` نیز می‌توانند به عنوان پیشوند برای رفع ابهام استفاده شوند.

با این حال، بهتر است نام‌ها را به‌گونه‌ای انتخاب کنیم که نیاز به چنین رفع ابهامی به وجود نیاید.

## Structures and Classes
یک **struct** در واقع همان **class** است با این تفاوت که اعضای آن به‌طور پیش‌فرض **public** هستند. بنابراین، یک struct می‌تواند **تابع عضو** هم داشته باشد (بخش §2.3.2 و فصل 16). به‌طور خاص، یک struct می‌تواند **سازنده (constructor)** داشته باشد.
برای مثال:

```cpp
struct Points {
    vector<Point> elem; // باید حداقل یک Point در خود داشته باشد
    Points(Point p0) { elem.push_back(p0); }
    Points(Point p0, Point p1) { elem.push_back(p0); elem.push_back(p1); }
    // ...
};
```

```cpp
Points x0; // خطا: سازنده‌ی پیش‌فرض وجود ندارد
Points x1{ {100,200} }; // یک Point
Points x1{ {100,200}, {300,400} }; // دو Point
```

---

نیازی نیست برای مقداردهی اعضا به ترتیب، حتماً یک سازنده تعریف کنید.
برای مثال:

```cpp
struct Point {
    int x, y;
};
```

```cpp
Point p0;       // خطرناک: اگر در محدوده‌ی محلی باشد بدون مقدار اولیه است (§6.3.5.1)
Point p1 {};    // سازنده‌ی پیش‌فرض: {{},{}} یعنی {0,0}
Point p2 {1};   // عضو دوم به‌طور پیش‌فرض مقداردهی می‌شود: {1,{}} یعنی {1,0}
Point p3 {1,2}; // {1,2}
```

---

**سازنده‌ها** زمانی لازم می‌شوند که بخواهید:

* ترتیب آرگومان‌ها را تغییر دهید،
* آرگومان‌ها را اعتبارسنجی کنید،
* آرگومان‌ها را اصلاح کنید،
* یا **invariant**ها (قیود پایدار) برقرار کنید (§2.4.3.2، §13.4).

برای مثال:

```cpp
struct Address {
    string name;    // "Jim Dandy"
    int number;     // 61
    string street;  // "South St"
    string town;    // "New Providence"
    char state[2];  // 'N' 'J'
    char zip[5];    // 07974
    Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
};
```

اینجا یک **سازنده** اضافه شده تا مطمئن شویم تمام اعضا مقداردهی شده‌اند و بتوانیم کد پستی را با یک رشته و یک عدد دریافت کنیم (نه اینکه مجبور شویم تک‌تک کاراکترها را دستکاری کنیم).

مثال استفاده:

```cpp
Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    "NJ", 7974 // توجه: 07974 عدد هشت‌شانزدهی محسوب می‌شود (§6.2.4.1)
};
```

---

سازنده‌ی `Address` می‌تواند این‌طور پیاده‌سازی شود:

```cpp
Address::Address(const string& n, int nu, const string& s,
                 const string& t, const string& st, int z)
    // اعتبارسنجی کد پستی
    :name{n},
     number{nu},
     street{s},
     town{t}
{
    if (st.size()!=2)
        error("State abbreviation should be two characters");
    state = {st[0], st[1]}; // ذخیره‌ی کد ایالت به‌صورت کاراکتر

    ostringstream ost; // رشته‌جریان خروجی؛ نگاه کنید به §38.4.2
    ost << z;          // استخراج کاراکترها از int
    string zi {ost.str()};

    switch (zi.size()) {
    case 5:
        zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
        break;
    case 4: // با ‘0’ شروع می‌شود
        zip = {'0', zi[0], zi[1], zi[2], zi[3]};
        break;
    default:
        error("unexpected ZIP code format");
    }

    // ... بررسی کنید که کد معتبر باشد ...
}
```

## Structures and Arrays
به‌طور طبیعی می‌توانیم آرایه‌ای از **struct**‌ها و همچنین **struct**‌هایی شامل آرایه داشته باشیم. برای مثال:

```cpp
struct Point {
    int x, y;
};
Point points[3] {{1,2},{3,4},{5,6}};
int x2 = points[2].x;

struct Array {
    Point elem[3];
};
Array points2 {{1,2},{3,4},{5,6}};
int y2 = points2.elem[2].y;
```

قرار دادن یک آرایهٔ درون‌ساخته (built-in array) در یک **struct** به ما اجازه می‌دهد آن آرایه را مثل یک شیء در نظر بگیریم:
می‌توانیم **struct** حاوی آن را در **مقداردهی اولیه** (از جمله در ارسال آرگومان و بازگرداندن از تابع) و همچنین در **عملیات انتساب** کپی کنیم. برای مثال:

```cpp
Array shift(Array a, Point p)
{
    for (int i=0; i!=3; ++i) {
        a.elem[i].x += p.x;
        a.elem[i].y += p.y;
    }
    return a;
}
Array ax = shift(points2,{10,20});
```

یادداشت مربوط به `Array` کمی ابتدایی است: چرا `i!=3`؟ چرا باید مرتب `.elem[i]` را تکرار کنیم؟ چرا فقط المان‌هایی از نوع `Point`؟
کتابخانهٔ استاندارد، `std::array` را (بخش §34.2.1) به عنوان یک توسعهٔ کامل‌تر و زیباتر از ایدهٔ آرایهٔ با اندازه ثابت به صورت struct فراهم کرده است:

```cpp
template<typename T, size_t N >
struct array { // ساده‌شده (بخش §34.2.1 را ببینید)
    T elem[N];

    T* begin() noexcept { return elem; }
    const T* begin() const noexcept { return elem; }

    T* end() noexcept { return elem+N; }
    const T* end() const noexcept { return elem+N; }

    constexpr size_t size() noexcept;

    T& operator[](size_t n) { return elem[n]; }
    const T& operator[](size_type n) const { return elem[n]; }

    T* data() noexcept { return elem; }
    const T* data() const noexcept { return elem; }
    // ...
};
```

این `array` یک **قالب (template)** است تا هر تعداد دلخواهی از عناصر هر نوع دلخواهی را پشتیبانی کند. همچنین به طور مستقیم با امکان **استثناها** (§13.5.1.1) و اشیاء **const** (§16.2.9.1) سروکار دارد. با استفاده از `array` می‌توانیم چنین بنویسیم:

```cpp
struct Point {
    int x,y;
};
using Array = array<Point,3>; // آرایه‌ای از 3 Point

Array points {{1,2},{3,4},{5,6}};
int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
    for (int i=0; i!=a.size(); ++i) {
        a[i].x += p.x;
        a[i].y += p.y;
    }
    return a;
}
Array ax = shift(points,{10,20});
```

مزایای اصلی `std::array` نسبت به آرایهٔ درون‌ساخته این است که:

* یک نوع شیء واقعی است (دارای انتساب و ...).
* به طور ضمنی به یک اشاره‌گر به یک عنصر منفرد تبدیل نمی‌شود.

مثال:

```cpp
ostream& operator<<(ostream& os, Point p)
{
    cout << '{' << p.x << ',' << p.y << '}';
}

void print(Point a[],int s) // باید تعداد عناصر مشخص شود
{
    for (int i=0; i!=s; ++i)
        cout << a[i] << '\n';
}

template<typename T, int N>
void print(array<T,N>& a)
{
    for (int i=0; i!=a.size(); ++i)
        cout << a[i] << '\n';
}

Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر

void f()
{
    print(point1,4); // 4 یک خطای بد است
    print(point2);
}
```

عیب `std::array` در مقایسه با آرایهٔ درون‌ساخته این است که نمی‌توانیم تعداد عناصر را از طول **initializer** استنتاج کنیم:

```cpp
Point point1[] = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 عنصر
array<Point> point3 = {{1,2},{3,4},{5,6}};   // خطا
```

## Type Equivalence
دو **struct** حتی زمانی که اعضای یکسانی دارند، نوع‌های متفاوتی محسوب می‌شوند.
برای مثال:

```cpp
struct S1 { int a; };
struct S2 { int a; };
```

`S1` و `S2` دو نوع متفاوت هستند، بنابراین:

```cpp
S1 x;
S2 y = x; // خطا: عدم تطابق نوع
```

یک **struct** همچنین با نوعی که به‌عنوان عضو در آن استفاده شده، متفاوت است.
برای مثال:

```cpp
S1 x;
int i = x; // خطا: عدم تطابق نوع
```

هر **struct** باید در یک برنامه تعریف یکتایی داشته باشد (§15.2.3).

## 8.2.6 Plain Old Data
گاهی اوقات می‌خواهیم با یک شیء مثل «داده‌ی خام قدیمی» (**Plain Old Data = POD**) رفتار کنیم (یعنی به‌عنوان یک دنباله‌ی پیوسته از بایت‌ها در حافظه) و نگران مفاهیم معنایی پیشرفته‌تر، مانند **چندریختی در زمان اجرا** (§3.2.3, §20.3.2)، **سمنتیک کپی تعریف‌شده توسط کاربر** (§3.3, §17.5) و غیره نباشیم.
دلیل انجام این کار اغلب این است که بتوانیم اشیاء را به مؤثرترین شکلی که سخت‌افزار اجازه می‌دهد جابه‌جا کنیم.

برای مثال، کپی کردن یک آرایه‌ی 100 عنصری با 100 بار فراخوانی سازنده‌ی کپی به‌طور معمول به‌اندازه‌ی یک فراخوانی به `std::memcpy()` سریع نیست، چون `memcpy` معمولاً تنها از یک دستور سخت‌افزاری **انتقال بلوکی حافظه** استفاده می‌کند. حتی اگر سازنده کپی inline شود، ممکن است بهینه‌ساز نتواند چنین بهینه‌سازی‌ای را کشف کند. این‌گونه «ترفندها» در پیاده‌سازی **کانتینرها** (مانند `vector`) و در **روال‌های سطح پایین I/O** متداول و مهم هستند، اما در کدهای سطح بالاتر غیرضروری بوده و بهتر است از آن‌ها پرهیز شود.

بنابراین، یک **POD** شیئی است که می‌توان با آن مانند «فقط داده» رفتار کرد، بدون نگرانی از پیچیدگی‌های مربوط به چیدمان کلاس یا معناهای تعریف‌شده توسط کاربر برای **سازنده، کپی و جابه‌جایی**.

برای مثال:

```cpp
struct S0 { };                        // یک POD
struct S1 { int a; };                 // یک POD
struct S2 { int a; S2(int aa) : a(aa) { } }; // POD نیست (سازنده پیش‌فرض ندارد)
struct S3 { int a; S3(int aa) : a(aa) { } S3() {} }; // یک POD (سازنده پیش‌فرض تعریف‌شده)
struct S4 { int a; S4(int aa) : a(aa) { } S4() = default; }; // یک POD
struct S5 { virtual void f(); };       // POD نیست (تابع مجازی دارد)
struct S6 : S1 { };                   // یک POD
struct S7 : S0 { int b; };            // یک POD
struct S8 : S1 { int b; };            // POD نیست (داده هم در S1 و هم در S8 است)
struct S9 : S0, S1 {};                // یک POD
```

برای اینکه بتوانیم با یک شیء مانند POD رفتار کنیم، آن شیء باید:

* چیدمان پیچیده نداشته باشد (مثلاً vptr نداشته باشد؛ §3.2.3, §20.3.2)،
* سمنتیک کپی غیر استاندارد (تعریف‌شده توسط کاربر) نداشته باشد، و
* سازنده‌ی پیش‌فرض ساده (trivial) داشته باشد.

واضح است که باید تعریف دقیق POD مشخص باشد تا تنها در جاهایی از این بهینه‌سازی‌ها استفاده کنیم که تضمین‌های زبان شکسته نشود.

به‌طور رسمی (§iso.3.9, §iso.9)، یک شیء POD باید:

* **از نوع با چیدمان استاندارد (standard layout type)** باشد،
* **از نوع قابل کپی ساده (trivially copyable)** باشد،
* **و یک سازنده‌ی پیش‌فرض ساده داشته باشد**.

مفهوم مرتبط دیگری هم هست به نام **نوع ساده (trivial type)** که ویژگی‌های زیر را دارد:

* سازنده‌ی پیش‌فرض ساده دارد.
* عملگرهای کپی و جابه‌جایی ساده دارد.

به‌طور غیررسمی، یک سازنده پیش‌فرض ساده است اگر هیچ کاری نیاز به انجام نداشته باشد (اگر نیاز داشتید یکی تعریف کنید، از `=default` استفاده کنید؛ §17.6.1).

یک نوع **چیدمان استاندارد (standard layout)** ندارد اگر:

* عضوی غیر‌استاتیک یا پایه‌ای داشته باشد که خود چیدمان استاندارد ندارد،
* تابع مجازی داشته باشد (§3.2.3, §20.3.2)،
* پایه‌ی مجازی داشته باشد (§21.3.5)،
* عضوی از نوع reference داشته باشد (§7.7)،
* برای داده‌های غیر‌استاتیک، چندین سطح دسترسی (`public/private/protected`) استفاده کند (§20.5)، یا
* مانع بهینه‌سازی‌های مهم چیدمان شود، مانند:

  * داشتن اعضای غیر‌استاتیک در بیش از یک کلاس پایه یا هم در کلاس مشتق و هم در یک پایه، یا
  * داشتن کلاسی پایه از همان نوع به‌عنوان اولین عضو غیر‌استاتیک.

به‌طور کلی، یک نوع **standard layout** نوعی است که چیدمان آن معادل واضحی در زبان C دارد و توسط ABIهای رایج C++ قابل پشتیبانی است.

یک نوع **trivially copyable** است مگر اینکه یک عملیات کپی، جابه‌جایی یا سازنده‌ی غیرساده داشته باشد (§3.2.1.2, §17.6).
به‌طور غیررسمی، یک عملیات کپی ساده است اگر بتوان آن را به‌صورت **کپی بیتی (bitwise copy)** پیاده‌سازی کرد.

چه چیزی باعث می‌شود یک کپی، جابه‌جایی یا مخرب (destructor) غیرساده باشد؟

* اگر توسط کاربر تعریف شده باشد.
* اگر کلاس تابع مجازی داشته باشد.
* اگر کلاس پایه‌ی مجازی داشته باشد.
* اگر کلاس پایه یا عضوی داشته باشد که خود ساده نیست.

یک شیء از نوع built-in به‌طور پیش‌فرض قابل کپی ساده است و چیدمان استاندارد دارد. همچنین، آرایه‌ای از اشیاء قابل کپی ساده، خودش قابل کپی ساده است، و آرایه‌ای از اشیاء با چیدمان استاندارد نیز همان ویژگی را دارد.

به مثال زیر توجه کنید:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count);
```

فرض کنید می‌خواهم حالت ساده را بهینه کنم وقتی که `T` یک POD است. می‌توانم این کار را با فراخوانی `mycopy()` فقط برای PODها انجام دهم، اما این پرخطاست: آیا می‌توانم مطمئن باشم که نگه‌دارنده‌ی کد هرگز `mycopy()` را برای نوعی غیر POD صدا نمی‌زند؟ واقع‌بینانه، خیر.
جایگزین بهتر این است که از `std::copy()` استفاده کنیم، که به احتمال زیاد با همان بهینه‌سازی موردنیاز پیاده‌سازی شده است.

به‌هرحال، این نسخه‌ی عمومی و بهینه‌شده‌ی کد است:

```cpp
template<typename T>
void mycopy(T* to, const T* from, int count)
{
    if (is_pod<T>::value)
        memcpy(to, from, count * sizeof(T));
    else
        for (int i = 0; i != count; ++i)
            to[i] = from[i];
}
```

`is_pod` یک ویژگی (type trait) در کتابخانه‌ی استاندارد است (§35.4.1) که در `<type_traits>` تعریف شده و به ما اجازه می‌دهد در کد بپرسیم: «آیا `T` یک POD است؟».
بهترین نکته درباره‌ی `is_pod<T>` این است که ما را از حفظ کردن قوانین دقیق POD بی‌نیاز می‌کند.

توجه داشته باشید که اضافه یا حذف کردن سازنده‌های غیرپیش‌فرض روی **چیدمان یا کارایی** تأثیری ندارد (این در C++98 درست نبود).

اگر احساس کردید می‌خواهید «وکیل زبان» شوید، مفاهیم چیدمان و سادگی (layout و triviality) را در استاندارد (§iso.3.9, §iso.9) مطالعه کنید و به پیامدهای آن‌ها برای برنامه‌نویسان و سازندگان کامپایلر فکر کنید. شاید این کار قبل از اینکه وقت زیادی از شما بگیرد، شما را از این علاقه منصرف کند!
